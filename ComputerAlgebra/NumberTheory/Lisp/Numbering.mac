/* Oliver Kullmann, 10.5.2018 (Swansea) */
/* Copyright 2018 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/NumberTheory/Lisp/Numbering.mac
  \brief Numbering pairs of integers etc.

Use by

oklib_load("OKlib/ComputerAlgebra/NumberTheory/Lisp/Numbering.mac");

*/

/*!
\htmlonly
*/

oklib_include("OKlib/ComputerAlgebra/DataStructures/Lisp/Lists.mac")$
oklib_include("OKlib/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/Constructions.mac")$
oklib_include("OKlib/ComputerAlgebra/Hypergraphs/Lisp/SetSystems.mac")$
oklib_include("OKlib/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/BasicOperations.mac")$


/* ****************************
   * Pairs of natural numbers *
   ****************************
*/

/* First all pairs [i,j] with max = 1, then max = 2, ..., each part sorted
by XXX

1. by max (increasing)
2. by second component (increasing)
3. by first component (decreasing)

[1,1],[2,1],[2,2],[1,2],[3,1],[3,2],[3,3],[2,3],[1,3], ...

5 6 7
2 3 8
1 4 9

*/

squarenumbering_orderlessp(x,y) := lmax(x)<lmax(y) or
  (lmax(x)=lmax(y) and second(x)<second(y)) or
  (lmax(x)=lmax(y) and second(x)=second(y) and first(x)>first(y))$

/*
sort(all_tuples_l([1,2,3,4,5],2),squarenumbering_orderlessp);
 [[1,1],
  [2,1],[2,2],[1,2],
  [3,1],[3,2],[3,3],[2,3],[1,3],
  [4,1],[4,2],[4,3],[4,4],[3,4],[2,4],[1,4],
  [5,1],[5,2],[5,3],[5,4],[5,5],[4,5],[3,5],[2,5],[1,5]]
*/

kill(qv)$
declare(qv, noun)$
declare(qv, posfun)$
qv_var([x]) := apply(nounify(qv),x)$

partialsol_nqueens_p(S) := setp(S) and every_s(lambda([p], listp(p) and
  length(p)=2 and naturalp(first(p)) and naturalp(second(p))), S) and
  every_s(lambda([P], block([p1:first(P),p2:second(P)], first(p1)#first(p2)
    and second(p1)#second(p2) and
    abs(first(p1)-first(p2))#abs(second(p1)-second(p2)))), powerset(S,2))$

/* Translate a set of pairs [i,j] into variables qv(i,j): */
qvmap(SP) := map(lambda([p], apply(qv_var,p)), SP)$

/* Translate a solution as a set of pairs into a DNF-clause: */
extendsol_nqueens(S) := block([N:lmax(map(first,S)),D],
  D : setdifference(all_tuples(setn(N),2),S), union(qvmap(S), comp_sl(qvmap(D))))$
/* The inverse, just keeping the positive literals: */
shrinksol_nqueens(S) := pospart_c(S)$

nqueens_amo_row_cl(N,i) := create_list({-qv_var(i,j1),-qv_var(i,j2)}, j1,1,N-1, j2,j1+1,N)$
nqueens_amo_rows_cl(N) := lappend(create_list(nqueens_amo_row_cl(N,i), i,1,N))$

nqueens_amo_column_cl(N,j) := create_list({-qv_var(i1,j),-qv_var(i2,j)}, i1,1,N-1, i2,i1+1,N)$
nqueens_amo_columns_cl(N) := lappend(create_list(nqueens_amo_column_cl(N,j), j,1,N))$

amo_cs(V) := map(comp_sl, powerset(V,2))$

samerow_p(p1,p2) := is(first(p1) = first(p2))$
samecolumn_p(p1,p2) := is(second(p1) = second(p2))$
samediag_p(p1,p2) := is(second(p1)-first(p1) = second(p2)-first(p2))$
sameantidiag_p(p1,p2) := is(second(p1)+first(p1) = second(p2)+first(p2))$

nqueens_fcs(N,M) := block([SQ : qvmap(cartesian_product(setn(N),setn(M)))],
  [SQ, union(
     lunion(map(amo_cs, equiv_classes(SQ, samerow_p))),
     lunion(map(amo_cs, equiv_classes(SQ, samecolumn_p))),
     lunion(map(amo_cs, equiv_classes(SQ, samediag_p))),
     lunion(map(amo_cs, equiv_classes(SQ, sameantidiag_p))),
     equiv_classes(SQ, samerow_p),
     equiv_classes(SQ, samecolumn_p))])$
nqueens_cs(N,M) := fcs2cs(nqueens_fcs(N,M))$

/* Transforming an N-queens-clause C into a square combinatorial matrix: */
queenscl2scom(C,N) := [setn(N), lambda([i,j], if elementp(qv_var(i,j),C) then +1 elseif elementp(-qv_var(i,j),C) then -1 else 0)]$
/* Now into a Maxima matrix: */
queenscl2m(C,N) := scom2m(queenscl2scom(C,N))$

/* Checking whether a clause lies completely in some row or column: */
isrowcolumn_p(C) := block([V:var_c(C)], is(length(map(first,V))=1) or
  is(length(map(second,V))=1))$
isnotrowcolumn_p(C) := not isrowcolumn_p(C)$

/* The eight standard symmetries: */
/* First the two generating symmetries: */
nqueens_rotate(i,j,N) := [N-j+1,i]$
/* For a point p: */
nqueens_rotate_p(p,N) := nqueens_rotate(first(p),second(p),N)$
nqueens_hmirror(i,j,N) := [N-i+1,j]$
nqueens_hmirror_p(p,N) := nqueens_hmirror(first(p),second(p),N)$
/* Now the m-times rotated versions ("iterated"): */
/* Rotation by m*90 degrees: */
nqueens_irotate(i,j,N,m) := block([p:[i,j]], thru mod(m,N) do p : nqueens_rotate(first(p),second(p),N), p)$
nqueens_irotate_p(p,N,m) := (thru mod(m,N) do p : nqueens_rotate_p(p,N), p)$
/* Mirroring at horizontal midline, antidiagonal, vertical midline, diagonal: */
nqueens_ihmirror(i,j,N,m) := block([p:nqueens_hmirror(i,j,N)],
  nqueens_irotate(first(p),second(p),N,m))$
nqueens_ihmirror_p(p,N,m) := (p:nqueens_hmirror_p(p,N), nqueens_irotate_p(p,N,m))$
/* Versions for sets S of points: */
nqueens_rotate_s(S,N) := map(lambda([p],nqueens_rotate_p(p,N)), S)$
nqueens_irotate_s(S,N,m) := map(lambda([p],nqueens_irotate_p(p,N,m)), S)$
nqueens_hmirror_s(S,N) := map(lambda([p],nqueens_hmirror_p(p,N)), S)$
nqueens_ihmirror_s(S,N,m) := map(lambda([p],nqueens_ihmirror_p(p,N,m)), S)$
/* The orbit of point [i,j]: */
nqueens_orbit(i,j,N) := setify(append(
  create_list(nqueens_irotate(i,j,N,m),m,0,3),
  create_list(nqueens_ihmirror(i,j,N,m),m,0,3)))$
nqueens_orbit_p(p,N) := setify(append(
  create_list(nqueens_irotate_p(p,N,m),m,0,3),
  create_list(nqueens_ihmirror_p(p,N,m),m,0,3)))$
/* The orbit of a set S of points: */
nqueens_orbit_s(S,N) := setify(append(
  create_list(nqueens_irotate_s(S,N,m),m,0,3),
  create_list(nqueens_ihmirror_s(S,N,m),m,0,3)))$

/* Extend map f_(i,j), implicitly defined on variables qv(i,j), to literals: */
nqueens_extvarlit(f_,x) := block([i,j,p], if posp(x) then (i:first(x),j:second(x),p:f_(i,j),qv_var(first(p),second(p))) else (i:first(-x),j:seccond(-x),p:f_(i,j),-qv_var(first(p),second(p))))$

/* Transform a set V of variables qv(i,j) in the corresponding set of pairs [i,j]: */
nqueens_extrpairs(V) := map(lambda([v], [first(v),second(v)]), V)$

/* Testing whether clauses C, D are isomorphic (there is a symmetry mapping, which transforms C to D): */
nqueens_isoc_p(C,D,N) := block(
 [PC:nqueens_extrpairs(pospart_c(C)), NC:nqueens_extrpairs(comp_sl(negpart_c(C))),
  PD:nqueens_extrpairs(pospart_c(D)), ND:nqueens_extrpairs(comp_sl(negpart_c(D))),
  solved:false],
  if length(PC)#length(PD) or length(NC)#length(ND) then return(false),
  thru 4 do (PC:nqueens_rotate_s(PC,N), NC:nqueens_rotate_s(NC,N),
    if PC=PD and NC=ND then (solved:true, return(true))),
  if solved then return(true),
  PC:nqueens_hmirror_s(PC,N), NC:nqueens_hmirror_s(NC,N),
  thru 4 do (PC:nqueens_rotate_s(PC,N), NC:nqueens_rotate_s(NC,N),
    if PC=PD and NC=ND then (solved:true, return(true))),
  if solved then return(true) else return(false))$


/* The total number of solutions for 1 <= N <= 27: */
nqueens_counts : [1,0,0,2,10,4,40,92,352,724,
 2680,14200,73712,365596,2279184,14772512,95815104,666090624,4968057848,39029188884,
 314666222712,2691008701644,24233937684440,227514171973736,2207893435808352,22317699616364044,234907967154122528]$
/* https://oeis.org/A000170 */
/* The maximal entry is ~ 2.35*10^17. */
/* Approximation formula (according to https://oeis.org/A000170): */
nqueens_approx_count(N) := N! / 2.54^N$
/* The number of isomorphism classes of solutions (classes of symmetric solutions) for 1 <= N <= 27: */
iso_nqueens_counts : [1,0,0,1,2,1,6,12,46,92,
 341,1787,9233,45752,285053,1846955,11977939,83263591,621012754,4878666808,
 39333324973,336376244042,3029242658210,28439272956934,275986683743434,2789712466510289,29363495934315694]$
/* https://oeis.org/A002562 */


/*!
\endhtmlonly
*/
