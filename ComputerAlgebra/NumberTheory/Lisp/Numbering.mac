/* Oliver Kullmann, 10.5.2018 (Swansea) */
/* Copyright 2018 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/NumberTheory/Lisp/Numbering.mac
  \brief Numbering pairs of integers etc.

XXX Currently also functions concerning N-Queens

Use by

oklib_load("OKlib/ComputerAlgebra/NumberTheory/Lisp/Numbering.mac");

*/

/*!
\htmlonly
*/

oklib_include("OKlib/ComputerAlgebra/DataStructures/Lisp/Lists.mac")$
oklib_include("OKlib/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/Constructions.mac")$
oklib_include("OKlib/ComputerAlgebra/Hypergraphs/Lisp/SetSystems.mac")$
oklib_include("OKlib/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/BasicOperations.mac")$


/* ****************************
   * Pairs of natural numbers *
   ****************************
*/

/* First all pairs [i,j] with max = 1, then max = 2, ..., each part sorted

1. by max (increasing)
2. by second component (increasing)
3. by first component (decreasing)

[1,1],[2,1],[2,2],[1,2],[3,1],[3,2],[3,3],[2,3],[1,3], ...

5 6 7
2 3 8
1 4 9

*/

squarenumbering_orderlessp(x,y) := lmax(x)<lmax(y) or
  (lmax(x)=lmax(y) and second(x)<second(y)) or
  (lmax(x)=lmax(y) and second(x)=second(y) and first(x)>first(y))$

/*
L : sort(all_tuples_l([1,2,3,4,5],2),squarenumbering_orderlessp);
 [[1,1],
  [2,1],[2,2],[1,2],
  [3,1],[3,2],[3,3],[2,3],[1,3],
  [4,1],[4,2],[4,3],[4,4],[3,4],[2,4],[1,4],
  [5,1],[5,2],[5,3],[5,4],[5,5],[4,5],[3,5],[2,5],[1,5]]
*/

rank_squarenumbering(x,y) := block([m:max(x,y), s],
  s : (m-1)^2,
  if m=x then s+y else s+2*m-x)$
rank_squarenumbering_p(p) := apply(rank_squarenumbering, p)$

/*
map(rank_squarenumbering_p, L);
  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]
*/

enum_squarenumbering(n) := block([r:ceiling(n^(1/2)), d],
  d : r^2-n,
  if d<r then [d+1,r] else [r,2*r-d-1])$

/* is(create_list(enum_squarenumbering(n),n,1,25) = L);
  true
*/


/* The N-Queens graph and SAT-representation */

kill(qv)$
declare(qv, noun)$
declare(qv, posfun)$
qv_var([x]) := apply(nounify(qv),x)$

/* Whether there is some N >= 0 such that S is a partial solution of the
   N-queens problem for N, using pairs [i,j] for queens-positions:
*/
partialsol_nqueens_p(S) := setp(S) and every_s(lambda([p], listp(p) and
  length(p)=2 and naturalp(first(p)) and naturalp(second(p))), S) and
  every_s(lambda([P], block([p1:first(P),p2:second(P)], first(p1)#first(p2)
    and second(p1)#second(p2) and
    abs(first(p1)-first(p2))#abs(second(p1)-second(p2)))), powerset(S,2))$
/*
partialsol_nqueens_p({[1,1],[3,2]});
  true
partialsol_nqueens_p({[1,1],[3,3]});
  false
partialsol_nqueens_p({[1,2],[2,4],[3,1],[4,3]});
  true
*/

/* Translate a set of pairs [i,j] into variables qv(i,j): */
qvmap(SP) := map(lambda([p], apply(qv_var,p)), SP)$

/* Translate a solution as a set of pairs into a DNF-clause: */
extendsol_nqueens(S) := block([N:lmax(map(first,S)),D],
  D : setdifference(all_tuples(setn(N),2),S), union(qvmap(S), comp_sl(qvmap(D))))$
/*
extendsol_nqueens({[1,2],[2,4],[3,1],[4,3]});
  {-qv(1,1),qv(1,2),-qv(1,3),-qv(1,4),-qv(2,1),-qv(2,2),-qv(2,3),qv(2,4),
   qv(3,1),-qv(3,2),-qv(3,3),-qv(3,4),-qv(4,1),-qv(4,2),qv(4,3),-qv(4,4)}
*/
/* The inverse, just keeping the positive literals (but as variables qv(i,j),
   not as pairs [i,j]): */
shrinksol_nqueens(S) := pospart_c(S)$
/*
shrinksol_nqueens(extendsol_nqueens({[1,2],[2,4],[3,1],[4,3]}));
  {qv(1,2),qv(2,4),qv(3,1),qv(4,3)}
*/

/* For a set V of variables, the clause expressing "at most one (AMO) of them":
*/
amo_cs(V) := comp_cs(powerset(V,2))$
/*
amo_cs({});
  {}
amo_cs({1,2});
  {{-2,-1}}
amo_cs({1,2,3});
  {{-3,-2},{-3,-1},{-2,-1}}
*/

/* The equivalence relations on the pairs [i,j] as well as on variables
   qv(i,j) as fundamental for the Queens-graph and Queens-constraints:
*/
samerow_p(p1,p2) := is(first(p1) = first(p2))$
samecolumn_p(p1,p2) := is(second(p1) = second(p2))$
samediag_p(p1,p2) := is(second(p1)-first(p1) = second(p2)-first(p2))$
sameantidiag_p(p1,p2) := is(second(p1)+first(p1) = second(p2)+first(p2))$

queens_g(N,M) :=  block([SQ : cartesian_product(setn(N),setn(M))],
  [SQ, union(
     lunion(map(lambda([K],powerset(K,2)),equiv_classes(SQ, samerow_p))),
     lunion(map(lambda([K],powerset(K,2)),equiv_classes(SQ, samecolumn_p))),
     lunion(map(lambda([K],powerset(K,2)),equiv_classes(SQ, samediag_p))),
     lunion(map(lambda([K],powerset(K,2)),equiv_classes(SQ, sameantidiag_p))))])$

nqueens_fcs(N,M) := block([SQ : qvmap(cartesian_product(setn(N),setn(M)))],
  [SQ, union(
     lunion(map(amo_cs, equiv_classes(SQ, samerow_p))),
     lunion(map(amo_cs, equiv_classes(SQ, samecolumn_p))),
     lunion(map(amo_cs, equiv_classes(SQ, samediag_p))),
     lunion(map(amo_cs, equiv_classes(SQ, sameantidiag_p))),
     if N<=M then equiv_classes(SQ, samerow_p) else {},
     if M<=N then equiv_classes(SQ, samecolumn_p) else {}
   )])$
nqueens_cs(N,M) := fcs2cs(nqueens_fcs(N,M))$

/* Transforming an N-queens-clause C into a square combinatorial matrix: */
queenscl2scom(C,N) := [setn(N), lambda([i,j], if elementp(qv_var(i,j),C) then +1 elseif elementp(-qv_var(i,j),C) then -1 else 0)]$
/* Now into a Maxima matrix: */
queenscl2m(C,N) := scom2m(queenscl2scom(C,N))$

/* Checking whether a clause lies completely in some row or column: */
isrowcolumn_p(C) := block([V:var_c(C)], is(length(map(first,V))=1) or
  is(length(map(second,V))=1))$
isnotrowcolumn_p(C) := not isrowcolumn_p(C)$

/* The eight standard symmetries: */
/* First the two generating symmetries: */
nqueens_rotate(i,j,N) := [N-j+1,i]$
/* For a point p: */
nqueens_rotate_p(p,N) := nqueens_rotate(first(p),second(p),N)$
nqueens_hmirror(i,j,N) := [N-i+1,j]$
nqueens_hmirror_p(p,N) := nqueens_hmirror(first(p),second(p),N)$
/* Now the m-times rotated versions ("iterated"): */
/* Rotation by m*90 degrees: */
nqueens_irotate(i,j,N,m) := block([p:[i,j]], thru mod(m,4) do p : nqueens_rotate(first(p),second(p),N), p)$
nqueens_irotate_p(p,N,m) := (thru mod(m,4) do p : nqueens_rotate_p(p,N), p)$
/* Mirroring at horizontal midline, antidiagonal, vertical midline, diagonal: */
nqueens_ihmirror(i,j,N,m) := block([p:nqueens_hmirror(i,j,N)],
  nqueens_irotate(first(p),second(p),N,m))$
nqueens_ihmirror_p(p,N,m) := (p:nqueens_hmirror_p(p,N), nqueens_irotate_p(p,N,m))$
/* Versions for sets S of points: */
nqueens_rotate_s(S,N) := map(lambda([p],nqueens_rotate_p(p,N)), S)$
nqueens_irotate_s(S,N,m) := map(lambda([p],nqueens_irotate_p(p,N,m)), S)$
nqueens_hmirror_s(S,N) := map(lambda([p],nqueens_hmirror_p(p,N)), S)$
nqueens_ihmirror_s(S,N,m) := map(lambda([p],nqueens_ihmirror_p(p,N,m)), S)$
/* The orbit of point [i,j]: */
nqueens_orbit(i,j,N) := setify(append(
  create_list(nqueens_irotate(i,j,N,m),m,0,3),
  create_list(nqueens_ihmirror(i,j,N,m),m,0,3)))$
nqueens_orbit_p(p,N) := setify(append(
  create_list(nqueens_irotate_p(p,N,m),m,0,3),
  create_list(nqueens_ihmirror_p(p,N,m),m,0,3)))$
/* The orbit of a set S of points: */
nqueens_orbit_s(S,N) := setify(append(
  create_list(nqueens_irotate_s(S,N,m),m,0,3),
  create_list(nqueens_ihmirror_s(S,N,m),m,0,3)))$

/* Extend map f_(i,j), implicitly defined on variables qv(i,j), to literals: */
nqueens_extvarlit(f_,x) := block([i,j,p], if posp(x) then (i:first(x),j:second(x),p:f_(i,j),qv_var(first(p),second(p))) else (i:first(-x),j:seccond(-x),p:f_(i,j),-qv_var(first(p),second(p))))$

/* Transform a set V of variables qv(i,j) in the corresponding set of pairs [i,j]: */
nqueens_extrpairs(V) := map(lambda([v], [first(v),second(v)]), V)$

/* Testing whether clauses C, D are isomorphic (there is a symmetry mapping, which transforms C to D): */
nqueens_isoc_p(C,D,N) := block(
 [PC:nqueens_extrpairs(pospart_c(C)), NC:nqueens_extrpairs(comp_sl(negpart_c(C))),
  PD:nqueens_extrpairs(pospart_c(D)), ND:nqueens_extrpairs(comp_sl(negpart_c(D))),
  solved:false],
  if length(PC)#length(PD) or length(NC)#length(ND) then return(false),
  thru 4 do (PC:nqueens_rotate_s(PC,N), NC:nqueens_rotate_s(NC,N),
    if PC=PD and NC=ND then (solved:true, return(true))),
  if solved then return(true),
  PC:nqueens_hmirror_s(PC,N), NC:nqueens_hmirror_s(NC,N),
  thru 4 do (PC:nqueens_rotate_s(PC,N), NC:nqueens_rotate_s(NC,N),
    if PC=PD and NC=ND then (solved:true, return(true))),
  if solved then return(true) else return(false))$


/* The total number of solutions for 1 <= N <= 27: */
nqueens_counts : [1,0,0,2,10,4,40,92,352,724,
 2680,14200,73712,365596,2279184,14772512,95815104,666090624,4968057848,39029188884,
 314666222712,2691008701644,24233937684440,227514171973736,2207893435808352,22317699616364044,234907967154122528]$
/* https://oeis.org/A000170 */
/* The maximal entry is ~ 2.35*10^17. */
/* Approximation formula (according to https://oeis.org/A000170): */
nqueens_approx_count(N) := N! / 2.54^N$
/* The number of isomorphism classes of solutions (classes of symmetric solutions) for 1 <= N <= 27: */
iso_nqueens_counts : [1,0,0,1,2,1,6,12,46,92,
 341,1787,9233,45752,285053,1846955,11977939,83263591,621012754,4878666808,
 39333324973,336376244042,3029242658210,28439272956934,275986683743434,2789712466510289,29363495934315694]$
/* https://oeis.org/A002562 */


/*!
\endhtmlonly
*/
