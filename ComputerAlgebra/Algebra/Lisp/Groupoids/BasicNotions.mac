/* Oliver Kullmann, 6.7.2008 (Swansea) */
/* Copyright 2008, 2009 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Algebra/Lisp/Groupoids/BasicNotions.mac
  \brief Basic notions (like test-predicates and conversions) for groupoids

Use by

oklib_load("Transitional/ComputerAlgebra/Algebra/Lisp/Groupoids/BasicNotions.mac");

*/

/*!
\htmlonly
*/

oklib_include("Transitional/ComputerAlgebra/Algebra/Lisp/Groupoids/Associativity.mac")$
oklib_include("Transitional/ComputerAlgebra/Algebra/Lisp/Groupoids/NeutralElements.mac")$
oklib_include("Transitional/ComputerAlgebra/Algebra/Lisp/Groupoids/InvertibleElements.mac")$
oklib_include("Transitional/ComputerAlgebra/Algebra/Lisp/Groupoids/UniquelySolvableElements.mac")$
oklib_include("Transitional/ComputerAlgebra/Algebra/Lisp/Groupoids/Commutativity.mac")$
oklib_include("Transitional/ComputerAlgebra/CombinatorialMatrices/Lisp/Basics.mac")$


/* ***********************
   * Fundamental notions *
   ***********************
*/

/* ************************************
   * Checking the defining properties *
   ************************************
*/

/* Checking whether compo is a binary law of composition on set X: */
compo_p(compo,X) := block(
 [e : errcatch(
   subsetp(map(lambda([P],apply(compo,P)),cartesian_product(X,X)),X))],
 not emptyp(e) and e[1])$

/* Groupoids: */
grd_p(V) := listp(V) and is(length(V)=2) and setp(V[1]) and compo_p(V[2],V[1])$
ugrd_p(V) := listp(V) and is(length(V)=3) and grd_p([V[1],V[2]]) and 
  elementp(V[3],V[1]) and neutral_el_grd(V,V[3])$
cgrd_p(V) := grd_p(V) and commutative_bydef_grd(V)$
cugrd_p(V) := ugrd_p(V) and commutative_bydef_grd(V)$

/* Semigroups and monoids: */
sgr_p(S) := grd_p(S) and associative_bydef_grd(S)$
csgr_p(S) := sgr_p(S) and commutative_bydef_grd(S)$
mon_p(M) := listp(M) and is(length(M)=3) and sgr_p([M[1],M[2]]) and 
  elementp(M[3],M[1]) and neutral_el_grd(M,M[3])$
cmon_p(M) := mon_p(M) and commutative_bydef_grd(M)$

/* Quasigroups: */
qgrp_p(Q) := grd_p(Q) and uniquelysolvable_bydef_grd(Q)$
/* Remark: qgrp_p(Q) = ls_p(Q). */
/* Commutative quasigroups: */
cqgrp_p(Q) := qgrp_p(Q) and commutative_bydef_grd(Q)$
/* Unital quasigroups (also known as "loops"): */
uqgrp_p(L) := ugrd_p(L) and uniquelysolvable_bydef_grd(ugrd2grd(L))$
/* Commutative unital quasigroups: */
cuqgrp_p(L) := uqgrp_p(L) and commutative_bydef_grd(ugrd2grd(L))$

/* Groups: */
grp_p(G) := qgrp_p(G) and associative_bydef_grd(G) and not emptyp(G[1])$
cgrp_p(G) := grp_p(G) and commutative_bydef_grd(G)$
ugrp_p(G) := uqgrp_p(G) and associative_bydef_grd(G)$
cugrp_p(G) := ugrp_p(G) and commutative_bydef_grd(G)$
ugrpi_p(G) := ugrd(rest(G,-1)) and inversion_ugrd(G,G[4])$
cugrpi_p(G) := ugrpi_p(G) and commutative_bydef_grd(G)$


/* *********************
   * Checking equality *
   *********************
*/

grd_equalp(V1,V2) := scom_equalp(V1,V2)$
ugrd_equalp(V1,V2) := grd_equalp(rest(V1,-1),rest(V2,-1)) and is(V1[3]=V2[3])$


/* *************
   * Downcasts *
   *************
*/

ugrd2grd(V) := rest(V,-1)$

ugrpi2ugrp(G) := rest(G,-1)$
ugrpi2grp(G) := rest(G,-2)$
ugrp2grp(G) := rest(G,-1)$


/* **************
   * Promotions *
   **************
*/

/* grp2ugrp(G), grp2ugrpi(G), ugrp2ugrpi(G) : 
   here we have the typical three possibilities ... 
*/


/* ***************
   * Conversions *
   ***************
*/

/* Between combinatorial square matrices and groupoids: */
scom2grd(M) := M$
grd2scom(V) := V$
m2grd(M) := scom2grd(m2scom(M))$
grd2m(V) := scom2m(grd2scom(V))$
/* Prerequisite: all values of M must be indices.
*/


/* ******************
   * Basic examples *
   ******************
*/

/* A smallest non-associated groupoid: */
non_assoc_2_grd : m2grd(matrix([2,2],[1,2]))$


/*!
\endhtmlonly
*/

