/* Oliver Kullmann, 8.12.2007 (Swansea) */
/* Copyright 2007, 2008, 2009 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Hypergraphs/Lisp/Basics.mac
  \brief Basic Maxima functions for hypergraphs

Use by

oklib_load("OKlib/ComputerAlgebra/Hypergraphs/Lisp/Basics.mac");

*/

/*!
\htmlonly
*/

oklib_include("OKlib/ComputerAlgebra/Hypergraphs/Lisp/SetSystems.mac")$
oklib_include("OKlib/ComputerAlgebra/CombinatorialMatrices/Lisp/Basics.mac")$
oklib_include("OKlib/ComputerAlgebra/DataStructures/Lisp/Lists.mac")$


/* ***********************
   * Fundamental notions *
   ***********************
*/

/*
 A "hypergraph" is a pair (V,E), where V is a set and E a subset of
 the powerset of V.
*/

/*
 A "general hypergraph" is a triple (V,E,f), where V, E are sets, while
 f is a function such that f(e) for e in E is a subset of V.
*/

/* ************************************
   * Checking the defining properties *
   ************************************
*/

ohg_p(G) := listp(G) and is(length(G)=2) and listnorep_p(G[1]) and
  listnorep_p(G[2]) and 
  block([V : setify(G[1])], every(lambda([H],subsetp(H,V)),G[2]))$


/* *********************
   * Checking equality *
   *********************
*/

/* Equality test for general hypergraphs: */
/* RENAME: ghg_equalp */
ghypequalp(G1,G2) := is(G1[1] = G2[1]) and is(G1[2] = G2[2]) and
 block([break : false],
  for e in G1[2] unless break do
    if G1[3](e) # G2[3](e) then break : true,
  return(not break))$
ghg_equalp(G1,G2) := is(G1[1] = G2[1]) and is(G1[2] = G2[2]) and
 block([break : false],
  for e in G1[2] unless break do
    if G1[3](e) # G2[3](e) then break : true,
  return(not break))$


/* **************
   * Promotions *
   **************
*/

hg2ohg(G) := map(listify,G)$

/* RENAME: hg2ghg */
promote_general_hypergraph(G) := [G[1], G[2], identity]$
hg2ghg(G) := [G[1], G[2], identity]$


/* *************
   * Downcasts *
   *************
*/

ohg2hg(G) := map(setify,G)$

ghg2hg(G) := [G[1], map(G[3],G[2])]$


/* ************* **
   * Conversions *
   ***************
*/

/* Promotes a set system to a hypergraph: */
/* RENAME: ses2hg(S) */
setsystem2hg(S) := [lunion(S), S]$
ses2hg(S) := setsystem2hg(S)$

/* Converts a list of sets to a hypergraph: */
listsets2hg(L) := setsystem2hg(setify(L))$

/* Converts a list of sets to an ordered general hypergraph: */
listsets2oghg(L) := [listify(lunion(L)), L, identity]$

/* The combinatorial (hyper)edge-vertex matrix of a hypergraph: */
/* RENAME: edge_vertex_com_hg */
edge_vertex_com_hyp(G) := [G[2], G[1], lambda([H,v], 
  if elementp(v, H) then 1 else 0)]$
edge_vertex_com_hg(G) := edge_vertex_com_hyp(G)$

/* The (hyper)edge intersection matrix (as a square combinatorial matrix)
   of a hypergraph: */
/* RENAME: edge_int_com_hg */
edge_int_com_hyp(G) := block([M : edge_vertex_com_hyp(G)],
 return(com2scom(prod_com(M, trans(M)))))$
edge_int_com_hg(G) := edge_int_com_hyp(G)$

/* The vertex intersection matrix (as a square combinatorial matrix)
   of a hypergraph (for each pair of vertices the number of common
   occurrences): */
/* RENAME: vertex_int_com_hg */
vertex_int_com_hyp(G) := block([M : edge_vertex_com_hyp(G)],
 return(com2scom(prod_com(trans(M), M))))$
vertex_int_com_hg(G) := vertex_int_com_hyp(G)$


/* *****************
   * Constructions *
   *****************
*/

/* The union of a list L of hypergraphs: */
union_hg([L]) := [lunion(map(first,L)), lunion(map(second,L))]$

/* The k-section of a hypergraph: */
/* RENAME: section_hg */
section_hyp(G,k) := [G[1], family_sets_union(G[2], lambda([H], powerset(H,k)))]$
section_hg(G,k) := section_hyp(G,k)$

/* The edge-wise complement of a hypergraph: */
/* RENAME: ecomp_hg */
ecomp_hyp(G) := [G[1], ecomp(G[2],G[1])]$
ecomp_hg(G) := ecomp_hyp(G)$

/* The closure under subset-formation of a hypergraph: */
/* RENAME: subset_closure_hg */
subset_closure_hyp(G) := [G[1], subset_closure(G[2])]$
subset_closure_hg(G) := subset_closure_hyp(G)$

/* The dual of a general hypergraph: */
/* RENAME: dual_ghg */
dual_general_hypergraph(G) := [G[2], G[1], buildq([V : G[2], f : G[3]],
 lambda([e], subset(V, lambda([v], elementp(e,f(v))))))]$
dual_ghg(G) := dual_general_hypergraph(G)$

/* The k-edge-graph, a k-graph, that is, a k-uniform hypergraph, having as 
    vertices the hyperedges of G and as hyperedges k-sets of hyperedges of G
    with non-empty intersection:
*/
/* RENAME: edge_k_hg */
edge_k_hyp(G,k) := 
 if k=0 then if emptyp(G[1]) then [G[2],{}] else [G[2],{{}}]
 elseif k=1 then [G[2], singletons(disjoin({},G[2]))] else
 [G[2], subset(powerset(G[2],k), lambda([H], not emptyp(lintersection(H))))]$
edge_k_hg(G,k) := edge_k_hyp(G,k)$
/* The edge-graph of a hypergraph: */
/* RENAME: edge_g_hg */
edge_g_hyp(G) := edge_k_hyp(G,2)$
edge_g_hg(G) := edge_g_hyp(G)$
/* The anti-k-edge-graph, a k-graph with vertices the hyperedges of G and as
   hyperedges k-sets of hyperedges of G with empty intersection:
*/
/* RENAME: anti_edge_k_hg */
anti_edge_k_hyp(G,k) := 
 if k=0 then if emptyp(G[1]) then [G[2],{{}}] else [G[2],{}]
 elseif k=1 then [G[2], singletons(intersection({{}},G[2]))] else
 [G[2], subset(powerset(G[2],k), lambda([H], emptyp(lintersection(H))))]$
anti_edge_k_hg(G,k) := anti_edge_k_hyp(G,k)$
/* The Kneser-graph of a hypergraph: */
/* RENAME: kneser_g_hg */
kneser_g_hyp(G) := anti_edge_k_hyp(G,2)$
kneser_g_hg(G) := kneser_g_hyp(G)$

/* For set-systems S1, S2 the "general subsumption hypergraph", with vertices
   the elements of S1, hyperedge-labels the elements of S2, and for H in S2
   the vertex set is given by the elements of S1 contained in H.
*/
subsumption_ghg(S1,S2) :=
 [S1, S2, buildq([S1,S2], lambda([H], subset(S1, lambda([S], subsetp(S,H)))))]$


/* *****************
   * Connectedness *
   *****************
*/

/* Computes the set system of vertex sets of connnected components: */
/* RENAME: components_hg(G) */
components_hypergraph(G) := unify_nondisjoint_elements(G[2])$
components_hg(G) := components_hypergraph(G)$
/* RENAME: components_ghg(G) */
components_general_hypergraph(G) := components_hypergraph(ghg2hg(G))$
components_ghg(G) := components_general_hypergraph(G)$

/* Whether a hypergraph is connected: */
/* RENAME: connected_hg_p(G) */
is_connected_hypergraph(G) := is(length(components_hypergraph(G)) <= 1)$
connected_hg_p(G) := is_connected_hypergraph(G)$

/*!
\endhtmlonly
*/
