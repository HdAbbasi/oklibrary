/* Oliver Kullmann, 16.1.2009 (Swansea) */
/* Copyright 2009 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Graphs/Lisp/Bicliques/BasicNotions.mac
  \brief Functions regarding biclique in multigraphs

Use by

oklib_load("OKlib/ComputerAlgebra/Graphs/Lisp/Bicliques/BasicNotions.mac");

*/

/*!
\htmlonly
*/

oklib_include("OKlib/ComputerAlgebra/Graphs/Lisp/Basic.mac")$


/* ***********************
   * Fundamental notions *
   ***********************
*/

/* A "vertex-biclique" ("vbc") in a graph is a pair of sets of vertices
   forming a biclique.
   An "ordered vertex-biclique" ("ovbc") uses lists of vertices instead.
*/

/* The following tests assume that G is a well-formed graph
   (of its type).
*/

vbc_gl_p(B,G) := listp(B) and is(length(B)=2) and
 every(setp, B) and disjointp(B[1],B[2]) and
 every(lambda([b], subsetp(b,G[1])), B) and
 subsetp(map(setify,cartesian_product(B[1],B[2])), G[2])$

/* CHANGE: the concept of a multigraph changed.
   Instead of the subset-test we check then whether the edge-function
   is non-zero on all potential edges.
 */
vbc_mugl_p(B,G) := listp(B) and is(length(B)=2) and
 every(setp, B) and disjointp(B[1],B[2]) and
 every(lambda([b], subsetp(b,G[1])), B) and
 subsetp(map(setify,cartesian_product(B[1],B[2])), G[2])$

vbc_gg_p(B,G) := listp(B) and is(length(B)=2) and
 every(setp, B) and disjointp(B[1],B[2]) and
 every(lambda([b], subsetp(b,G[1])), B) and
 subsetp(map(setify,cartesian_product(B[1],B[2])), map(G[3],G[2]))$


vbc_dgl_p(B,G) := listp(B) and is(length(B)=2) and
 every(setp, B) and disjointp(B[1],B[2]) and
 every(lambda([b], subsetp(b,G[1])), B) and
 subsetp(cartesian_product(B[1],B[2]), G[2])$


/* An "edge-biclique" ("ebc") in a graph is a set of edges
   forming a biclique.
   An "ordered edge-biclique" ("oebc") uses lists of edges instead.
*/

/* The following tests assume that G is a well-formed graph
   (of its type).
*/

ebc_gg_p(B,G) := setp(B) and subsetp(B,G[2]) and
 block([S : edge_induced_subgraph_gg(B,G)],
  not parallel_edges_gg_p(S) and completebipartite_gg_p(S))$


/* Given a vertex biclique B in G, extend it (somehow) to a maximal biclique:
*/
maximal_bc_gl(B,G) := if emptyp(G[2]) then B else
block(
  if B = [{},{}] then 
    B : [{first_element(first_element(G[2]))},
         {second_element(first_element(G[2]))}]
  elseif (not emptyp(B[1]) and emptyp(B[2])) then block(
   [restv : listify(setdifference(G[1],B[1]))],
    for i : 1 thru length(restv) do
      if subsetp(map(setify,cartesian_product(B[1],{restv[i]})),G[2]) then 
        B[2] : {restv[i]})
  elseif(emptyp(B[1]) and not emptyp(B[2])) then block(
   [restv2 : listify(setdifference(G[1],B[2]))],
    for i : 1 thru length(restv2) do
      if subsetp(map(setify,cartesian_product(B[2],{restv2[i]})),G[2]) then 
        B[1] : {restv2[i]}),
  /* Now established: B[1] and B[2] are not empty. */
  for v in setdifference(G[1],union(B[1],B[2])) do 
    if vbc_gl_p([adjoin(v,B[1]),B[2]],G) then
      B[1] : adjoin(v,B[1])
    else if vbc_gl_p([B[1],adjoin(v,B[2])],G) then
      B[2] : adjoin(v,B[2]),
  return(B))$

/* max_bc_cover_gl takes a graph with loops G and
   returns a biclique partition of maximal bicliques of G.
   It is not too hard to show that this sometimes of a size less than
   the minimum biclique parition number of the graph G */

max_bc_cover_gl(G) := block([GNL : G, i, LB, rest, fedge, reiterate, induMB],
  LB : [],
  EP : {},
  GNL : gl2g(G),
  rest : setdifference(GNL[2],EP),
  reiterate : not(rest = {}),
  for i : 1 while reiterate = true do block([B, S1, S2, MB],
    fedge : listify(rest)[1],
    S1 : {listify(fedge)[1]},
    S2 : {listify(fedge)[2]},
    B : [S1,S2],
    MB : maximal_bc_gl(B,G),
    LB : cons(MB,LB),
    induMB : map(setify,cartesian_product(MB[1],MB[2])),
    rest : setdifference(rest,induMB),
    reiterate : not(rest = {})
  ),
  return(LB))$


/*!
\endhtmlonly
*/
