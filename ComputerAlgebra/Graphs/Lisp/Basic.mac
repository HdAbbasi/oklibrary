/* Oliver Kullmann, 5.1.2008 (Swansea) */
/* Copyright 2008 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Graphs/Lisp/Basic.mac
  \brief Basic graph functionality

Use by

oklib_load("Transitional/ComputerAlgebra/Graphs/Lisp/Basic.mac");

*/

/*!
\htmlonly
*/

oklib_include("Transitional/ComputerAlgebra/Hypergraphs/Lisp/SetSystems.mac")$
oklib_include("Transitional/ComputerAlgebra/DataStructures/Lisp/HashMaps.mac")$
oklib_include("Transitional/ComputerAlgebra/DataStructures/Lisp/Lists.mac")$


/* ***********************
   * Fundamental notions *
   ***********************
*/

/* A "graph" is just a 2-element list, consisting of the set of
   vertices, and a set of 2-element vertex sets.
   A "graph with loops" also allows 1-element vertex sets.
*/

/* A "digraph" is a 2-element list, consisting of the set of vertices,
   and a set of 2-element vertex lists with different elements.
   A "digrap with loops" also allows the elements to be identical.
*/

/* A "multigraph" is a triple [V,E,f] such that [V,E] is a graph,
   and such that f is a function which assigns to every edge its
   cardinality, a natural number (>0).
   A "multigraph with loops" allows loops.
*/

/* A "multi-digraph" is similarly a triple [V,E,f] such that [V,E] is
   is digraph; and a "multi-digraph with loops" allows loops.
*/

/* A "general graph" is a triple [V,E,f], where f maps each element of
   E to a 1- or 2-element subset of V.
   For a "general digraph" f yields lists of length 1 or 2.
*/

/* The ordered versions of all the above notions use lists instead of
   sets, but without repetition.
*/

/* See "Providing basic test cases" in
   ComputerAlgebra/Graphs/Lisp/tests/Basic.mac
   for basic examples.
*/


/* ************************************
   * Checking the defining properties *
   ************************************
*/

g_p(G) := listp(G) and is(length(G)=2) and setp(G[1]) and setp(G[2]) and 
  every(lambda([e], setp(e) and is(length(e) = 2) and subsetp(e,G[1])), G[2])$
gl_p(G) := listp(G) and is(length(G)=2) and setp(G[1]) and setp(G[2]) and 
  every(lambda([e], setp(e) and elementp(length(e),{1,2}) and subsetp(e,G[1])),G[2])$
dg_p(G) := listp(G) and is(length(G)=2) and setp(G[1]) and setp(G[2]) and 
  every(lambda([e], listp(e) and is(length(e)=2 and e[1]#e[2]) and subsetp(setify(e),G[1])), G[2])$
dgl_p(G) := listp(G) and is(length(G)=2) and setp(G[1]) and setp(G[2]) and 
  every(lambda([e], listp(e) and is(length(e)=2) and subsetp(setify(e),G[1])), G[2])$
mug_p(G) := listp(G) and is(length(G)=3) and g_p([G[1],G[2]]) and
  every(lambda([e], block([n : G[3](e)], integerp(n) and n > 0)), G[2])$
mugl_p(G) := listp(G) and is(length(G)=3) and gl_p([G[1],G[2]]) and
  every(lambda([e], block([n : G[3](e)], integerp(n) and n > 0)), G[2])$
mudg_p(G) := listp(G) and is(length(G)=3) and dg_p([G[1],G[2]]) and
  every(lambda([e], block([n : G[3](e)], integerp(n) and n > 0)), G[2])$
mudgl_p(G) := listp(G) and is(length(G)=3) and dgl_p([G[1],G[2]]) and
  every(lambda([e], block([n : G[3](e)], integerp(n) and n > 0)), G[2])$
gg_p(G) := listp(G) and is(length(G)=3) and setp(G[1]) and setp(G[2]) and
  every(lambda([e], block([s : G[3](e)],
    setp(s) and elementp(length(s),{1,2}) and subsetp(s,G[1]))), G[2])$
gdg_p(G) := listp(G) and is(length(G)=3) and setp(G[1]) and setp(G[2]) and
  every(lambda([e], block([l : G[3](e)],
    listp(l) and is(length(l)=2) and subsetp(setify(l),G[1]))), G[2])$

og_p(G) := listp(G) and is(length(G)=2) and listnorep_p(G[1]) and listnorep_p(G[2]) and
  every(lambda([e], setp(e) and is(length(e) = 2) and subsetp(e,setify(G[1]))), G[2])$
ogl_p(G) := listp(G) and is(length(G)=2) and listnorep_p(G[1]) and listnorep_p(G[2]) and 
  every(lambda([e], setp(e) and elementp(length(e),{1,2}) and subsetp(e,setify(G[1]))), G[2])$
odg_p(G) := listp(G) and is(length(G)=2) and listnorep_p(G[1]) and listnorep_p(G[2]) and 
  every(lambda([e], listp(e) and is(length(e)=2 and e[1]#e[2]) and subsetp(setify(e),setify(G[1]))), G[2])$
odgl_p(G) := listp(G) and is(length(G)=2) and listnorep_p(G[1]) and listnorep_p(G[2]) and 
  every(lambda([e], listp(e) and is(length(e)=2) and subsetp(setify(e),setify(G[1]))), G[2])$
omug_p(G) := listp(G) and is(length(G)=3) and og_p([G[1],G[2]]) and
  every(lambda([e], block([n : G[3](e)], integerp(n) and n > 0)), G[2])$
omugl_p(G) := listp(G) and is(length(G)=3) and ogl_p([G[1],G[2]]) and
  every(lambda([e], block([n : G[3](e)], integerp(n) and n > 0)), G[2])$
omudg_p(G) := listp(G) and is(length(G)=3) and odg_p([G[1],G[2]]) and
  every(lambda([e], block([n : G[3](e)], integerp(n) and n > 0)), G[2])$
omudgl_p(G) := listp(G) and is(length(G)=3) and odgl_p([G[1],G[2]]) and
  every(lambda([e], block([n : G[3](e)], integerp(n) and n > 0)), G[2])$
ogg_p(G) := listp(G) and is(length(G)=3) and listnorep_p(G[1]) and listnorep_p(G[2]) and
  every(lambda([e], block([s : G[3](e)],
    setp(s) and elementp(length(s),{1,2}) and subsetp(s,setify(G[1])))), G[2])$
ogdg_p(G) := listp(G) and is(length(G)=3) and listnorep_p(G[1]) and listnorep_p(G[2]) and
  every(lambda([e], block([l : G[3](e)],
    listp(l) and is(length(l)=2) and subsetp(setify(l),setify(G[1])))), G[2])$


/* *********************
   * Checking equality *
   *********************
*/

/* Equality checking for (directed) graphs (with loops) happens via normal
   "syntactical" equality testing, however for multigraphs and general
   graphs this would demand that the terms for the edge functions are equal,
   and so here we define special equality tests.
*/
/* G1, G2, can be of arbitrary but identical graph-type: */
gr_equalp(G1,G2) := if length(G1)=2 then is(G1 = G2) else
 is(G1[1] = G2[1] and G1[2] = G2[2]) and
  every(lambda([e],is(G1[3](e)=G2[3](e))), G1[2])$


/* **************
   * Promotions *
   **************
*/

/* Promotions gr -> grl and mugr -> mugrl happen implicitly. */

/* Works for g2mug, gl2mugl, og2omug, ogl2omugl, dg2mudg, dgl2mudgl, odg2omudg,
   odgl2omudgl: */
generic_g2mug(G) := [G[1], G[2], lambda([e],1)]$
/* Works for g2gg, gl2gg, og2ogg, ogl2ogg, dg2gdg, dgl2gdg, odg2ogdg,
   odgl2ogdg: */
generic_g2gg(G) := [G[1], G[2], identity]$
/* Works for mug2gg, mugl2gg, mudg2gdg, mudgl2gdg: */
generic_mug2gg(G) := block([L : listify(G[2])],
  [G[1], 
   setify(create_list([e,i], e,L, i,1,G[3](e))),
   first
  ])$
/* Works for omug2ogg, omugl2ogg, omudg2ogdg, omudgl2ogdg: */
generic_omug2ogg(G) := 
  [G[1], 
   create_list([e,i], e,G[2], i,1,G[3](e)),
   first
  ]$
/* Works for g2og, gl2ogl, dg2odg, dgl2odgl: */
generic_g2og(G) := [listify(G[1]), listify(G[2])]$
/* Works for mug2omug, mugl2omugl, mudg2omudg, mudgl2omudgl, gg2ogg, gdg2ogdg: */
generic_gg2ogg(G) := [listify(G[1]), listify(G[2]), G[3]]$

gl2mugl(G) := generic_g2mug(G)$
gl2gg(G) := generic_g2gg(G)$
mugl2gg(G) := generic_mug2gg(G)$

ogl2omugl(G) := generic_g2mug(G)$
ogl2ogg(G) := generic_g2gg(G)$
omugl2ogg(G) := generic_omug2ogg(G)$

gl2ogl(G) := generic_g2og(G)$
mugl2omugl(G) := generic_gg2ogg(G)$
gg2ogg(G) := generic_gg2ogg(G)$

dgl2mudgl(G) := generic_g2mug(G)$
dgl2gdg(G) := generic_g2gg(G)$
mudgl2gdg(G) := generic_mug2gg(G)$

odgl2omudgl(G) := generic_g2mug(G)$
odgl2ogdg(G) := generic_g2gg(G)$
omudgl2ogdg(G) := generic_omug2ogg(G)$

dgl2odgl(G) := generic_g2og(G)$
mudgl2omudgl(G) := generic_gg2ogg(G)$
gdg2ogdg(G) := generic_gg2ogg(G)$


/* *************
   * Downcasts *
   *************
*/

generic_gg2mugl(G) := [
 G[1], 
 map(G[3],G[2]),
 buildq([G],lambda([e],length(subset(G[2],lambda([x],is(G[3](x)=e))))))
]$
generic_ogg2omugl(G) := [
 G[1], 
 stable_unique(map(G[3],G[2])),
 buildq([G],lambda([e],length(sublist(G[2],lambda([x],is(G[3](x)=e))))))
]$

mugl2gl(G) := [G[1],G[2]]$
gg2gl(G) := [G[1], map(G[3],G[2])]$
gg2mugl(G) := generic_gg2mugl(G)$

omugl2ogl(G) := [G[1],G[2]]$
ogg2ogl(G) := [G[1], stable_unique(map(G[3],G[2]))]$
ogg2omugl(G) := generic_ogg2omugl(G)$

ogl2gl(G) := [setify(G[1]), setify(G[2])]$
omugl2mugl(G) := [setify(G[1]), setify(G[2]), G[3]]$
ogg2gg(G) := [setify(G[1]), setify(G[2]), G[3]]$

mudgl2dgl(G) := [G[1],G[2]]$
gdg2dgl(G) := [G[1], map(G[3],G[2])]$
gdg2mudgl(G) := generic_gg2mugl(G)$

omudgl2odgl(G) := [G[1],G[2]]$
ogdg2odgl(G) := [G[1], stable_unique(map(G[3],G[2]))]$
ogdg2omudgl(G) := generic_ogg2omugl(G)$

odgl2dgl(G) := [setify(G[1]), setify(G[2])]$
omudgl2mudgl(G) := [setify(G[1]), setify(G[2]), G[3]]$
ogdg2gdg(G) := [setify(G[1]), setify(G[2]), G[3]]$


/* ***************
   * Conversions *
   ***************
*/

/* Removal of loops: */
gl2g(G) := [G[1], subset(G[2],lambda([e],is(length(e)=2)))]$
ogl2og(G) := [G[1]. sublist(G[2],lambda([e],is(length(e)=2)))]$
mugl2mug(G) := [G[1], subset(G[2],lambda([e],is(length(G[3](e))=2))), G[3]]$
omugl2omug(G) := [G[1], sublist(G[2],lambda([e],is(length(G[3](e))=2))), G[3]]$

/* Underlying graphs of directed graphs: */
dg2g(G) := [G[1], map(setify,G[2])]$
odg2og(G) := [G[1], stable_unique(map(setify,G[2]))]$
dgl2gl(G) := [G[1], map(setify,G[2])]$
odgl2ogl(G) := [G[1], stable_unique(map(setify,G[2]))]$


/* **************************
   * Basic graph operations *
   **************************
*/

/* The set of neighbours of vertex v in graph G. */
/* RENAME it to "neighbours_g". */
neighbours(v,G) := disjoin(v, list_sets_union(
 subset(G[2], lambda([e],elementp(v,e)))))$

/* Removes vertex set V from graph G (with loops). */
/* RENAME it to "rem_vertices_gl". */
remove_vertices_graph(V,G) := [setdifference(G[1],V),
 subset(G[2], lambda([e], disjointp(e,V)))]$


/* *****************************
   * Basic graph constructions *
   *****************************
*/

/* The complement graph of a graph */
/* RENAME it to "complement_g". */
comp_graph(G) := [G[1], setdifference(powerset(G[1],2),G[2])]$


/* **********
   * Tests  *
   **********
*/

load(graphs)$

/* Tests whether a general or multi-graph has parallel edges: */
parallel_edges_gg_p(G) := is(length(map(G[3],G[2])) < length(G[2]))$
parallel_edges_mug_p(G) := every(G[2],lambda([e],is(G[3](e)=1)))$
parallel_edges_mugl_p(G) := every(G[2],lambda([e],is(G[3](e)=1)))$
parallel_edges_ogg_p(G) := is(length(setify(map(G[3],G[2]))) < length(G[2]))$
parallel_edges_omug_p(G) := every(G[2],lambda([e],is(G[3](e)=1)))$
parallel_edges_omugl_p(G) := every(G[2],lambda([e],is(G[3](e)=1)))$


/* Tests whether a graph with loops is irreflexive (that is, doesn't actually
   have loops): */
irreflexive_gl(G) := every(G[2],lambda([e],is(length(e)=2)))$
irreflexive_mugl(G) := every(G[2],lambda([e],is(length(e)=2)))$
irreflexive_gg(G) := every(G[2],lambda([e],is(length(G[3](e))=2)))$
irreflexive_ogl(G) := every(G[2],lambda([e],is(length(e)=2)))$
irreflexive_omugl(G) := every(G[2],lambda([e],is(length(e)=2)))$
irreflexive_ogg(G) := every(G[2],lambda([e],is(length(G[3](e))=2)))$


/* An "oriented graph" is, following the abuse of language in [Jensen,
   Gutin; Digraphs], a directed graph without antiparallel edges: */
orientedgraph_dg_p(G) := not is(length(map(setify,G[2])) < length(G[2]))$
orientedgraph_dgl_p(G) := not is(length(map(setify,G[2])) < length(G[2]))$
orientedgraph_odg_p(G) := not is(length(setify(map(setify,G[2]))) < length(G[2]))$
orientedgraph_odgl_p(G) := not is(length(setify(map(setify,G[2]))) < length(G[2]))$


/* Tests whether a graph is complete: */
complete_g_p(G) := is(binom(length(G[1]),2) = length(G[2]))$
complete_gl_p(G) := complete_g_p(gl2g(G))$
complete_og_p(G) := is(binom(length(G[1]),2) = length(G[2]))$
complete_ogl_p(G) := complete_og_p(ogl2og(G))$
complete_mug_p(G) := complete_g_p(mug2g(G))$
complete_mugl_p(G) := complete_gl_p(mugl2gl(G))$
complete_omug_p(G) := complete_og_p(omug2og(G))$
complete_omugl_p(G) := complete_ogl_p(omugl2ogl(G))$
complete_gg_p(G) := complete_gl_p(gg2gl(G))$
complete_ogg_p(G) := complete_ogl_p(ogg2ogl(G))$


/* Tests whether a graph is connected: */
connected_g_p(G) := is_connected(g2mg(G))$
connected_og_p(G) := is_connected(og2mg(G))$
connected_mug_p(G) :=  connected_g_p(mug2g(G))$
connected_omug_p(G) :=  connected_og_p(omug2og(G))$
connected_gg_p(G) :=  connected_gl_p(gg2gl(G))$
connected_ogg_p(G) :=  connected_ogl_p(ogg2ogl(G))$
connected_gl_p(G) := is_connected(g2mg(gl2g(G)))$
connected_ogl_p(G) := is_connected(og2mg(ogl2og(G)))$
connected_mugl_p(G) :=  connected_gl_p(mugl2gl(G))$
connected_omugl_p(G) :=  connected_ogl_p(omugl2ogl(G))$

/* Tests whether a digraph is strongly connected: */
sconnected_dg_p(G) := is_sconnected(dg2mdg(G))$
sconnected_odg_p(G) := is_connected(odg2mdg(G))$
sconnected_mudg_p(G) :=  sconnected_dg_p(mudg2dg(G))$
sconnected_omudg_p(G) :=  sconnected_odg_p(omudg2odg(G))$
sconnected_gdg_p(G) :=  sconnected_dgl_p(gdg2dgl(G))$
sconnected_ogdg_p(G) :=  sconnected_odgl_p(ogdg2odgl(G))$
sconnected_dgl_p(G) := is_connected(dg2mdg(dgl2dg(G)))$
sconnected_odgl_p(G) := is_connected(odg2mg(odgl2odg(G)))$
sconnected_mudgl_p(G) :=  sconnected_dgl_p(mudgl2dgl(G))$
sconnected_omudg_p(G) :=  sconnected_odgl_p(omudgl2odgl(G))$


/* Tests whether a graph is a tree: */
tree_g_p(G) := is_tree(g2mg(G))$
tree_og_p(G) := is_tree(og2mg(G))$
tree_mug_p(G) :=  not parallel_edges_mug_p(G) and tree_g_p(mug2g(G))$
tree_omug_p(G) :=  not parallel_edges_omug_p(G) and tree_og_p(omug2og(G))$
tree_gg_p(G) :=  not parallel_edges_gg_p(G) and tree_gl_p(gg2gl(G))$
tree_ogg_p(G) :=  not parallel_edges_ogg_p(G) and tree_ogl_p(ogg2ogl(G))$
tree_gl_p(G) := irreflexive_gl_p(G) and is_tree(g2mg(gl2g(G)))$
tree_ogl_p(G) := irreflexive_ogl_p(G) and is_tree(og2mg(ogl2og(G)))$
tree_mugl_p(G) :=  irreflexive_mugl_p(G) and tree_gl_p(mugl2gl(G))$
tree_omugl_p(G) :=  irreflexive_omugl_p(G) and tree_ogl_p(omugl2ogl(G))$


/* ********************************
   * Connections to Maxima-graphs *
   ********************************
*/

/* Graphs to Maxima-graphs (vertex names yield vertex labels).
   The vertices in the Maxima-graph are numbered starting with 1.
   Edges in the Maxima-graph, which are ordered, are ordered according
   to orderlessp (this is the order imposed on the vertex set).
*/
og2mg(G) := block(
 [V : G[1], E : G[2], h : sm2hm({}), n : length(G[1])],
 for i : 1 thru n do set_hm(h, V[i], i),
 create_graph(create_list([i,V[i]],i,1,n), 
   create_list([ev_hm(h,listify(e)[1]), ev_hm(h,listify(e)[2])], e, E)
 )
)$
g2mg(G) := og2mg(gl2ogl(G))$
/* Without the vertex-labels: */
og2mg_nl(G) := block(
 [V : G[1], E : G[2], h : sm2hm({}), n : length(G[1])],
 for i : 1 thru n do set_hm(h, V[i], i),
 create_graph(create_list(i,i,1,n), 
   create_list([ev_hm(h,listify(e)[1]), ev_hm(h,listify(e)[2])], e, E)
 )
)$
g2mg_nl(G) := og2mg_nl(gl2ogl(G))$

/* Maxima-graphs to ordered graphs, moving 0-based indices to 1-based
   (ignoring the vertex labels). */
mg2og(g) := block([V : vertices(g), E : edges(g)],
  if not emptyp(V) and last(V)=0 then (
    for i :1 thru length(V) do
      V[i] : V[i] + 1,
    for i : 1 thru length(E) do block([e : E[i]],
      E[i] : [e[1]+1,e[2]+1])
  ),
  return([V,map(setify,E)]))$
/* Maxima-graphs to graphs (ignoring the vertex labels): */
mg2g(g) := block([G : mg2og(g)], [setify(G[1]), setify(G[2])])$


/* Digraphs to Maxima-digraphs (vertex names yield vertex labels).
   The vertices in the Maxima-digraph are numbered starting with 1. */
dg2mdg(G) := block(
 [V : listify(G[1]), E : listify(G[2]), h : sm2hm({}), n : length(G[1])],
 for i : 1 thru n do set_hm(h, V[i], i),
 return(
   create_graph(
     create_list([i,V[i]],i,1,n), 
     create_list([ev_hm(h,e[1]), ev_hm(h,e[2])], e, E),
     true
 ))
)$



/*!
\endhtmlonly
*/
