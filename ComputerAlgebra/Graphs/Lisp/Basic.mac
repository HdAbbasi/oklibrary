/* Oliver Kullmann, 5.1.2008 (Swansea) */
/* Copyright 2008 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Graphs/Lisp/Basic.mac
  \brief Basic graph functionality

Use by

oklib_load("Transitional/ComputerAlgebra/Graphs/Lisp/Basic.mac");

*/

/*!
\htmlonly
*/

oklib_include("Transitional/ComputerAlgebra/Hypergraphs/Lisp/SetSystems.mac")$
oklib_include("Transitional/ComputerAlgebra/DataStructures/Lisp/HashMaps.mac")$
oklib_include("Transitional/ComputerAlgebra/DataStructures/Lisp/Lists.mac")$


/* ***********************
   * Fundamental notions *
   ***********************
*/

/* A "graph" is just a 2-element list, consisting of the set of
   vertices, and a set of 2-element vertex sets.
   A "graph with loops" also allows 1-element vertex sets.
*/

/* A "digraph" is a 2-element list, consisting of the set of vertices,
   and a set of 2-element vertex lists with different elements.
   A "digrap with loops" also allows the elements to be identical.
*/

/* A "multigraph" is a triple [V,E,f] such that [V,E] is a graph,
   and such that f is a function which assigns to every edge its
   cardinality, a natural number (>0).
   A "multigraph with loops" allows loops.
*/

/* A "multi-digraph" is similarly a triple [V,E,f] such that [V,E] is
   is digraph; and a "multi-digraph with loops" allows loops.
*/

/* A "general graph" is a triple [V,E,f], where f maps each element of
   E to a 1- or 2-element subset of V.
   For a "general digraph" f yields lists of length 1 or 2.
*/

/* The ordered versions of all the above notions use lists instead of
   sets, but without repetition.
*/

/* See "Providing basic test cases" in
   ComputerAlgebra/Graphs/Lisp/tests/Basic.mac
   for basic examples.
*/


/* ************************************
   * Checking the defining properties *
   ************************************
*/

g_p(G) := listp(G) and is(length(G)=2) and setp(G[1]) and setp(G[2]) and 
  every(lambda([e], setp(e) and is(length(e) = 2) and subsetp(e,G[1])), G[2])$
gl_p(G) := listp(G) and is(length(G)=2) and setp(G[1]) and setp(G[2]) and 
  every(lambda([e], setp(e) and elementp(length(e),{1,2}) and subsetp(e,G[1])),G[2])$
dg_p(G) := listp(G) and is(length(G)=2) and setp(G[1]) and setp(G[2]) and 
  every(lambda([e], listp(e) and is(length(e)=2 and e[1]#e[2]) and subsetp(setify(e),G[1])), G[2])$
dgl_p(G) := listp(G) and is(length(G)=2) and setp(G[1]) and setp(G[2]) and 
  every(lambda([e], listp(e) and is(length(e)=2) and subsetp(setify(e),G[1])), G[2])$
mug_p(G) := listp(G) and is(length(G)=3) and g_p([G[1],G[2]]) and
  every(lambda([e], block([n : G[3](e)], integerp(n) and n > 0)), G[2])$
mugl_p(G) := listp(G) and is(length(G)=3) and gl_p([G[1],G[2]]) and
  every(lambda([e], block([n : G[3](e)], integerp(n) and n > 0)), G[2])$
mudg_p(G) := listp(G) and is(length(G)=3) and dg_p([G[1],G[2]]) and
  every(lambda([e], block([n : G[3](e)], integerp(n) and n > 0)), G[2])$
mudgl_p(G) := listp(G) and is(length(G)=3) and dgl_p([G[1],G[2]]) and
  every(lambda([e], block([n : G[3](e)], integerp(n) and n > 0)), G[2])$
gg_p(G) := listp(G) and is(length(G)=3) and setp(G[1]) and setp(G[2]) and
  every(lambda([e], block([s : G[3](e)],
    setp(s) and elementp(length(s),{1,2}) and subsetp(s,G[1]))), G[2])$
gdg_p(G) := listp(G) and is(length(G)=3) and setp(G[1]) and setp(G[2]) and
  every(lambda([e], block([l : G[3](e)],
    listp(l) and is(length(l)=2) and subsetp(setify(l),G[1]))), G[2])$

listnorep_p(L) := listp(L) and is(length(unique(L)) = length(L))$

og_p(G) := listp(G) and is(length(G)=2) and listnorep_p(G[1]) and listnorep_p(G[2]) and
  every(lambda([e], setp(e) and is(length(e) = 2) and subsetp(e,setify(G[1]))), G[2])$
ogl_p(G) := listp(G) and is(length(G)=2) and listnorep_p(G[1]) and listnorep_p(G[2]) and 
  every(lambda([e], setp(e) and elementp(length(e),{1,2}) and subsetp(e,setify(G[1]))), G[2])$
odg_p(G) := listp(G) and is(length(G)=2) and listnorep_p(G[1]) and listnorep_p(G[2]) and 
  every(lambda([e], listp(e) and is(length(e)=2 and e[1]#e[2]) and subsetp(setify(e),setify(G[1]))), G[2])$
odgl_p(G) := listp(G) and is(length(G)=2) and listnorep_p(G[1]) and listnorep_p(G[2]) and 
  every(lambda([e], listp(e) and is(length(e)=2) and subsetp(setify(e),setify(G[1]))), G[2])$
omug_p(G) := listp(G) and is(length(G)=3) and og_p([G[1],G[2]]) and
  every(lambda([e], block([n : G[3](e)], integerp(n) and n > 0)), G[2])$
omugl_p(G) := listp(G) and is(length(G)=3) and ogl_p([G[1],G[2]]) and
  every(lambda([e], block([n : G[3](e)], integerp(n) and n > 0)), G[2])$
omudg_p(G) := listp(G) and is(length(G)=3) and odg_p([G[1],G[2]]) and
  every(lambda([e], block([n : G[3](e)], integerp(n) and n > 0)), G[2])$
omudgl_p(G) := listp(G) and is(length(G)=3) and odgl_p([G[1],G[2]]) and
  every(lambda([e], block([n : G[3](e)], integerp(n) and n > 0)), G[2])$
ogg_p(G) := listp(G) and is(length(G)=3) and listnorep_p(G[1]) and listnorep_p(G[2]) and
  every(lambda([e], block([s : G[3](e)],
    setp(s) and elementp(length(s),{1,2}) and subsetp(s,setify(G[1])))), G[2])$
ogdg_p(G) := listp(G) and is(length(G)=3) and listnorep_p(G[1]) and listnorep_p(G[2]) and
  every(lambda([e], block([l : G[3](e)],
    listp(l) and is(length(l)=2) and subsetp(setify(l),setify(G[1])))), G[2])$


/* *********************
   * Checking equality *
   *********************
*/

/* Equality checking for (directed) graphs (with loops) happens via normal
   "syntactical" equality testing, however for multigraphs and general
   graphs this would demand that the terms for the edge functions are equal,
   and so here we define special equality tests.
*/
/* G1, G2, can be of arbitrary but identical graph-type: */
gr_equalp(G1,G2) := if length(G1)=2 then is(G1 = G2) else
 is(G1[1] = G2[1] and G1[2] = G2[2]) and
  every(lambda([e],is(G1[3](e)=G2[3](e))), G1[2])$


/* **************
   * Promotions *
   **************
*/

/* Promotions gr -> grl and mugr -> mugrl happen implicitly. */

/* Works for g2mug, gl2mugl, og2omug, ogl2omugl, dg2mudg, dgl2mudgl, odg2omudg,
   odgl2omudgl: */
generic_g2mug(G) := [G[1], G[2], lambda([e],1)]$
/* Works for g2gg, gl2gg, og2ogg, ogl2ogg, dg2gdg, dgl2gdg, odg2ogdg,
   odgl2ogdg: */
generic_g2gg(G) := [G[1], G[2], identity]$
/* Works for mug2gg, mugl2gg, mudg2gdg, mudgl2gdg: */
generic_mug2gg(G) := block([L : listify(G[2])],
  [G[1], 
   setify(create_list([e,i], e,L, i,1,G[3](e))),
   first
  ])$
/* Works for omug2ogg, omugl2ogg, omudg2ogdg, omudgl2ogdg: */
generic_omug2ogg(G) := 
  [G[1], 
   create_list([e,i], e,G[2], i,1,G[3](e)),
   first
  ]$
/* Works for g2og, gl2ogl, dg2odg, dgl2odgl: */
generic_g2og(G) := [listify(G[1]), listify(G[2])]$
/* Works for mug2omug, mugl2omugl, mudg2omudg, mudgl2omudgl, gg2ogg, gdg2ogdg: */
generic_gg2ogg(G) := [listify(G[1]), listify(G[2]), G[3]]$

gl2mugl(G) := generic_g2mug(G)$
gl2gg(G) := generic_g2gg(G)$
mugl2gg(G) := generic_mug2gg(G)$

ogl2omugl(G) := generic_g2mug(G)$
ogl2ogg(G) := generic_g2gg(G)$
omugl2ogg(G) := generic_omug2ogg(G)$

gl2ogl(G) := generic_g2og(G)$
mugl2omugl(G) := generic_gg2ogg(G)$
gg2ogg(G) := generic_gg2ogg(G)$

dgl2mudgl(G) := generic_g2mug(G)$
dgl2gdg(G) := generic_g2gg(G)$
mudgl2gdg(G) := generic_mug2gg(G)$

odgl2omudgl(G) := generic_g2mug(G)$
odgl2ogdg(G) := generic_g2gg(G)$
omudgl2ogdg(G) := generic_omug2ogg(G)$

dgl2odgl(G) := generic_g2og(G)$
mudgl2omudgl(G) := generic_gg2ogg(G)$
gdg2ogdg(G) := generic_gg2ogg(G)$


/* *************
   * Downcasts *
   *************
*/

generic_gg2mugl(G) := [
 G[1], 
 map(G[3],G[2]),
 buildq([G],lambda([e],length(subset(G[2],lambda([x],is(G[3](x)=e))))))
]$
generic_ogg2omugl(G) := [
 G[1], 
 stable_unique(map(G[3],G[2])),
 buildq([G],lambda([e],length(sublist(G[2],lambda([x],is(G[3](x)=e))))))
]$

mugl2gl(G) := [G[1],G[2]]$
gg2gl(G) := [G[1], map(G[3],G[2])]$
gg2mugl(G) := generic_gg2mugl(G)$

omugl2ogl(G) := [G[1],G[2]]$
ogg2ogl(G) := [G[1], stable_unique(map(G[3],G[2]))]$
ogg2omugl(G) := generic_ogg2omugl(G)$

ogl2gl(G) := [setify(G[1]), setify(G[2])]$
omugl2mugl(G) := [setify(G[1]), setify(G[2]), G[3]]$
ogg2gg(G) := [setify(G[1]), setify(G[2]), G[3]]$

mudgl2dgl(G) := [G[1],G[2]]$
gdg2dgl(G) := [G[1], map(G[3],G[2])]$
gdg2mudgl(G) := generic_gg2mugl(G)$

omudgl2odgl(G) := [G[1],G[2]]$
ogdg2odgl(G) := [G[1], stable_unique(map(G[3],G[2]))]$
ogdg2omudgl(G) := generic_ogg2omugl(G)$

odgl2dgl(G) := [setify(G[1]), setify(G[2])]$
omudgl2mudgl(G) := [setify(G[1]), setify(G[2]), G[3]]$
ogdg2gdg(G) := [setify(G[1]), setify(G[2]), G[3]]$


/* **************************
   * Basic graph operations *
   **************************
*/

/* The set of neighbours of vertex v in graph G. */
neighbours(v,G) := disjoin(v, list_sets_union(
 subset(G[2], lambda([e],elementp(v,e)))))$

/* Removes vertex set V from graph G (with loops). */
remove_vertices_graph(V,G) := [setdifference(G[1],V),
 subset(G[2], lambda([e], disjointp(e,V)))]$


/* *****************************
   * Basic graph constructions *
   *****************************
*/

/* The complement graph of a graph */
comp_graph(G) := [G[1], setdifference(powerset(G[1],2),G[2])]$


/* **********
   * Tests  *
   **********
*/

/* Tests whether a graph is complete */
completegrp(G) := block([n : length(G[1]), m : length(G[2])],
  is(binom(n,2) = m))$


/* ********************************
   * Connections to Maxima-graphs *
   ********************************
*/

load(graphs)$

/* Graphs to Maxima-graphs (vertex names yield vertex labels).
   The vertices in the Maxima-graph are numbered starting with 1.
   Edges in the Maxima-graph, which are ordered, are ordered according
   to orderlessp (this is the order imposed on the vertex set).
*/
g2mg(G) := block(
 [V : listify(G[1]), E : listify(G[2]), h : sm2hm({}), n : length(G[1])],
 for i : 1 thru n do set_hm(h, V[i], i),
 create_graph(create_list([i,V[i]],i,1,n), 
   create_list([ev_hm(h,listify(e)[1]), ev_hm(h,listify(e)[2])], e, E)
 )
)$

/* Maxima-graphs to ordered graphs, moving 0-based indices to 1-based
   (ignoring the vertex labels). */
mg2og(g) := block([V : vertices(g), E : edges(g)],
  if not emptyp(V) and last(V)=0 then (
    for i :1 thru length(V) do
      V[i] : V[i] + 1,
    for i : 1 thru length(E) do block([e : E[i]],
      E[i] : [e[1]+1,e[2]+1])
  ),
  return([V,map(setify,E)]))$
/* Maxima-graphs to graphs (ignoring the vertex labels): */
mg2g(g) := block([G : mg2og(g)], [setify(G[1]), setify(G[2])])$


/* Digraphs to Maxima-digraphs (vertex names yield vertex labels).
   The vertices in the Maxima-digraph are numbered starting with 1. */
dg2mdg(G) := block(
 [V : listify(G[1]), E : listify(G[2]), h : sm2hm({}), n : length(G[1])],
 for i : 1 thru n do set_hm(h, V[i], i),
 return(
   create_graph(
     create_list([i,V[i]],i,1,n), 
     create_list([ev_hm(h,e[1]), ev_hm(h,e[2])], e, E),
     true
 ))
)$



/*!
\endhtmlonly
*/
