/* Oliver Kullmann, 4.5.2008 (Guangzhou) */
/* Copyright 2008 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/DataStructures/Lisp/tests/HashMaps.mac
  \brief Tests for hash-processing functions

Use by

oklib_load("Transitional/ComputerAlgebra/DataStructures/Lisp/tests/HashMaps.mac");

*/

/*!
\htmlonly
*/

oklib_include("Transitional/ComputerAlgebra/TestSystem/Lisp/Asserts.mac")$
oklib_include("Transitional/ComputerAlgebra/DataStructures/Lisp/HashMaps.mac")$
oklib_include("Transitional/ComputerAlgebra/DataStructures/Lisp/Lists.mac")$

kill(f)$

/* ************************
   * Set-theoretical maps *
   ************************
*/

okltest_setmapp(f) := (
  assert(f(1) = false),
  assert(f([]) = false),
  assert(f({}) = true),
  assert(f({1}) = false),
  assert(f({[1,2,3]}) = false),
  assert(f({[1,1]}) = true),
  assert(f({[1,1],[1,2]}) = false),
  assert(f({[1,1],[2,1]}) = true),
  true)$

okltest_define_set_map(f) := block([M,x,y],
  M : f({},1,10),
  assert(M = {[1,10]}),
  M : f(M,1,11),
  assert(M = {[1,11]}),
  M : f(M,1,11),
  assert(M = {[1,11]}),
  M : f(M,2,20),
  assert(M = {[1,11],[2,20]}),
  M : f(M,2,21),
  assert(M = {[1,11],[2,21]}),
  true)$

okltest_evaluate_set_map(f) := block([M,x],
  assert(f({},x) = done),
  assert(f({[1,10]},1) = 10),
  assert(f({[1,10]},2) = done),
  M : {[1,2],[5,10]},
  assert(f(M,1) = 2), assert(f(M,5) = 10), assert(f(M,2) = done),
  true)$

okltest_evaluate_set_map_d(f) := block([M,x,y],
  assert(f({},x,1) = 1),
  assert(f({[1,10]},1,y) = 10),
  assert(f({[1,10]},2,20) = 20),
  M : {[1,2],[5,10]},
  assert(f(M,1,3) = 2), assert(f(M,5,9) = 10), assert(f(M,2,y) = y),
  true)$


/* ***********************************************
   * Hash maps as provided by the graphs-package *
   ***********************************************
*/

/* A tool for checking whether an original hash-map and a set-map are identical
   as mathematical functions (this is only useful for compatibility
   reasons). */
eq_ohmsm_p(h,M) := if not setmapp(M) then
  error("eq_ohmsm_p: the alleged set-map is not a set-map")
  else if not is(create_set_map(h) = M) then false else
  block([table : map(lambda([p],part(p,1)),hash_table_data_okl(h)), 
    translated : hash_table_okl(),
    L : listify(M)],
    L : sort(L,lambda([P1,P2],is(sublist_indices_el(table,P1[1])[1] < sublist_indices_el(table,P2[1])[1]))),
    for p in L do set_hash_okl(p[1], translated, p[2]),
    is(sconcat(translated) = sconcat(h)))$

okltest_eq_ohmsm_p(f) := block([M,h],
  h : hash_table_okl(),
  M : {},
  assert(f(h,M) = true),
  set_hash_okl(1,h,10),
  assert(f(h,M) = false),
  M : define_set_map(M,1,10),
  assert(f(h,M) = true),
  set_hash_okl(1,h,11),
  assert(f(h,M) = false),
  M : define_set_map(M,1,11),
  assert(f(h,M) = true),
  set_hash_okl([],h,1),
  assert(f(h,M) = false),
  M : define_set_map(M,[],1),
  assert(f(h,M) = (not oklib_load_annotation)), /* Assumes, that
  the setting of oklib_load_annotation was the same when loading 
  this file, and that oklib_include or oklib_load was used;
  this is automatically given when loading the testobject-file
  by any of the oklib-load-instructions. */
  h : hash_table_okl(),
  set_hash_okl(1,h,1), set_hash_okl(-1,h,0),
  M : {[1,1],[-1,0]},
  assert(f(h,M) = true),
  h : hash_table_okl(),
  set_hash_okl(-1,h,0), set_hash_okl(1,h,1),
  assert(f(h,M) = true),
  true)$

okltest_repo_set_maps : {
 {},
 {[1,1]},
 {[1,1],[2,3]}
}$

okltest_create_hash_map(f) := (
  for M in okltest_repo_set_maps do block([h : f(M)],
    assert(length(hash_table_data_okl(h)) = length(M)),
    for p in M do assert(get_hash_okl(p[1],h) = p[2])
  ),
  true)$

okltest_create_set_map(f) := (
  for M in okltest_repo_set_maps do
    assert(f(create_hash_map(M)) = M),
  true)$

/* A tool for checking whether an improved hash-map and a set-map are identical
   as mathematical functions. */
eq_hmsm_p(h,M) := (
 if oklib_monitor then (
   print("M[eq_hmsm_p]: ENTRY"),
   if oklib_monitor_level >= 1 then (
     print("The hash-map is:"),
     print(h),
     print("The set-map is:"),
     print(M))
 ),
 if not setmapp(M) then
   error("eq_hmsm_p: the alleged set-map is not a set-map")
 elseif not is(hm2sm(h) = M) then (
     if not oklib_monitor then false else (
       print("M[eq_hmsm_p]: translating the hash-map does not yield the given set-map!"),
       if oklib_monitor_level >= 1 then (
         print("The translated hash-map is:"),
         print(hm2sm(h))),
       false
     ))
 else block(
  [table : map(lambda([p],eval_string(part(p,1))),hash_table_data_okl(h)), 
   translated : sm2hm({}),
   L : listify(M)],
   L : sort(L,lambda([P1,P2],is(sublist_indices_el(table,P1[1])[1] < sublist_indices_el(table,P2[1])[1]))),
   for p in L do set_hm(translated, p[1], p[2]),
   if not is(sconcat(translated) = sconcat(h)) then (
     if not oklib_monitor then false else (
       print("M[eq_hmsm_p]: translating the set-map does not yield the given hash-map!"),
       if oklib_monitor_level >= 1 then (
         print("The translated set-map yields the string:"),
         print(sconcat(translated)),
         print("The hash-map yields the string:"),
         print(sconcat(h))),
       false
     ))
   else true))$

okltest_eq_hmsm_p(f) := block([M,h],
  h : hash_table_okl(),
  M : {},
  assert(f(h,M) = true),
  set_hm(h,1,10),
  assert(f(h,M) = false),
  M : define_set_map(M,1,10),
  assert(f(h,M) = true),
  set_hm(h,1,11),
  assert(f(h,M) = false),
  M : define_set_map(M,1,11),
  assert(f(h,M) = true),
  set_hm(h,[],1),
  assert(f(h,M) = false),
  M : define_set_map(M,[],1),
  assert(f(h,M) = true),
  h : hash_table_okl(),
  set_hm(h,1,1), set_hm(h,-1,0),
  M : {[1,1],[-1,0]},
  assert(f(h,M) = true),
  h : hash_table_okl(),
  set_hm(h,-1,0), set_hm(h,1,1),
  assert(f(h,M) = true),
  true)$

okltest_set_hm(f) := block([h : hash_table_okl()],
  f(h,1,10),
  assert(get_hash_okl(sconcat(1),h) = 10),
  assert(get_hash_okl(sconcat(2),h) = false),
  f(h,[],20),
  assert(get_hash_okl(sconcat([]),h) = 20),
  assert(get_hash_okl(sconcat(1),h) = 10),
  assert(get_hash_okl(sconcat([[]]),h) = false),
  f(h,1,11),
  assert(get_hash_okl(sconcat(1),h) = 11),
  f(h,[],21),
  assert(get_hash_okl(sconcat([]),h) = 21),
  assert(eq_hmsm_p(h,{[1,11],[[],21]}) = true),
  h : hash_table_okl(),
  f(h,1,1),
  assert(ev_hm(h,1) = 1),
  assert(ev_hm(h,-1) = false),
  f(h,-1,0),
  assert(eq_hmsm_p(h,{[1,1],[-1,0]}) = true),
  true)$

okltest_ev_hm(f) := block([h : hash_table_okl()],
  assert(f(h,1) = false),
  set_hash_okl(sconcat(1),h,10),
  assert(f(h,1) = 10),
  set_hash_okl(sconcat([{}]),h,20),
  assert(f(h,[{}]) = 20),
  true)$

okltest_ev_hm_d(f) := block([h : hash_table_okl()],
  assert(f(h,1,11) = 11),
  set_hash_okl(sconcat(1),h,1),
  assert(f(h,1,11) = 1),
  assert(f(h,[],11) = 11),
  set_hash_okl(sconcat([{}]),h,20),
  assert(f(h,[{}],-7) = 20),
  assert(f(h,[],{}) = {}),
  h : sm2hm({}),
  assert(f(h,1,10) = 10),
  set_hm(h,1,false),
  assert(f(h,1,10) = false),
  assert(f(h,2,10) = 10),
  true)$

okltest_del_hm(f) := block([h : sm2hm({})],
  set_hm(h,1,10),
  del_hm(h,1),
  assert(eq_hmsm_p(h,{}) = true),
  compose_hm_sm(h,{[1,11],[{},{{}}]}),
  assert(eq_hmsm_p(h,{[1,11],[{},{{}}]}) = true),
  del_hm(h,1),
  assert(eq_hmsm_p(h,{[{},{{}}]}) = true),
  del_hm(h,{}),
  assert(eq_hmsm_p(h,{}) = true),
  true)$
  
okltest_sm2hm(f) := block([h,M],
  h : f({}),
  assert(ev_hm(h,1) = false),
  h : f({[1,10]}),
  assert(ev_hm(h,1) = 10),
  M : {[{},{{}}],[[1,2],[3,4]],[5,5]},
  h : f(M),
  assert(ev_hm(h,{}) = {{}}),
  assert(ev_hm(h,[1,2]) = [3,4]),
  assert(ev_hm(h,5) = 5),
  assert(ev_hm(h,1) = false),
  assert(eq_hmsm_p(h,M) = true),
  true)$

okltest_hm2sm(f) := block([h],
  h : hash_table_okl(),
  assert(f(h) = {}),
  set_hm(h,1,10),
  assert(f(h) = {[1,10]}),
  set_hm(h,{[]},20),
  assert(f(h) = {[1,10],[{[]},20]}),
  assert(eq_hmsm_p(h,{[1,10],[{[]},20]}) = true),
  true)$

okltest_compose_hm_sm(f) := block([h],
  h : f(sm2hm({}),{}),
  assert(eq_hmsm_p(h, {}) = true),
  f(h,{[1,1],[{{}},2]}),
  assert(eq_hmsm_p(h, {[1,1],[{{}},2]}) = true),
  f(h,{[{{}},2],[[[]],3]}),
  assert(eq_hmsm_p(h, {[1,1],[{{}},2],[[[]],3]}) = true),
  true)$

/* *********************
   * Frequency counter *
   *********************
*/

okltest_list_distribution(f) := (
  assert(f([]) = []),
  assert(f([1]) = [[1,1]]),
  assert(f([1,2]) = [[1,1],[2,1]]),
  assert(f([1,1]) = [[1,2]]),
  true)$


/*!
\endhtmlonly
*/
