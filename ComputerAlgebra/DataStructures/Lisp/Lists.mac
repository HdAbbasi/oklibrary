/* Oliver Kullmann, 20.2.2008 (Swansea) */
/* Copyright 2008 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/DataStructures/Lisp/Lists.mac
  \brief Functions for handling lists (in Maxima/Lisp)

Use by

oklib_load("Transitional/ComputerAlgebra/DataStructures/Lisp/Lists.mac");

*/

/*!
\htmlonly
*/

oklib_include("Transitional/ComputerAlgebra/DataStructures/Lisp/HashMaps.mac")$

/* *******************************
   * Testing properties of lists *
   *******************************
*/

/* The versions of "every" and "some" with short-circuit evaluation: */

every_s(pred,L) := block([nocountex : true],
  for x in L while nocountex do
    nocountex : pred(x),
  return(nocountex))$
some_s(pred,L) := block([countex : false],
  for x in L unless countex do
    countex : pred(x),
  return(countex))$

/* Checks whether L is a list without repetitions: */
listnorep_p(L) := listp(L) and is(length(unique(L)) = length(L))$


/* **************************
   * Sublist constructions *
   **************************
*/

/* The first n elements of L for 0 <= n <= length(L), while for 
   length(L) <= n <= 2 length(L) we use n' := 2 length(L) - n and
   return the last n' elements. Error if n < 0 or n > 2 length(L). */
/* Returns a shallow copy of L. */
take_elements(n,L) := rest(L, - (length(L) - n))$

/* Finds the list of indices of elements equal to x. */
sublist_indices_el(L,x) := sublist_indices(L,lambda([e],is(e=x)))$

/* Removes element with index i from list L. Error if i < 1 or 
   i > length(L). */
/* Returns a shallow copy of L. */
remove_element(i,L) := append(take_elements(i-1,L), rest(L,i))$

/* Return the sublist of list L for which the corresponding entry in
   okl-array I is 0. Returns a shallow copy. */
sublist_indicator(L,I) := block([res : [], l : length(L), i : 1],
 for x in L do (
   if I[i] = 0 then res : endcons(x,res),
   i : i + 1),
 return(res))$


/* **********************
   * List constructions *
   **********************
*/

/* Partitions a given list l into a list of lists of size n,
   or less (in the case of the last-element list).
   Prerequisite n > 0. */
/* Returns a shallow copy of L. */
partition_elements(l,n) := if emptyp(l) then [] else 
 block([nn : min(length(l),n)],
  cons(take_elements(nn,l), partition_elements(rest(l,nn),n)))$
/* We have apply(append, partition_elements(l,n)) = l. */

/* Rotates a list n elements to the right. Negative n rotates to the left. */
rotate(l,n) := 
  if n = 0 or l = [] then l
  else if sign(n) = pos then  rotate(append([last(l)],rest(l,-1)), n-1)
  else rotate(append(rest(l), [first(l)]), n+1)$


/* Removes duplicated elements in the order they appear (i.e., the second
   occurrence and later ones are removed). */
/* Returns copies of each first occurrence. */
stable_unique(L) := block([h : sm2hm({}), res : []],
 for x in L do
   if not ev_hm(h,x) then (
     set_hm(h,x,true),
     res : endcons(x,res)),
 return(res))$


/* *************************
   * Random parts of lists *
   *************************
*/

/* Returns a random element with indices between a and b
   from a non-empty list L. */
/* Prerequisites: 1 <= a <= b <= length(L). */
random_element_ab(a,b,L) := L[random(b-a+1)+a]$
/* Returns a random element from a non-empty list: */
random_element(L) := random_element_ab(1,length(L),L)$

/* Removes a random element from a non-empty list passed by
   reference, and returns that element: */
remove_random_element(L) := block([n : length(ev(L)), i, x],
  i : random(n) + 1,
  x : ev(L)[i],
  L :: remove_element(i,ev(L)),
  return(x))$




/* REMARK : Functions below should go to LinearAlgebra? */

/* Flattens a matrix or list into a list of the elements, row by row: */
matrix2list(m) := apply(append, create_list(m[i],i,1,length(m)))$

/* Returns a list of the given matrix's columns (as lists) */
matrixcolumns(m) := partition_elements(matrix2list(transpose(m)),length(m))$

/* Builds a matrix from a list of it's columns (as lists) */
columns2matrix(mc) := transpose(apply(matrix, mc))$


/*!
\endhtmlonly
*/
