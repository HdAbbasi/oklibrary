/* Oliver Kullmann, 20.2.2008 (Swansea) */
/* Copyright 2008 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/DataStructures/Lisp/Lists.mac
  \brief Functions for handling lists (in Maxima/Lisp)

Use by

oklib_load("Transitional/ComputerAlgebra/DataStructures/Lisp/Lists.mac");

*/

/*!
\htmlonly
*/

oklib_include("Transitional/ComputerAlgebra/DataStructures/Lisp/HashMaps.mac")$


/* **************************
   * Sublist constructions *
   **************************
*/

/* The first n elements of L for 0 <= n <= length(L), while for 
   length(L) <= n <= 2 length(L) we use n' := 2 length(L) - n and
   return the last n' elements. Error if n < 0 or n > 2 length(L). */
/* Returns a shallow copy of L. */
take_elements(n,L) := rest(L, - (length(L) - n))$

/* Finds the list of indices of elements equal to x. */
sublist_indices_el(L,x) := sublist_indices(L,lambda([e],is(e=x)))$

/* Removes element with index i from list L. Error if i < 1 or 
   i > length(L). */
/* Returns a shallow copy of L. */
remove_element(i,L) := append(take_elements(i-1,L), rest(L,i))$

/* Return the sublist of list L for which the corresponding entry in
   array I is 0. Returns a shallow copy. */
sublist_indicator(L,I) := block([res : [], l : length(L)],
 for i : 0 thru l-1 do if I[i] = 0 then res : endcons(L[i+1],res),
 return(res))$


/* **********************
   * List constructions *
   **********************
*/

/* Partitions a given list l into a list of lists of size n,
   or less (in the case of the last-element list).
   Prerequisite n > 0. */
/* Returns a shallow copy of L. */
partition_elements(l,n) := if emptyp(l) then [] else 
 block([nn : min(length(l),n)],
  cons(take_elements(nn,l), partition_elements(rest(l,nn),n)))$
/* We have apply(append, partition_elements(l,n)) = l. */

/* Rotates a list n elements to the right. Negative n rotates to the left. */
rotate(l,n) := 
  if n = 0 or l = [] then l
  else if sign(n) = pos then  rotate(append([last(l)],rest(l,-1)), n-1)
  else rotate(append(rest(l), [first(l)]), n+1)$


/* Removes duplicated elements in the order they appear (i.e., the second
   occurrence and later ones are removed). */
/* Returns copies of each first occurrence. */
stable_unique(L) := block([h : sm2hm({}), res : []],
 for x in L do
   if not ev_hm(h,x) then (
     set_hm(h,x,true),
     res : endcons(x,res)),
 return(res))$


/* REMARK : Functions below should go to LinearAlgebra? */

/* Flattens a matrix or list into a list of the elements, row by row */
matrix2list(m) := apply(append, makelist(m[i],i,1,length(m)))$

/* Returns a list of the given matrix's columns (as lists) */
matrixcolumns(m) := partition_elements(matrix2list(transpose(m)),length(m))$

/* Builds a matrix from a list of it's columns (as lists) */
columns2matrix(mc) := transpose(apply(matrix, mc))$


/*!
\endhtmlonly
*/
