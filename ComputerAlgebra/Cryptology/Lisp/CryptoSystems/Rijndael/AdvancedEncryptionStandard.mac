/* Matthew Gwynne, 6.9.2007 (Swansea) */
/* Copyright 2007, 2008, 2009, 2010 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Cryptology/Lisp/CryptoSystems/Rijndael/AdvancedEncryptionStandard.mac
  \brief Implementing AES (Rijndael) and generalisations

Use by

oklib_load("OKlib/ComputerAlgebra/Cryptology/Lisp/CryptoSystems/Rijndael/AdvancedEncryptionStandard.mac");

*/

/*!
\htmlonly
*/

/* The following two files are guaranteed to be included: */
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/CryptoSystems/Rijndael/BitField.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/CryptoSystems/Rijndael/ByteField.mac")$

oklib_include("OKlib/ComputerAlgebra/DataStructures/Lisp/Lists.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Conversions.mac")$
oklib_include("OKlib/ComputerAlgebra/Algebra/Lisp/FiniteFields.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/CryptoSystems/Rijndael/data/Sbox.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/CryptoSystems/Rijndael/data/InvSbox.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/CryptoSystems/Rijndael/data/FieldMultiplications.mac")$
oklib_include("OKlib/ComputerAlgebra/CombinatorialMatrices/Lisp/Basics.mac")$

oklib_plain_include(eigen)$ /* (for function columnvector) */

/*
   The following functions implement AES with 128 bit up to
   192 bit block sizes and with the corresponding key block
   sizes, but for simplicity of implementation, not unequal block/key
   sizes.
*/


/* *************
   * Constants *
   *************
*/

/* Default number of rounds to be used in the AES functions. */
aes_num_rounds : 10$


/* *********
   * S box *
   *********
*/

/* Constant used in the affine transformation within sbox: */
rijn_affine_constant : '(x^6 + x^5 + x + 1)$
/* Constant used in the affine transformation within inv_sbox: */
rijn_inv_affine_constant : '(x^2 + 1)$ 

/* Matrix used in the affine transformation within rijn_sbox: */
rijn_sbox_matrix : apply(matrix,
  create_list(rotate([1,1,1,1,1,0,0,0],i),i,0,7))$
/* Matrix used in the affine transformation within inv_sbox: */
rijn_inv_sbox_matrix : apply(matrix,
  create_list(rotate([0,1,0,1,0,0,1,0],i),i,0,7))$

/* The AES sbox */

/* Takes a value from the byte field as vector and returns the result
   of applying the Rijndael Sbox operation (as vector): */
rijn_sbox_vec(v) := rijn_stand_vec(column_m(
   rijn_sbox_matrix . columnvector(rijn_vecinv(v)) +
   columnvector(polybin2vecbin_rijn(rijn_affine_constant)), 1))$
/* Now representing bytes as natural numbers: */
rijn_sbox_nat(bytei) := vecbin2nat(rijn_sbox_vec(nat2vecbin_rijn(bytei)))$
/* Now representing bytes as polynomials (the standard representation): */
rijn_sbox(bytei) := vecbin2polybin(rijn_sbox_vec(polybin2vecbin_rijn(bytei)))$

/* Inverse of Sbox: */
rijn_inv_sbox_vec(v) := rijn_vecinv(rijn_stand_vec(column_m(
  rijn_inv_sbox_matrix . columnvector(v) + 
  columnvector(polybin2vecbin_rijn(rijn_inv_affine_constant)),1)))$
rijn_inv_sbox_nat(bytei) := vecbin2nat(rijn_inv_sbox_vec(nat2vecbin_rijn(bytei)))$
rijn_inv_sbox(bytei) := vecbin2polybin(rijn_inv_sbox_vec(polybin2vecbin_rijn(bytei)))$

/* Sbox implementation that utilises a lookup array to provide fast operation:
*/
rijn_lookup_sbox_nat(bytei) := sbox_data[bytei+1]$
rijn_lookup_sbox(bytei) := nat2polybin(sbox_data[polybin2nat(bytei)+1])$

/* Inverse Sbox implementation that utilises a lookup array to provide 
   fast operation: */
rijn_lookup_inv_sbox_nat(bytei) := inv_sbox_data[bytei+1]$
rijn_lookup_inv_sbox(bytei) :=
  nat2polybin(inv_sbox_data[polybin2nat(bytei)+1])$


/* *************
   * Sub-bytes *
   *************
*/

/* 
   Takes the input block as a list of 16 bytes and applies
   the sbox operation to each byte, returning the list of 
   result bytes:
*/
rijn_subbytes(inputblock, sbox_f) := map(sbox_f, inputblock)$

/* 
   Takes the input block as a list of 16 bytes and applies
   the inverse sbox operation to each byte, returning the list of 
   result bytes:
*/
rijn_inv_subbytes(inputblock,inv_sbox_f) := map(inv_sbox_f, inputblock)$


/* **************
   * Shift rows *
   **************
*/

/*
   List of shifts left for each row in the block in the  shiftrows
   operation:
*/
aes_shiftrows_shifts : [0,1,2,3]$

/*
   Takes a list of GF(2^8) elements (the block), and
   performs the shiftrows operation, returning the resulting
   block as a list of GF(2^8) elements:
*/
aes_shiftrows(inputblock) := block(
[list_rows : partition_elements(transpose_l(inputblock,4),4)],
  transpose_l(m2l_r (
      create_list(rotate(list_rows[abs(r)+1],-r), r, aes_shiftrows_shifts)
  ),length(inputblock)/4))$

/*
   Takes a list of GF(2^8) elements (the block), and
   performs the inverse shiftrows operation, returning the resulting
   block as a list of GF(2^8) elements:
*/
aes_inv_shiftrows(inputblock) := 
  block([aes_shiftrows_shifts : -aes_shiftrows_shifts],
  aes_shiftrows(inputblock))$


/* ***************
   * Mix columns *
   ***************
*/

/*
   Matrix used in the mixcolumns step to model the 
   multiplication of each 4-byte column by a constant
   in a polynomial ring of at most order 4 with coefficients in
   GF(2^8):
*/
rijn_mixcolumns_matrix : block([x], apply(matrix, 
  create_list(rotate([x, x + 1, 1, 1], i),i,0,3)))$
/* Inverse of the rijn_mix_columns_matrix: */
rijn_inv_mixcolumns_matrix : block([x], apply(matrix,
  create_list(rotate([x^3+x^2+x,x^3+x+1,x^3+x^2+1,x^3+1], i),i,0,3)))$

/* Mixcolumn operation applied to the elements of a single
   column in the AES/Rijndael block: */
rijn_mixcolumn(inputblocki) :=
  map(rijn_stand,m2l_r(
      rijn_mixcolumns_matrix . columnvector(inputblocki)));

/*
   Takes a list of GF(2^8) elements (the block), and
   performs the mixcolumns operation, returning the resulting
   block as a list of GF(2^8) elements. A function specifying
   the actual operation done on a particular column must be
   provided as the second argument.
*/
rijn_mixcolumns(inputblock,mixcolumn_f) :=
  transpose_l(m2l_r(columns2matrix(
    map(
      lambda([a], map(polybin2nat,mixcolumn_f(map(nat2polybin,a)))),
      matrixcolumns(
      apply(matrix,partition_elements(transpose_l(inputblock,4),4)))))),4)$

/* Mixcolumn operation applied to the elements of a single
   column in the AES/Rijndael block: */
rijn_inv_mixcolumn(inputblock) :=
  block([rijn_mixcolumns_matrix : rijn_inv_mixcolumns_matrix],
    rijn_mixcolumn(inputblock))$

/*
   Takes a list of GF(2^8) elements (the block), and
   performs the inverse mixcolumns operation, returning the resulting
   block as a list of GF(2^8) elements. A function specifying
   the actual operation done on a particular column must be
   provided as the second argument.
*/
rijn_inv_mixcolumns(inputblock,inv_mixcolumn_f) := 
  rijn_mixcolumns(inputblock,inv_mixcolumn_f)$


/* *****************
   * Key expansion *
   *****************
*/

/*
   Takes an AES round key for round r as a list of
   integers and returns the round key for round r+1.
 */
aes_keyschedule(kl, r, sbox_f) := block(
  [newcols, oldcols : partition_elements(kl,4), n_k : length(kl)/4,
   round_constant : x^(r-1)],
  newcols : [create_list(
    oldcols[1][i] + sbox_f(oldcols[n_k][mod(i,4)+1]) + 
      if i = 1 then round_constant else 0,i,1,4)],
  for j : 2 thru n_k do
    newcols : endcons(
      create_list(oldcols[j][i] + newcols[j-1][i],i,1,4),newcols),
  return(map(rijn_stand,m2l_r(newcols))))$

/* Given the AES key as a list of integers representing the
   byte field elements in the AES key block, column by column,
   returns a list of integers representing the byte field elements
   of the concatenation of the round key blocks for all AES rounds,
   column by column.
 */
 aes_key_expansion(kl, sbox_f) := block(
  [ks : lambda([kl,r],
    endcons(aes_keyschedule(last(kl),r,sbox_f),kl))],
  m2l_r(lreduce(ks, create_list(i,i,1,aes_num_rounds), [kl])))$


/* *********************************
   * AES encryption and decryption *
   *********************************
*/

/* 
   Takes the plaintext list of GF(2^8) elements and the 
   round key for this round as a list of GF(2^8) elements, and
   returns a list of the same size of GF(2^8) elements as the plaintext
   as the result of the round operation:
 */
aes_round(pl, rkl, sbox_f, mixcolumn_f, aes_add) := 
  map(aes_add,
    rijn_mixcolumns(aes_shiftrows(rijn_subbytes(pl,sbox_f)),mixcolumn_f),rkl)$
aes_inv_round(pl,rkl,inv_sbox_f,inv_mixcolumn_f,aes_add) := 
  rijn_inv_subbytes(aes_inv_shiftrows(
    rijn_inv_mixcolumns(map(aes_add,pl,rkl),inv_mixcolumn_f)), inv_sbox_f)$

/* 
   Takes the plaintext list of 16 GF(2^8) elements, the key list of 16
   GF(2^8) elements and returns the result of applying the 128 bit AES 
   encryption algorithm (hence number of rounds is assumed to be 10):
*/
aes_encrypt(pl, kl, sbox_f, mixcolumn_f,aes_add) := block(
  [ks_sbox_f :
    buildq([sbox_f],lambda([a], nat2polybin(sbox_f(polybin2nat(a)))))],
  /* Initial Rounds */
  ekl : partition_elements(
    map(polybin2nat,
      aes_key_expansion(map(nat2polybin,kl),ks_sbox_f)),length(pl)),
  initial_rk : first(ekl), final_rk : last(ekl),
  initial_result : 
    lreduce(lambda([a,b],aes_round(a,b,sbox_f,mixcolumn_f,aes_add)),
    rest(rest(ekl), -1), map(aes_add,pl,initial_rk)),
  /* Final Round */
  if aes_num_rounds = 10 then
    map(aes_add,aes_shiftrows(rijn_subbytes(initial_result,sbox_f)), final_rk)
  else
    aes_round(initial_result,final_rk, sbox_f, mixcolumn_f,aes_add)
)$

/* 
   Takes the ciphertext list of 16 GF(2^8) elements, the key list of 16
   GF(2^8) elements and returns the result of applying the 128 bit AES 
   decryption algorithm (hence number of rounds is assumed to be 10):
*/
aes_decrypt(pl, kl, sbox_f, inv_sbox_f,inv_mixcolumn_f,aes_add) := block(
  [ks_sbox_f :
    buildq([sbox_f],lambda([a], nat2polybin(sbox_f(polybin2nat(a)))))],
  /* Initial Rounds */
  ekl : partition_elements(
    map(polybin2nat,
      aes_key_expansion(map(nat2polybin,kl),ks_sbox_f)),length(pl)),
  initial_rk : first(ekl), final_rk : last(ekl),
  /* Final Round */
  if aes_num_rounds = 10 then
    initial_result : 
      rijn_inv_subbytes(aes_inv_shiftrows(map(aes_add,pl,final_rk)),
        inv_sbox_f)
  else
    initial_result :
      aes_inv_round(pl,final_rk, inv_sbox_f,inv_mixcolumn_f,aes_add),
  map(aes_add, rreduce(lambda([a,b],
    aes_inv_round(a,b,inv_sbox_f,inv_mixcolumn_f,aes_add)), 
    rest(rest(ekl), -1), initial_result), initial_rk)
)$


/* *************************************
   * Convenience instantiations of AES *
   *************************************
*/


/* Different forms of computation */

/* AES Encryption using lookup tables: */
aes_encrypt_l(p,k) := 
  aes_encrypt(p,k,rijn_lookup_sbox_nat,rijn_mixcolumn,rijn_nataddl)$

/* AES Encryption using field operations: */
aes_encrypt_f(p,k) := 
  aes_encrypt(p,k,rijn_sbox_nat,rijn_mixcolumn,rijn_natadd)$

/* AES Decryption using lookup tables: */
aes_decrypt_l(c,k) := 
  aes_decrypt(c,k,rijn_lookup_sbox_nat,rijn_lookup_inv_sbox_nat,rijn_inv_mixcolumn,rijn_nataddl)$

/* AES Decryption using field operations: */
aes_decrypt_f(c,k) := 
  aes_decrypt(c,k,rijn_sbox_nat,rijn_inv_sbox_nat,rijn_inv_mixcolumn,rijn_natadd)$


/* Various representations of input/output */

/* Input and output as hexadecimal values (the input does not need
   leading zeros, but the output is always padded to 32 hexadecimal
   digits): */
aes_encrypt_hex(p,k) := 
  lpad(int2hex(polyadic2int(
    aes_encrypt_l(
      pad_block_16(pad_block_16(int2polyadic(hex2int(p),256))),
      pad_block_16(pad_block_16(int2polyadic(hex2int(k),256)))
    ),
    256)), "0", 32)$
aes_decrypt_hex(p,k) := 
  lpad(int2hex(polyadic2int(
    aes_decrypt_l(
      pad_block_16(pad_block_16(int2polyadic(hex2int(p),256))),
      pad_block_16(pad_block_16(int2polyadic(hex2int(k),256)))
    ),
    256)), "0", 32)$

/* The AES-chiffre as number-theoretical function: */
aes_int(p,k) :=
  polyadic2int(
    aes_encrypt_l(
      pad_block_16(int2polyadic(p,256)), 
      pad_block_16(int2polyadic(k,256))
    ),
    256)$


/*!
\endhtmlonly
*/
