/* Matthew Gwynne, 27.1.2010 (Swansea) */
/* Copyright 2010 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Cryptology/Lisp/CryptoSystems/Rijndael/SmallScaleAdvancedEncryptionStandard.mac
  \brief Implementing AES (Rijndael) and generalisations

Use by

oklib_load("OKlib/ComputerAlgebra/Cryptology/Lisp/CryptoSystems/Rijndael/AdvancedEncryptionStandard.mac");

*/

/*!
\htmlonly
*/

/* The following two files are guaranteed to be included: */
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/CryptoSystems/Rijndael/SmallScaleWordFields.mac")$

oklib_include("OKlib/ComputerAlgebra/DataStructures/Lisp/Lists.mac")$

oklib_plain_include(eigen)$ /* (for function columnvector) */

oklib_include("OKlib/ComputerAlgebra/CombinatorialMatrices/Lisp/Basics.mac")$


/* *********
   * S box *
   *********
*/

/* Constant used in the affine transformation within ss_sbox: */
ss_affine_constant_2_4 : '(x^2+x)$
ss_affine_constant_2_8 : '(x^6 + x^5 + x + 1)$
/* Returns the default affine constant for the default GF(b^e) field. */
ss_affine_constant_std(b,e) :=
  if b = 2 then
    if e = 4 then ss_affine_constant_2_4
    else if e = 8 then ss_affine_constant_2_8
    else und
  else und$
/* TODO: Should these just be computed using the default sbox_matrices?
   As it is simply the result of multiplying the matrix by the affine
   constant. */
/* Constant used in the affine transformation within ss_inv_sbox: */
/* Generated by multiplying the corresponding Sbox matrix by the
   vector for the affine constant and converting back to polynomials. */
ss_inv_affine_constant_2_4 : '(x+1)$ 
ss_inv_affine_constant_2_8 : '(x^2 + 1)$
/* Returns the default inverse affine constant for the default GF(b^e) field. */
ss_inv_affine_constant_std(b,e) :=
  if b = 2 then
    if e = 4 then ss_inv_affine_constant_2_4
    else if e = 8 then ss_inv_affine_constant_2_8
    else und
  else und$



/* Matrix used in the affine transformation within ss_sbox: */
ss_sbox_matrix_2_4 : apply(matrix,
  create_list(rotate([1,0,1,1],i),i,0,3))$
ss_sbox_matrix_2_8 : apply(matrix,
  create_list(rotate([1,1,1,1,1,0,0,0],i),i,0,7))$
/* Returns the default sbox matrix for the default GF(b^e) field. */
ss_sbox_matrix_std(b,e) :=
  if b = 2 then
    if e = 4 then ss_sbox_matrix_2_4
    else if e = 8 then ss_sbox_matrix_2_8
    else und
  else und$
/* Matrix used in the affine transformation within ss_sbox: */
ss_inv_sbox_matrix_2_4 : apply(matrix,
  create_list(rotate([1,1,1,0],i),i,0,3))$
ss_inv_sbox_matrix_2_8 : apply(matrix,
  create_list(rotate([0,1,0,1,0,0,1,0],i),i,0,7))$
/* Returns the default inverse sbox matrix for the default GF(b^e) field. */
ss_inv_sbox_matrix_std(b,e) :=
  if b = 2 then
    if e = 4 then ss_inv_sbox_matrix_2_4
    else if e = 8 then ss_inv_sbox_matrix_2_8
    else und
  else und$

/* The small scale AES sbox */

ss_sbox(wordi,b,e,mod_poly, sbox_matrix,affine_constant) := 
  ss_stand(vec2poly(column_m(
    sbox_matrix .
    columnvector(
      poly2vec_ss(ss_einv(ss_stand(wordi,b,mod_poly),b,mod_poly),e)),1)) +
      affine_constant,b,mod_poly)$
ss_sbox_std(wordi, b,e) :=
  ss_sbox(wordi,b,e,ss_polynomial_std(b,e),
    ss_sbox_matrix_std(b,e),ss_affine_constant_std(b,e))$
ss_inv_sbox(wordi,b,e,mod_poly, inv_sbox_matrix,inv_affine_constant) := block(
  ss_einv(ss_stand(vec2poly(column_m(
    inv_sbox_matrix .
    columnvector(
      poly2vec_ss(wordi,e)),1)) +
      inv_affine_constant,b,mod_poly),b,mod_poly))$
ss_inv_sbox_std(wordi, b,e) :=
  ss_inv_sbox(wordi,b,e,ss_polynomial_std(b,e),
    ss_inv_sbox_matrix_std(b,e),ss_inv_affine_constant_std(b,e))$



/*!
\endhtmlonly
*/