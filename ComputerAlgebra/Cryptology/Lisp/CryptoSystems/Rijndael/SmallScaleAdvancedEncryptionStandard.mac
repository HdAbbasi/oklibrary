/* Matthew Gwynne, 27.1.2010 (Swansea) */
/* Copyright 2010 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Cryptology/Lisp/CryptoSystems/Rijndael/SmallScaleAdvancedEncryptionStandard.mac
  \brief Implementing the small-scale variation of AES, and generalisations

Use by

oklib_load("OKlib/ComputerAlgebra/Cryptology/Lisp/CryptoSystems/Rijndael/AdvancedEncryptionStandard.mac");

*/

/*!
\htmlonly
*/

/* The following file is guaranteed to be included: */
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/CryptoSystems/Rijndael/SmallScaleWordFields.mac")$

oklib_include("OKlib/ComputerAlgebra/DataStructures/Lisp/Lists.mac")$

oklib_plain_include(eigen)$ /* (for function columnvector) */

oklib_include("OKlib/ComputerAlgebra/CombinatorialMatrices/Lisp/Basics.mac")$

/* GENERAL SPECIFICATION */


/* *********
   * S box *
   *********
*/

/* Constant used in the affine transformation within ss_sbox: */
ss_affine_constant_2_4 : '(x^2+x)$
ss_affine_constant_2_8 : '(x^6 + x^5 + x + 1)$
/* Returns the default affine constant for the default GF(b^e) field: */
ss_affine_constant(b,e) :=
  if b = 2 then
    if e = 4 then ss_affine_constant_2_4
    else if e = 8 then ss_affine_constant_2_8
    else und
  else und$
/* TODO: Should the constants below be computed using the default 
   sbox_matrices? As they are simply the result of multiplying the matrix by 
   the affine constant. */
/* Constant used in the affine transformation within ss_inv_sbox: */
/* Generated by multiplying the corresponding Sbox matrix by the
   vector for the affine constant and converting back to polynomials. */
ss_inv_affine_constant_2_4 : '(x+1)$ 
ss_inv_affine_constant_2_8 : '(x^2 + 1)$
/* Returns the default inverse affine constant for the default GF(b^e) field. */
ss_inv_affine_constant(b,e) :=
  if b = 2 then
    if e = 4 then ss_inv_affine_constant_2_4
    else if e = 8 then ss_inv_affine_constant_2_8
    else und
  else und$



/* Matrix used in the affine transformation within ss_sbox: */
ss_sbox_matrix_2_4 : apply(matrix,
  create_list(rotate([1,0,1,1],i),i,0,3))$
ss_sbox_matrix_2_8 : apply(matrix,
  create_list(rotate([1,1,1,1,1,0,0,0],i),i,0,7))$
/* Returns the default sbox matrix for the default GF(b^e) field. */
ss_sbox_matrix(b,e) :=
  if b = 2 then
    if e = 4 then ss_sbox_matrix_2_4
    else if e = 8 then ss_sbox_matrix_2_8
    else und
  else und$
/* Matrix used in the affine transformation within ss_sbox: */
ss_inv_sbox_matrix_2_4 : apply(matrix,
  create_list(rotate([1,1,1,0],i),i,0,3))$
ss_inv_sbox_matrix_2_8 : apply(matrix,
  create_list(rotate([0,1,0,1,0,0,1,0],i),i,0,7))$
/* Returns the default inverse sbox matrix for the default GF(b^e) field. */
ss_inv_sbox_matrix(b,e) :=
  if b = 2 then
    if e = 4 then ss_inv_sbox_matrix_2_4
    else if e = 8 then ss_inv_sbox_matrix_2_8
    else und
  else und$

/* The small scale AES sbox */
/* SPECIFICATION ?? */
/* wordi ?? */
ss_sbox(wordi,b,e,mod_poly, sbox_matrix,affine_constant) := 
  ss_stand(vec2poly(column_m(
    sbox_matrix .
    columnvector(
      poly2vec_ss(ss_einv(ss_stand(wordi,b,mod_poly),b,mod_poly),e)),1)) +
      affine_constant,b,mod_poly)$
/* std ?? */
ss_sbox_std(wordi, b,e) :=
  ss_sbox(wordi,b,e,ss_polynomial(b,e),
    ss_sbox_matrix(b,e),ss_affine_constant(b,e))$
ss_inv_sbox(wordi,b,e,mod_poly, inv_sbox_matrix,inv_affine_constant) := block(
  ss_einv(ss_stand(vec2poly(column_m(
    inv_sbox_matrix .
    columnvector(
      poly2vec_ss(wordi,e)),1)) +
      inv_affine_constant,b,mod_poly),b,mod_poly))$
ss_inv_sbox_std(wordi, b,e) :=
  ss_inv_sbox(wordi,b,e,ss_polynomial(b,e),
    ss_inv_sbox_matrix(b,e),ss_inv_affine_constant(b,e))$


/* *************
   * Sub-bytes *
   *************
*/

/* 
??? range ??? 16
   Takes the input block as a matrix of 16 polynomials in
   the range 0-nat2polybin(b^e -1) and applies the sbox operation to
   each polynomial, returning the matrix of result polynomials:
*/
ss_subbytes(inputmatrix, sbox_f) := matrixmap(sbox_f, inputmatrix)$

/* 
   Takes the input block as a matrix of 16 polynomials in the range
   0-nat2polybin(b^e-1) and applies the inverse sbox operation to each
   polynomial, returning the list of result polynomials:
*/
ss_inv_subbytes(inputmatrix,inv_sbox_f) := matrixmap(inv_sbox_f, inputmatrix)$


/* **************
   * Shift rows *
   **************
*/


/*
   Takes a matrix and performs the shiftrows operation,
   returning a matrix where each row has been shifted
   cyclically by the specified amount (see aes_shiftrows_shifts[i]
   for the shift for the i'th row).
*/
ss_shiftrows(inputmatrix) :=
  apply(matrix,
    create_list(rotate(inputmatrix[abs(r)+1],-r), r, 0,length(inputmatrix)-1))$


/*
   Takes a matrix and performs the inverse shiftrows operation,
   returning a matrix where each row has been shifted
   cyclically by the specified amount (see -aes_shiftrows_shifts[i]
   for the shift for the i'th row).
*/
ss_inv_shiftrows(inputmatrix) :=
  apply(matrix,
    create_list(rotate(inputmatrix[abs(r)+1],r), r, 0,length(inputmatrix)-1))$


/* ***************
   * Mix columns *
   ***************
*/

/*
   Matrices used in the mixcolumns step to model the 
   multiplication of each n_C-byte column by a constant
   in a polynomial ring of at most order n_C with coefficients in
   GF(b^e):
*/
ss_mixcolumns_matrix_2_4_1 : matrix([1])$
ss_mixcolumns_matrix_2_8_1 : matrix([1])$
ss_mixcolumns_matrix_2_4_2 : block([x], apply(matrix,
  create_list(rotate([x+1,x],i),i,0,1)))$
ss_mixcolumns_matrix_2_8_2 : block([x], apply(matrix,
  create_list(rotate([x+1,x],i),i,0,1)))$
ss_mixcolumns_matrix_2_4_4 : block([x], apply(matrix, 
  create_list(rotate([x, x + 1, 1, 1], i),i,0,3)))$
ss_mixcolumns_matrix_2_8_4 : block([x], apply(matrix, 
  create_list(rotate([x, x + 1, 1, 1], i),i,0,3)))$
ss_mixcolumns_matrix(b,e,n_R) :=
  if b = 2 then
    if n_R = 4 then
      if e = 4 then ss_mixcolumns_matrix_2_4_4
      else if e = 8 then ss_mixcolumns_matrix_2_8_4
      else und
    else if n_R = 2 then
      if e = 4 then ss_mixcolumns_matrix_2_4_2
      else if e = 8 then ss_mixcolumns_matrix_2_8_2
      else und
    else if n_R = 1 then
      if e = 4 then ss_mixcolumns_matrix_2_4_1
      else if e = 8 then ss_mixcolumns_matrix_2_8_1
      else und
    else und
  else und$
/* Inverse of the rijn_mix_columns_matrix: */
ss_inv_mixcolumns_matrix_2_4_1 : matrix([1])$
ss_inv_mixcolumns_matrix_2_8_1 : matrix([1])$
ss_inv_mixcolumns_matrix_2_4_2 : block([x], apply(matrix,
  create_list(rotate([x+1,x], i),i,0,1)))$
ss_inv_mixcolumns_matrix_2_8_2 : block([x], apply(matrix,
  create_list(rotate([x+1,x], i),i,0,1)))$
ss_inv_mixcolumns_matrix_2_4_4 : block([x], apply(matrix,
  create_list(rotate([x^3+x^2+x,x^3+x+1,x^3+x^2+1,x^3+1], i),i,0,3)))$
ss_inv_mixcolumns_matrix_2_8_4 : block([x], apply(matrix,
  create_list(rotate([x^3+x^2+x,x^3+x+1,x^3+x^2+1,x^3+1], i),i,0,3)))$
ss_inv_mixcolumns_matrix(b,e,n_R) :=
  if b = 2 then
    if n_R = 4 then
      if e = 4 then ss_inv_mixcolumns_matrix_2_4_4
      else if e = 8 then ss_inv_mixcolumns_matrix_2_8_4
      else und
    else if n_R = 2 then
      if e = 4 then ss_inv_mixcolumns_matrix_2_4_2
      else if e = 8 then ss_inv_mixcolumns_matrix_2_8_2
      else und
    else if n_R = 1 then
      if e = 4 then ss_inv_mixcolumns_matrix_2_4_1
      else if e = 8 then ss_inv_mixcolumns_matrix_2_8_1
      else und
    else und
  else und$


/* Mixcolumn operation applied to the elements of a single
   column (given a matrix of polynomials) in the AES/Rijndael block: */
ss_mixcolumn(inputmatrixi,b,e,mod_poly,mixcolumns_matrix) :=
  matrixmap(lambda([p],ss_stand(p,b,mod_poly)),
      mixcolumns_matrix . inputmatrixi);
ss_mixcolumn_std(inputmatrix,b,e) := block(
  ss_mixcolumn(inputmatrix,b,e,
    ss_polynomial(b,e),
    ss_mixcolumns_matrix(b,e,length(inputmatrix))))$

/*
   Takes a list of GF(b^e) elements (the block), and
   performs the mixcolumns operation, returning the resulting
   block as a list of GF(b^e) elements. A function specifying
   the actual operation done on a particular column must be
   provided as the second argument.
*/
ss_mixcolumns(inputmatrix,mixcolumn_f) := block([M : matrix()],
  for i : 1 thru length(matrixcolumns(inputmatrix)) do
    M : addcol(M,mixcolumn_f(col(inputmatrix,i))),
  return(M))$

/* Mixcolumn operation applied to the elements of a single
   column (given a matrix) in the AES/Rijndael block: */
ss_inv_mixcolumn(inputmatrix,b,e,mod_poly,inv_mixcolumns_matrix) :=
    ss_mixcolumn(inputmatrix,b,e,mod_poly,inv_mixcolumns_matrix)$
ss_inv_mixcolumn_std(inputmatrix,b,e) :=
  ss_inv_mixcolumn(inputmatrix,b,e,
    ss_polynomial(b,e),
    ss_inv_mixcolumns_matrix(b,e,length(inputmatrix)))$

/*
   Takes a list of GF(b^e) elements (the block), and
   performs the inverse mixcolumns operation, returning the resulting
   block as a list of GF(b^e) elements. A function specifying
   the actual operation done on a particular column must be
   provided as the second argument.
*/
ss_inv_mixcolumns(inputmatrix,inv_mixcolumn_f) := 
  ss_mixcolumns(inputmatrix,inv_mixcolumn_f)$


/* *****************
   * Key expansion *
   *****************
*/

/*
   Takes an AES round key for round r as a list of
   polynomials and returns the round key for round r+1.
 */
ss_keyschedule(kl, r, b, mod_poly, sbox_f) := block(
  [newcols : matrix(), n_C : length(matrixcolumns(kl)),
   round_constant : x^(r-1), n_R : length(kl)],
  newcols : addcol(newcols,columnvector(
      create_list(
        (if n_C > 1 then kl[i,1] else 0) + sbox_f(kl[mod(i,n_R)+1,n_C]) + 
        if i = 1 then round_constant else 0,i,1,n_R))),
  for j : 2 thru n_C do
    newcols : addcol(newcols,columnvector(
      create_list(kl[i,j] + newcols[i,j-1],i,1,n_R))),
  return(matrixmap(lambda([p],ss_stand(p,b,mod_poly)),newcols)))$

/* Given the AES key as a list of polynomials representing the
   byte field elements in the AES key block, column by column,
   returns a list of polynomials representing the byte field elements
   of the concatenation of the round key blocks for all AES rounds,
   column by column.
 */
ss_key_expansion(kl, num_rounds, b, mod_poly, sbox_f) := block(
  [ks : lambda([kl,r],
    endcons(ss_keyschedule(last(kl),r,b,mod_poly,sbox_f),kl))],
  apply(addcol,lreduce(ks, create_list(i,i,1,num_rounds), [kl])))$
ss_key_expansion_std(kl,num_rounds,b,e) := 
  ss_key_expansion(kl,num_rounds,b,ss_polynomial(b,e), ss_sbox_std(b,e))$


/* *********************************************
   * Small scale AES encryption and decryption *
   *********************************************
*/

/* 
   Takes the plaintext matrix of GF(2^8) elements and the 
   round key for this round as a list of GF(2^8) elements, and
   returns a matrix of the same size of GF(2^8) elements as the plaintext
   as the result of the round operation:
 */
ss_round_wa(pl,sbox_f,mixcolumn_f) := 
    ss_mixcolumns(ss_shiftrows(
        ss_subbytes(pl,sbox_f)),mixcolumn_f)$
ss_round(pl, rkl,b,mod_poly,sbox_f, mixcolumn_f) := 
  matrixmap(lambda([p], ss_stand(p,b,mod_poly)),
    ss_round_wa(pl,sbox_f,mixcolumn_f)+rkl)$
ss_inv_round_wa(pl,inv_sbox_f,inv_mixcolumn_f) := 
    ss_inv_subbytes(ss_inv_shiftrows(
        ss_inv_mixcolumns(pl,inv_mixcolumn_f)), inv_sbox_f)$
ss_inv_round(pl,rkl,inv_sbox_f,inv_mixcolumn_f) := 
    ss_inv_round_wa(pl+rkl,inv_sbox_f, inv_mixcolumn_f)$

/* 
   Takes the plaintext matrix of GF(2^8) elements and the 
   round key for this round as a list of GF(2^8) elements, and
   returns a matrix of the same size of GF(2^8) elements as the plaintext
   as the result of the final aes round operation (without mixcolumn):
 */
ss_final_round_wa(pl,sbox_f) := /* Without round key addition */
    ss_shiftrows(
        ss_subbytes(pl,sbox_f))$
ss_final_round(pl,rkl,b,mod_poly, sbox_f) := 
  matrixmap(lambda([p],ss_stand(p,b,mod_poly)),
    ss_final_round_wa(pl,sbox_f)+rkl)$
ss_inv_final_round_wa(pl,inv_sbox_f) := 
    ss_inv_subbytes(ss_inv_shiftrows(pl), inv_sbox_f)$
ss_inv_final_round(pl,rkl,inv_sbox_f) := 
    ss_inv_final_round_wa(pl+rkl, inv_sbox_f)$


/* 
   Takes the plaintext matrix of 16 GF(2^8) elements, the key matrix of 16
   GF(2^8) elements and returns the result of applying the 128 bit AES 
   encryption algorithm (hence number of rounds is assumed to be 10):
*/
ss_encrypt_wf(pl, kl, num_rounds,b,e,mod_poly, sbox_f, mixcolumn_f) := block(
  [n_C : length(pl),
   partition_m : lambda([M,n], 
     map(columns2matrix,partition_elements(matrixcolumns(M),n)))],
  /* Initial Rounds */
  ekl : partition_m(ss_key_expansion(kl,num_rounds,b,mod_poly,sbox_f),n_C),
  initial_rk : first(ekl), final_rk : last(ekl),
  initial_result : 
    lreduce(lambda([m,n],
        ss_round(m,n,b,mod_poly,sbox_f,mixcolumn_f)),
    rest(rest(ekl), -1), pl + initial_rk),
  /* Final Round */
  matrixmap(lambda([p],ss_stand(p,b,mod_poly)),
    if num_rounds = 10 then
      ss_final_round(initial_result,final_rk, b,mod_poly, sbox_f)
    else
      ss_round(
          initial_result,final_rk,b,mod_poly, sbox_f, mixcolumn_f))
)$

/* 
   Takes the ciphertext list of 16 GF(2^8) elements, the key list of 16
   GF(2^8) elements and returns the result of applying the 128 bit AES 
   decryption algorithm (hence number of rounds is assumed to be 10):
*/
ss_decrypt_wf(pl, kl, num_rounds, b,e,mod_poly, sbox_f, inv_sbox_f,inv_mixcolumn_f) := block(
  [n_C : length(pl),
   partition_m : lambda([M,n], /* This should be moved somewhere suitable */
    map(columns2matrix,partition_elements(matrixcolumns(M),n)))],
  /* Initial Rounds */
  ekl : partition_m(ss_key_expansion(kl,num_rounds,b,mod_poly,sbox_f),n_C),
  initial_rk : first(ekl), final_rk : last(ekl),
  /* Final Round */
  if num_rounds = 10 then
    initial_result : ss_inv_final_round(pl,final_rk,inv_sbox_f)
  else
    initial_result :
      ss_inv_round(pl,final_rk, inv_sbox_f,inv_mixcolumn_f),
  matrixmap(lambda([a],ss_stand(a,b,mod_poly)),
    rreduce(
      lambda([a,b],ss_inv_round(a,b,inv_sbox_f,inv_mixcolumn_f)), 
      rest(rest(ekl), -1), initial_result) + initial_rk)
)$

/*!
\endhtmlonly
*/
