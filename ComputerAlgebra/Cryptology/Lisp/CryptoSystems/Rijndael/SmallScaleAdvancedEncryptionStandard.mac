/* Matthew Gwynne, 27.1.2010 (Swansea) */
/* Copyright 2010 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Cryptology/Lisp/CryptoSystems/Rijndael/SmallScaleAdvancedEncryptionStandard.mac
  \brief Implementing AES (Rijndael) and generalisations

Use by

oklib_load("OKlib/ComputerAlgebra/Cryptology/Lisp/CryptoSystems/Rijndael/AdvancedEncryptionStandard.mac");

*/

/*!
\htmlonly
*/

/* The following two files are guaranteed to be included: */
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/CryptoSystems/Rijndael/SmallScaleWordFields.mac")$

oklib_include("OKlib/ComputerAlgebra/DataStructures/Lisp/Lists.mac")$

oklib_plain_include(eigen)$ /* (for function columnvector) */

oklib_include("OKlib/ComputerAlgebra/CombinatorialMatrices/Lisp/Basics.mac")$


/* *********
   * S box *
   *********
*/

/* Constant used in the affine transformation within ss_sbox: */
ss_affine_constant_2_4 : '(x^2+x)$
ss_affine_constant_2_8 : '(x^6 + x^5 + x + 1)$
/* Returns the default affine constant for the default GF(b^e) field. */
ss_affine_constant_std(b,e) :=
  if b = 2 then
    if e = 4 then ss_affine_constant_2_4
    else if e = 8 then ss_affine_constant_2_8
    else und
  else und$
/* TODO: Should these just be computed using the default sbox_matrices?
   As it is simply the result of multiplying the matrix by the affine
   constant. */
/* Constant used in the affine transformation within ss_inv_sbox: */
/* Generated by multiplying the corresponding Sbox matrix by the
   vector for the affine constant and converting back to polynomials. */
ss_inv_affine_constant_2_4 : '(x+1)$ 
ss_inv_affine_constant_2_8 : '(x^2 + 1)$
/* Returns the default inverse affine constant for the default GF(b^e) field. */
ss_inv_affine_constant_std(b,e) :=
  if b = 2 then
    if e = 4 then ss_inv_affine_constant_2_4
    else if e = 8 then ss_inv_affine_constant_2_8
    else und
  else und$



/* Matrix used in the affine transformation within ss_sbox: */
ss_sbox_matrix_2_4 : apply(matrix,
  create_list(rotate([1,0,1,1],i),i,0,3))$
ss_sbox_matrix_2_8 : apply(matrix,
  create_list(rotate([1,1,1,1,1,0,0,0],i),i,0,7))$
/* Returns the default sbox matrix for the default GF(b^e) field. */
ss_sbox_matrix_std(b,e) :=
  if b = 2 then
    if e = 4 then ss_sbox_matrix_2_4
    else if e = 8 then ss_sbox_matrix_2_8
    else und
  else und$
/* Matrix used in the affine transformation within ss_sbox: */
ss_inv_sbox_matrix_2_4 : apply(matrix,
  create_list(rotate([1,1,1,0],i),i,0,3))$
ss_inv_sbox_matrix_2_8 : apply(matrix,
  create_list(rotate([0,1,0,1,0,0,1,0],i),i,0,7))$
/* Returns the default inverse sbox matrix for the default GF(b^e) field. */
ss_inv_sbox_matrix_std(b,e) :=
  if b = 2 then
    if e = 4 then ss_inv_sbox_matrix_2_4
    else if e = 8 then ss_inv_sbox_matrix_2_8
    else und
  else und$

/* The small scale AES sbox */

ss_sbox(wordi,b,e,mod_poly, sbox_matrix,affine_constant) := 
  ss_stand(vec2poly(column_m(
    sbox_matrix .
    columnvector(
      poly2vec_ss(ss_einv(ss_stand(wordi,b,mod_poly),b,mod_poly),e)),1)) +
      affine_constant,b,mod_poly)$
ss_sbox_std(wordi, b,e) :=
  ss_sbox(wordi,b,e,ss_polynomial_std(b,e),
    ss_sbox_matrix_std(b,e),ss_affine_constant_std(b,e))$
ss_inv_sbox(wordi,b,e,mod_poly, inv_sbox_matrix,inv_affine_constant) := block(
  ss_einv(ss_stand(vec2poly(column_m(
    inv_sbox_matrix .
    columnvector(
      poly2vec_ss(wordi,e)),1)) +
      inv_affine_constant,b,mod_poly),b,mod_poly))$
ss_inv_sbox_std(wordi, b,e) :=
  ss_inv_sbox(wordi,b,e,ss_polynomial_std(b,e),
    ss_inv_sbox_matrix_std(b,e),ss_inv_affine_constant_std(b,e))$


/* *************
   * Sub-bytes *
   *************
*/

/* 
   Takes the input block as a matrix of 16 polynomials in
   the range 0-nat2polybin(b^e -1) and applies the sbox operation to
   each polynomial, returning the matrix of result polynomials:
*/
ss_subbytes(inputmatrix, sbox_f) := matrixmap(sbox_f, inputmatrix)$

/* 
   Takes the input block as a matrix of 16 polynomials in the range
   0-nat2polybin(b^e-1) and applies the inverse sbox operation to each
   polynomial, returning the list of result polynomials:
*/
ss_inv_subbytes(inputmatrix,inv_sbox_f) := matrixmap(inv_sbox_f, inputmatrix)$


/* **************
   * Shift rows *
   **************
*/


/*
   Takes a matrix and performs the shiftrows operation,
   returning a matrix where each row has been shifted
   cyclically by the specified amount (see aes_shiftrows_shifts[i]
   for the shift for the i'th row).
*/
ss_shiftrows(inputmatrix) :=
  apply(matrix,
    create_list(rotate(inputmatrix[abs(r)+1],-r), r, 0,length(inputmatrix)-1))$


/*
   Takes a matrix and performs the inverse shiftrows operation,
   returning a matrix where each row has been shifted
   cyclically by the specified amount (see -aes_shiftrows_shifts[i]
   for the shift for the i'th row).
*/
ss_inv_shiftrows(inputmatrix) :=
  apply(matrix,
    create_list(rotate(inputmatrix[abs(r)+1],r), r, 0,length(inputmatrix)-1))$


/* ***************
   * Mix columns *
   ***************
*/

/*
   Matrices used in the mixcolumns step to model the 
   multiplication of each n_C-byte column by a constant
   in a polynomial ring of at most order n_C with coefficients in
   GF(b^e):
*/
ss_mixcolumns_matrix_2_8 : block([x], apply(matrix, 
  create_list(rotate([x, x + 1, 1, 1], i),i,0,3)))$
ss_mixcolumns_std(b,e) :=
  if b = 2 then
    if e = 8 then ss_mixcolumns_matrix_2_8
    else und
  else und$
/* Inverse of the rijn_mix_columns_matrix: */
ss_inv_mixcolumns_matrix_2_8 : block([x], apply(matrix,
  create_list(rotate([x^3+x^2+x,x^3+x+1,x^3+x^2+1,x^3+1], i),i,0,3)))$
ss_inv_mixcolumns_std(b,e) :=
  if b = 2 then
    if e = 8 then ss_inv_mixcolumns_matrix_2_8
    else und
  else und$


/* Mixcolumn operation applied to the elements of a single
   column (given a matrix of polynomials) in the AES/Rijndael block: */
ss_mixcolumn(inputmatrixi,b,e,mod_poly,mixcolumns_matrix) :=
  matrixmap(lambda([p],ss_stand(p,b,mod_poly)),
      mixcolumns_matrix . inputmatrixi);
ss_mixcolumn_std(inputmatrix,b,e) :=
  ss_mixcolumn(inputmatrix,b,e,
    ss_polynomial_std(b,e),ss_mixcolumns_matrix_std(b,e))$

/*
   Takes a list of GF(b^e) elements (the block), and
   performs the mixcolumns operation, returning the resulting
   block as a list of GF(b^e) elements. A function specifying
   the actual operation done on a particular column must be
   provided as the second argument.
*/
ss_mixcolumns(inputmatrix,mixcolumn_f) := block([M : matrix()],
  for i : 1 thru 4 do M : addcol(M,mixcolumn_f(col(inputmatrix,i))),
  return(M))$

/* Mixcolumn operation applied to the elements of a single
   column (given a matrix) in the AES/Rijndael block: */
ss_inv_mixcolumn(inputmatrix,b,e,mod_poly,inv_mixcolumns_matrix) :=
    ss_mixcolumn(inputmatrix,b,e,mod_poly,inv_mixcolumns_matrix)$
ss_inv_mixcolumn_std(inputmatrix,b,e) :=
  ss_inv_mixcolumn(inputmatrix,b,e,
    ss_polynomial_std(b,e), ss_inv_mixcolumns_matrix_std(b,e))$

/*
   Takes a list of GF(b^e) elements (the block), and
   performs the inverse mixcolumns operation, returning the resulting
   block as a list of GF(b^e) elements. A function specifying
   the actual operation done on a particular column must be
   provided as the second argument.
*/
ss_inv_mixcolumns(inputmatrix,inv_mixcolumn_f) := 
  rijn_mixcolumns(inputmatrix,inv_mixcolumn_f)$

/*!
\endhtmlonly
*/