/* Matthew Gwynne, 6.9.2007 (Swansea) */
/* Copyright 2007, 2008 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Cryptology/Lisp/AdvancedEncryptionStandard.mac
  \brief Implementing AES and generalisations

Use by

oklib_load("Transitional/OKsystem/Transitional/ComputerAlgebra/Cryptology/AES.mac");

*/

/*!
\htmlonly
*/

/* This should be better removed and handled by oklib --maxima */
load(gf);

/* ***************************************
   * Constants                           *
   ***************************************
*/

rijndael_affine_constant : x^6 + x^5 + x + 1;
rijndael_sbox_matrix : matrix(
                        [1,1,1,1,1,0,0,0],
                        [0,1,1,1,1,1,0,0],
                        [0,0,1,1,1,1,1,0],
                        [0,0,0,1,1,1,1,1],
                        [1,0,0,0,1,1,1,1],
                        [1,1,0,0,0,1,1,1],
                        [1,1,1,0,0,0,1,1],
                        [1,1,1,1,0,0,0,1])$
rijndael_polynomial : x^8+x^4+x^3+x+1 $
rijndael_mixcolumns_matrix : matrix (
        [x, x + 1, 1, 1], 
        [1, x, x + 1, 1],
        [1, 1, x, x + 1],
        [x + 1, 1, 1, x])$
rijndael_bit_field : [2,1,[x]]$
rijndael_byte_field : [2,8,rijndael_polynomial]$
rijndael_shiftrows_shifts : [0,1,2,3]$

/* ***************************************
   * Helper Functions                    *
   ***************************************
*/

polynomial2bitvector(poly) := 
    matrix([coeff(poly, x, 7)],[coeff(poly,x, 6)],[coeff(poly, x, 5)],
           [coeff(poly, x, 4)],[coeff(poly, x, 3)],[coeff(poly, x, 2)],
           [coeff(poly, x, 1)],[coeff(poly, x,0)])$

bitvector2polynomial(byte) := 
    byte[1][1] * x^7 + byte[2][1] * x^6 + byte[3][1] * x^5 + byte[4][1] * x^4
    + byte[5][1] * x^3 + byte[6][1] * x^2 + byte[7][1] * x^1 + byte[8][1]$

/* List Processing */

/* Returns a list of n (or less if len(l) < n) elements from the beginning of l 
 */
take(l,n) := rest(l,-max(length(l)-n,0))$

/* Partitions a given list l into a list of lists of size n,
 * or less (in the case of the last element list)
 */
partition(l,n) := if emptyp(l) then [] else 
  cons(take(l,n), partition(rest(l,min(length(l),n)),n))$

/* Rotates a list n elements to the left */
rotate_left(l,n) := 
    if n <= 0 or l = [] then l
    else rotate_left(append(rest(l), [first(l)]), n-1)$

/* Takes a two parameter function f and two lists 'a' and 'b',
   and returns a list of the form [f(a[1],b[1]),...f(a[n],b[n])] where
   n is the minimum of len(a) and len(b).
   "map_rel" means "map relaxed".
 */
map_rel(f,a,b) := block([m : min(length(a),length(b))],
  if m < length(a) then a : take(a,m) elseif m < length(b) then b : take(b,m),
  map(f,a,b))$

/* Flattens a matrix or list into a list of the elements, row by row */
matrix2list(m) := apply(append, makelist(m[i],i,1,length(m)))$


/* ***************************************
   * Finite Field Wrapper Functions      *
   ***************************************
*/

/* It appears you can not overload functions with different arities
 * and so the gf_* functions have been prefixed with an 'e' for 
 * extended. These functions perform the same duty as their gf_*
 * counterparts but requ ???
 */

egf_add(field, a,b) :=  (
        gf_set(field[1],field[2],field[3]),
        gf_add(a,b)
    )$

egf_mul(field, a,b) := (
        gf_set(field[1],field[2],field[3]),
        gf_mul(a,b)
    )$

egf_matmul(field, a,b) := (
        gf_set(field[1],field[2],field[3]),
        gf_matmul(a,b)
    )$

egf_inv(field, a) := (
        gf_set(field[1],field[2],field[3]),
        gf_inv(a)
    )$


/* ***************************************
   * Main Round Functions                *
   ***************************************
*/

sbox(byte) := 
    block([invbyte,result],
    if byte = 0 then 
        rijndael_affine_constant
    else (
        invbyte : egf_inv(rijndael_byte_field,byte),
        result : egf_matmul(rijndael_bit_field,rijndael_sbox_matrix,
            polynomial2bitvector(invbyte)),
        egf_add(rijndael_byte_field, bitvector2polynomial(result),
            rijndael_affine_constant)
        )
    )$

subbytes(inputblock) := map(sbox, inputblock)$

/**
 * Takes a list of GF(2^8) elements (the block), and
 * performs the shiftrows operation, returning the resulting
 * block as a list of GF(2^8) elements.
 */
shiftrows(inputblock) := block([r],
     list_rows : partition(inputblock,4),
     matrix2list (
         create_list(rotate_left(list_rows[r+1],r), r, 
             rijndael_shiftrows_shifts))
)$

/**
 * Takes a list of GF(2^8) elements (the block), and
 * performs the mixcolumns operation, returning the resulting
 * block as a list of GF(2^8) elements.
 */
mixcolumns(inputblock) :=
    matrix2list(
        egf_matmul(rijndael_byte_field, rijndael_mixcolumns_matrix, 
            apply(matrix, partition(inputblock,4))))$

/**
 * Takes a round key matrix km for round r-1 and a round number r and produces
 * the round key matrix for round r.
 *
 * This needs reworking as it should follow the same scheme as other functions
 * to take a list and produce a list.
 */

/* ??????????????????? b,c,d are not used ??????? */
keysch(km,r) := 
    block([
        a : gf_add(km[1][1], gf_add(sbox(km[2][4]),gf_exp(x,r-1))),
        b : gf_add(km[2][1], gf_add(sbox(km[3][4]),gf_exp(x,r-1))),
        c : gf_add(km[3][1], gf_add(sbox(km[4][4]),gf_exp(x,r-1))),
        d : gf_add(km[4][1], gf_add(sbox(km[1][4]),gf_exp(x,r-1)))
          ],
        matrix(
            [a, gf_add(a,km[1][2]), gf_add(gf_add(a,km[1][2]),km[1][3]), 
                gf_add(gf_add(gf_add(a,km[1][2]),km[1][3]),km[1][4])],
            [a, gf_add(a,km[2][2]), gf_add(gf_add(a,km[2][2]),km[2][3]), 
                gf_add(gf_add(gf_add(a,km[2][2]),km[2][3]),km[2][4])],
            [a, gf_add(a,km[3][2]), gf_add(gf_add(a,km[3][2]),km[3][3]), 
                gf_add(gf_add(gf_add(a,km[3][2]),km[3][3]),km[3][4])],
            [a, gf_add(a,km[4][2]), gf_add(gf_add(a,km[4][2]),km[4][3]), 
                gf_add(gf_add(gf_add(a,km[4][2]),km[4][3]),km[4][4])] )
    )$

/* Takes the plaintext list of GF(2^8) elements and the 
 * round key for this round as a list of GF(2^8) elements and
 * returns a list of the same size of GF(2^8) elements as the plaintext
 * as the result of the round operation. 
 */
round(pl, rkl) := 
    map_rel(lambda([a,b], egf_add(rijndael_byte_field,a,b)),
        mixcolumns(shiftrows(subbytes(pl))), 
        rkl)$

/*!
\endhtmlonly
*/
