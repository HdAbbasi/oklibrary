/* Matthew Gwynne, 6.9.2007 (Swansea) */
/* Copyright 2007, 2008 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Cryptology/Lisp/AdvancedEncryptionStandard.mac
  \brief Implementing AES and generalisations

Use by

oklib_load("Transitional/OKsystem/Transitional/ComputerAlgebra/Cryptology/AES.mac");

*/

/*!
\htmlonly
*/

/* This should be better removed and handled by oklib --maxima */
load(gf);

/* ***************************************
   * Constants                           *
   ***************************************
*/

rijndael_affine_constant : x^6 + x^5 + x + 1;
rijndael_sbox_matrix : matrix(
                        [1,1,1,1,1,0,0,0],
                        [0,1,1,1,1,1,0,0],
                        [0,0,1,1,1,1,1,0],
                        [0,0,0,1,1,1,1,1],
                        [1,0,0,0,1,1,1,1],
                        [1,1,0,0,0,1,1,1],
                        [1,1,1,0,0,0,1,1],
                        [1,1,1,1,0,0,0,1])$
rijndael_polynomial : x^8+x^4+x^3+x+1 $
rijndael_mixcolumns_matrix : matrix (
        [x, x + 1, 1, 1], 
        [1, x, x + 1, 1],
        [1, 1, x, x + 1],
        [x + 1, 1, 1, x])$
rijndael_bit_field : [2,1,[x]]$
rijndael_byte_field : [2,8,rijndael_polynomial]$
rijndael_shiftrows_shifts : [0,1,2,3]$

/* ***************************************
   * Helper Functions                    *
   ***************************************
*/

polynomialToBitVector(poly) := (local(poly), 
    matrix([coeff(poly, x, 7)],[coeff(poly,x, 6)],[coeff(poly, x, 5)],
           [coeff(poly, x, 4)],[coeff(poly, x, 3)],[coeff(poly, x, 2)],
           [coeff(poly, x, 1)],[coeff(poly, x,0)]))$

bitVectorToPolynomial(byte) := (local(byte),
    (byte[1][1] * x^7 + byte[2][1] * x^6 + byte[3][1] * x^5 + byte[4][1] * x^4
    + byte[5][1] * x^3 + byte[6][1] * x^2 + byte[7][1] * x^1 + byte[8][1]))$

/* List Processing 
 * (Are there built-in versions of these or functions with similar purposes?) */

/* Returns a list of n (or less if len(l) < n) elements from the beginning of 
 * l 
 */
take(l,n) := (local(l,n),
    if (n <= 0) or (l = []) then [] else cons(first(l), take(rest(l),n - 1)))$

/* Returns the result of removing the first n elements
 * from l
 */
drop(l,n) := (local(l,n),
    if (n <= 0) or l = [] then l else drop(rest(l),n - 1))$

/* Partitions a given list l into a list of smaller lists of size n,
 * or less (in the case of the last element list)
 */
partition(l,n) := (local(l,n),
    if l = [] then [] else append([take(l,n)], partition(drop(l,n),n)))$

/* Rotates a list n elements to the left */
rotateLeft(l,n) := (local(l,n), 
    if n <= 0 or l = [] then l
    else rotateLeft(append(rest(l), [first(l)]), n-1))$

/* Flattens a matrix or list into a list of the elements, row by row */
matrixToList(m) := (local(m),
    if m = [] or m = matrix() then [] 
    else append(first(m), matrixToList(rest(m))))$

/* Takes a two parameter function f, and then two lists 'a' and 'b',
 * and returns a list of the form [f(a[1],b[1]),...f(a[n],b[n])] where
 * n is the minimum of len(a) and len(b).
 */
zipWith(f,a,b) := (local(f,a,b),
    if a = [] or b = [] then []
    else cons(f(first(a),first(b)), zipWith(f, rest(a), rest(b)))
)$

/* ***************************************
   * Finite Field Wrapper Functions      *
   ***************************************
*/

/* It appears you can not overload functions with different arities
 * and so the gf_* functions have been prefixed with an 'e' for 
 * extended. These functions perform the same duty as their gf_*
 * counterparts but requ
 */

egf_add(field, a,b) := (local(field,a,b),
    block(
        gf_set(field[1],field[2],field[3]),
        gf_add(a,b)
    ))$

egf_mul(field, a,b) := (local(field,a,b),
    block(
        gf_set(field[1],field[2],field[3]),
        gf_mul(a,b)
    ))$

egf_matmul(field, a,b) := (local(field,a,b),
    block(
        gf_set(field[1],field[2],field[3]),
        gf_matmul(a,b)
    ))$

egf_inv(field, a) := (local(field,a),
    block(
        gf_set(field[1],field[2],field[3]),
        gf_inv(a)
    ))$


/* ***************************************
   * Main Round Functions                *
   ***************************************
*/

sbox(byte) := 
    (local(byte,invByte,result),
    if byte = 0 then 
        rijndael_affine_constant
    else 
        block(
            invByte : egf_inv(rijndael_byte_field,byte),
            result : egf_matmul(rijndael_bit_field,rijndael_sbox_matrix,
                polynomialToBitVector(invByte)),
            egf_add(rijndael_byte_field, bitVectorToPolynomial(result),
                rijndael_affine_constant)
        )
    )$

subBytes(inputBlock) := (local(inputBlock), map(sbox, inputBlock))$

/**
 * Takes a list of GF(2^8) elements (the block), and
 * performs the shiftrows operation, returning the resulting
 * block as a list of GF(2^8) elements.
 */
shiftRows(inputBlock) := (local(inputBlock,r),
    block(
        listOfRows : partition(inputBlock,4),
        matrixToList (
            create_list(rotateLeft(listOfRows[r+1],r), r, 
                rijndael_shiftrows_shifts))
    ))$

/**
 * Takes a list of GF(2^8) elements (the block), and
 * performs the mixcolumns operation, returning the resulting
 * block as a list of GF(2^8) elements.
 */
mixColumns(inputBlock) := (local(inputBlock),
    matrixToList(
        egf_matmul(rijndael_byte_field, rijndael_mixcolumns_matrix, 
            apply(matrix, partition(inputBlock,4)))))$

/**
 * Takes a round key matrix km for round r-1 and a round number r and produces
 * the round key matrix for round r.
 *
 * This needs reworking as it should follow the same scheme as other functions
 * to take a list and produce a list.
 */
keysch(km,r) := (local(km,r),
    block (
        a : gf_add(km[1][1], gf_add(sbox(km[2][4]),gf_exp(x,r-1))),
        b : gf_add(km[2][1], gf_add(sbox(km[3][4]),gf_exp(x,r-1))),
        c : gf_add(km[3][1], gf_add(sbox(km[4][4]),gf_exp(x,r-1))),
        d : gf_add(km[4][1], gf_add(sbox(km[1][4]),gf_exp(x,r-1))),
        matrix(
            [a, gf_add(a,km[1][2]), gf_add(gf_add(a,km[1][2]),km[1][3]), 
                gf_add(gf_add(gf_add(a,km[1][2]),km[1][3]),km[1][4])],
            [a, gf_add(a,km[2][2]), gf_add(gf_add(a,km[2][2]),km[2][3]), 
                gf_add(gf_add(gf_add(a,km[2][2]),km[2][3]),km[2][4])],
            [a, gf_add(a,km[3][2]), gf_add(gf_add(a,km[3][2]),km[3][3]), 
                gf_add(gf_add(gf_add(a,km[3][2]),km[3][3]),km[3][4])],
            [a, gf_add(a,km[4][2]), gf_add(gf_add(a,km[4][2]),km[4][3]), 
                gf_add(gf_add(gf_add(a,km[4][2]),km[4][3]),km[4][4])] )
    )
)$

/* Takes the plaintext list of GF(2^8) elements and the 
 * round key for this round as a list of GF(2^8) elements and
 * returns a list of the same size of GF(2^8) elements as the plaintext
 * as the result of the round operation. 
 */
round(pl, rkl) := (local(pl,rkl), 
    zipWith(lambda([a,b], egf_add(rijndael_byte_field,a,b)),
        mixColumns(shiftRows(subBytes(pl))), 
        rkl )
)$

/*!
\endhtmlonly
*/
