/* Matthew Gwynne, 26.3.2008 (Swansea) */
/* Copyright 2008, 2009, 2010, 2011 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/Translations.mac
  \brief Cryptanalysis functions for translations of Rijndael into active clauses etc

Use by

oklib_load("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/Translations.mac");
  
*/

/*!
\htmlonly
*/

oklib_include("OKlib/ComputerAlgebra/DataStructures/Lisp/Lists.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/CryptoSystems/Rijndael/AdvancedEncryptionStandard.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/SboxAnalysis.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/FieldOperationsAnalysis.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/data/FieldMul2CNF.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/data/FieldMul3CNF.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/data/FieldMul11CNF.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/data/FieldMul13CNF.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/data/FieldMul14CNF.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/data/FieldMul9CNF.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/data/SboxCNF.mac")$
oklib_include("OKlib/ComputerAlgebra/Satisfiability/Lisp/FiniteFunctions/TseitinTranslation.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/ConstraintTemplateGlobalPropagation.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/ConstraintTemplateRewriteSystem.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/ConstraintTemplateSmallScaleRewriteRules.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/ConstraintTemplateTranslation.mac")$

/* TODO: Add documentation at this level. */

/* ***************************************
   * Sets of Conditions                  *
   ***************************************
*/


/* Generates (and caches) the canonical CNF representation as a formal clause
   set of AES Field muliplication (within the Rijndael GF(2^8) field) by p 
   (given as an integer) with new variables. 
   
   New variables are introduced for each clause in the canonical DNF 
   representation (see dualts_fcl), where the variables are of the form dts(i)
   and i is the rank in the lexiographical ordering of the clauses.

   Caching here simply means that upon the first call to the function with
   argument "p", the result of the computation for that argument is stored 
   in a global variable "aes_mul_ts_CNF[p]" which will then be returned 
   immediately on subsequent calls to "aes_mul_ts_gen" with the same argument 
   to allow for reuse of "aes_mul_ts_gen" without the overhead of 
   recomputation.
 */
aes_mul_ts_CNF : create_list(false,i,1,256)$
aes_mul_ts_gen(p) := 
  if aes_mul_ts_CNF[p+1] = false then block([plus16 : lambda([x],x+16)],
      [mul_dnf : rijnmult_fulldnf_fcs(p)],
    aes_mul_ts_CNF[p+1] : dualts_fcl(
      [listify(mul_dnf[1]),
       sort(
         listify(mul_dnf[2]),
         lambda([a,b], is(
           rank_lex_ksubsets(map(plus16,a),32) < 
             rank_lex_ksubsets(map(plus16,b),32)))
        )]
     ),
     return(aes_mul_ts_CNF[p+1])
  ) else aes_mul_ts_CNF[p+1]$

/* Generates (and caches) the canonical CNF representation as a formal clause
   set of AES Sbox operator with new variables. New variables are 
   introduced for each clause in the canonical DNF representation (see
   dualts_fcl), where the new variables are of the form dts(i) and i is the 
   rank in the lexiographical ordering of the clauses.

   Caching here simply means that upon the first call to the function, the 
   result of the computation is stored in a global variable "aes_sbox_ts_CNF"
   which will then be returned immediately on subsequent calls to
   "aes_sbox_ts_gen" to allow for reuse of "aes_sbox_ts_gen" without the
   overhead of recomputation.
 */
aes_sbox_ts_CNF : false;
aes_sbox_ts_gen() := 
  if aes_sbox_ts_CNF = false then block([plus16 : lambda([x],x+16)],
      [sbox_dnf : rijnsbox_fulldnf_fcs()],
    aes_sbox_ts_CNF : dualts_fcl(
      [listify(sbox_dnf[1]),
       sort(
         listify(sbox_dnf[2]),
         lambda([a,b], is(
           rank_lex_ksubsets(map(plus16,a),32) < 
             rank_lex_ksubsets(map(plus16,b),32)))
        )]
     ), 
     return(aes_sbox_ts_CNF)
  ) else aes_sbox_ts_CNF$


/*************************************************************
 * Constraint template rewrite-based translations            *
 *************************************************************
*/

oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/ConstraintTemplateRewriteRules.mac");
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/ConstraintTemplateRewriteSystem.mac");


/* AES */

/* AES Translations

         Boxes -
             For each box we have the following translation

             aes_small_box - Each box is represented by the smallest known cnf
             aes_ts_box    - Each box is represented by the canonical
                             translation using new variables.
             aes_rbase_box - Each box is represented by a CNF which is
                             an r_1 base.

         MixColumns -
             For the translation of the MixColumns component, we may either
             add additional constraints translating the inversion as well
             or simply translate the component in the forward direction.

             aes_mc_forward
             aes_mc_bidirectional

*/

declare(aes_small_box, noun)$
declare(aes_ts_box, noun)$
declare(aes_rbase_box, noun)$
declare(aes_mc_forward, noun)$
declare(aes_mc_bidirectional, noun)$


/* Constraint rewrite translations */

/* Given the number of rounds, produces a list of constraint templates
   which model AES using standard parameters. */
/* TODO: Add the full version that allows all parameters */
aes_csttl(r, mc_tran) :=
  rewrite_all_csttl(
    [cstt_new("aes_cst",
              generate_aes_constraint_vars(1,3*128,lambda([a],a),"aes_cst"),
              [r],lambda([a],a))],
    if mc_tran = aes_mc_bidirectional then aes_bimc_rewrite_mapping_std
    else aes_rewrite_mapping_std)$
aes_cstt_std_l(r) := aes_csttl(r, aes_mc_forward)$


aes_cstt_vars_l(r, mc_tran) :=
  append(
    generate_aes_constraint_vars(1,3*128,lambda([a],a),"aes_cst"),
    rewrite_all_cstt_vars_l(
      [cstt_new("aes_cst",
        generate_aes_constraint_vars(1,3*128,lambda([a],a),"aes_cst"),
        [r],lambda([a],a))],
      if mc_tran = aes_mc_bidirectional then aes_bimc_rewrite_mapping_std
      else aes_rewrite_mapping_std))$
aes_cstt_vars_std_l(r) := aes_cstt_vars_l(r,aes_mc_forward)$


aes_fcl(r, box_tran, mc_tran) := block(
  [aes_csttl : aes_csttl(r,mc_tran),aes_vars_l, prop_csttl],
  aes_vars_l : aes_cstt_vars_l(r,mc_tran),
  prop_csttl : prop_all_csttl(aes_csttl, aes_vars_l, aes_propagations),
  csttl2fcl(prop_csttl[1],prop_csttl[2],
    if box_tran = aes_small_box then
      aes_pi_translation_mapping
    else
      aes_ts_translation_mapping))$

aes_std_fcl(r) := aes_fcl(r, aes_small_box, aes_ts_box)$

/* Small Scale AES */

ss_csttl(r,ss_num_columns, ss_num_rows, ss_exp, final_round_b, mc_tran) :=
  block([num_block_bits : ss_num_columns * ss_num_rows * ss_exp],
    rewrite_all_csttl(
      [cstt_new("ss_cst",
        generate_aes_constraint_vars(1,3*num_block_bits,
          lambda([a],a),"ss_cst"),
          [r,ss_num_columns, ss_num_rows,2, ss_exp,
           ss_polynomial(2,ss_exp),ss_sbox_matrix(2,ss_exp),
           ss_affine_constant(2,ss_exp),
           ss_mixcolumns_matrix(2,ss_exp,ss_num_rows),final_round_b],
           lambda([a],a))],
    if mc_tran = aes_mc_bidirectional then ss_bimc_rewrite_mapping_std
    else ss_rewrite_mapping_std))$
/*aes_cstt_std_l(r) := aes_csttl(r, aes_mc_forward)$*/

ss_cstt_vars_l(r, ss_num_columns, ss_num_rows, ss_exp, final_round_b, mc_tran) :=
  append(
    generate_aes_constraint_vars(1,3*(ss_num_columns*ss_num_rows*ss_exp),
        lambda([a],a),"ss_cst"),
    rewrite_all_cstt_vars_l(
      [cstt_new("ss_cst",
        generate_aes_constraint_vars(1,3*(ss_num_columns*ss_num_rows*ss_exp),
          lambda([a],a),"ss_cst"),
        [r,ss_num_columns, ss_num_rows,2, ss_exp,
           ss_polynomial(2,ss_exp),ss_sbox_matrix(2,ss_exp),
           ss_affine_constant(2,ss_exp),
           ss_mixcolumns_matrix(2,ss_exp,ss_num_rows),final_round_b],
           lambda([a],a))],
      if mc_tran = aes_mc_bidirectional then ss_bimc_rewrite_mapping_std
      else ss_rewrite_mapping_std))$

ss_fcl(r, ss_num_columns, ss_num_rows, ss_exp, final_round_b, box_tran, mc_tran) := block(
  [ss_csttl : ss_csttl(r,ss_num_columns, ss_num_rows, ss_exp, final_round_b,mc_tran),
  ss_vars_l, prop_csttl],
  ss_vars_l : ss_cstt_vars_l(r,ss_num_columns,
      ss_num_rows, ss_exp, final_round_b,mc_tran),
  prop_csttl : prop_all_csttl(ss_csttl, ss_vars_l, ss_propagations),
  csttl2fcl(prop_csttl[1],prop_csttl[2],
    if box_tran = aes_small_box then
      ss_pi_translation_mapping
    else if box_tran = aes_rbase_box then
      ss_rbase_translation_mapping
    else
      ss_ts_translation_mapping))$


output_ss_fcl(n,r, ss_num_columns, ss_num_rows, ss_exp, final_round_b, box_tran, mc_tran) :=
  block([FF, FF_std],
    if oklib_monitor then print("Starting translation..."),
    FF : ss_fcl(r, ss_num_columns, ss_num_rows, ss_exp, final_round_b, box_tran, mc_tran),
    if oklib_monitor then print("Starting standardisation..."),
    FF_std : standardise_fcl(FF),
    if oklib_monitor then print("Starting output..."),
    output_fcl_v(sconcat("Small Scale AES with ",
                   "r=",r,",c=",ss_num_columns,",rw=",ss_num_rows,
                   ",e=",ss_exp,",final=",final_round_b,
                   ",box_tran=",box_tran,",mc_tran=",mc_tran),
                 FF_std[1],n,
      FF_std[2]))$
  
output_ss_fcl_std(r, ss_num_columns, ss_num_rows, ss_exp, final_round_b, box_tran, mc_tran) :=
  output_ss_fcl(
    sconcat("ssaes_r", r, "_c",ss_num_columns, "_rw",ss_num_rows,"_e",ss_exp,
      "_f",if final_round_b then 1 else 0, ".cnf"),
    r, ss_num_columns, ss_num_rows, ss_exp, final_round_b, box_tran, mc_tran)$
    

ss_trans_fcl(cst, box_tran, mc_tran) := block(
  [ss_csttl : rewrite_all_csttl([cst],ss_rewrite_mapping_std),
  ss_vars_l, prop_csttl],
  ss_vars_l : append(cstt_vars_l(cst),rewrite_all_cstt_vars_l([cst], ss_rewrite_mapping_std)),
  prop_csttl : prop_all_csttl(ss_csttl, ss_vars_l, ss_propagations),
  csttl2fcl(prop_csttl[1],prop_csttl[2],
    if box_tran = aes_small_box then
      ss_pi_translation_mapping
    else
      ss_ts_translation_mapping))$


/* Takes a partial assignment, along with small scale parameters
   and returns true if the partial assignment represents a valid
   small scale encryption using those parameters. */
ss_validate(pa, r, ss_num_columns, ss_num_rows, ss_exp, final_round_b) :=
block([block_size],
  block_size : ss_num_columns * ss_num_rows * ss_exp,
  P : ss_pa2matrix(pa, create_list(i,i,1,block_size),
    2, ss_exp, ss_polynomial(2,ss_exp), ss_num_rows),
  K : ss_pa2matrix(pa, create_list(i,i,block_size+1,2*block_size),
    2, ss_exp, ss_polynomial(2,ss_exp), ss_num_rows),
  C : ss_pa2matrix(pa, create_list(i,i,2*block_size+1,3*block_size),
    2, ss_exp, ss_polynomial(2,ss_exp), ss_num_rows),
  return(
    is(ss_encrypt(P,K,r,2,ss_exp) = C))
)$

/******************************************************************
 * Statistics                                                     *
 ******************************************************************
*/

/* Given the appropriate parameters, computes the number of sboxes
   in the associated small scale AES. The parameters are the number
   of rounds, and the number of columns and rows in the block. */
nsbox_ss(r,num_columns,num_rows) :=
  (r*num_columns*num_rows) + (r * num_rows)$

/* Given the appropriate parameters, computes the number of multiplications
   by the finite field element e (given as a polynomial) in the associated
   small scale AES. The parameters are the field element, given as a
   polynomial, number of rounds, and the number of columns, the small scale
   exponent, the mixcolumns matrix, whether or not to use a special final
   round (true/false) and the MixColumns translation to use (aes_mc_forward or
   aes_mc_bidirectional). */
nmul_ss(e,r,num_cols,ss_exp,mixcolumns_matrix, final_round_b, mc_trans) :=
block([inv_mixcolumns_matrix, nmul, nmul_inv],
  inv_mixcolumns_matrix :
    ss_mixcolumns_matrix2inv_mixcolumns_matrix(2,ss_exp,mixcolumns_matrix),
  nmul : length(sublist(m2l_r(mixcolumns_matrix), lambda([a],is(a=e)))),
  if mc_trans = aes_mc_bidirectional then
    nmul_inv :
      length(sublist(m2l_r(inv_mixcolumns_matrix), lambda([a],is(a=e))))
  else nmul_inv : 0,
  if final_round_b then r : r -1,
  return(r * (nmul + nmul_inv) * num_cols))$

/* Given the appropriate parameters, computes the number of variables
   in the small scale AES clause-list translation.

   The parameters are the number of rounds, the number of columns, the small
   scale exponent, the mixcolumns matrix to use, the number of variables
   introduced by the sbox CNF translation, a list-map from the field elements
   in the mixcolumns to the number of variables introduced in the CNF
   translation of each multiplication, whether or not to use a special
   final round, and whether to include the MixColumns inversion or not
   (aes_mc_forward vs aes_mc_bidirectional). */
nvar_ss(r,num_cols,num_rows,ss_exp,mixcolumns_matrix,
            num_sbox_vars,num_mul_vars_map,final_round_b,mc_trans) :=
block([mul_h : osm2hm(num_mul_vars_map), block_size],
  block_size : num_cols * num_rows * ss_exp,
  if final_round_b then
    return(
      (block_size * 3) + /* Input */
      (2 * r * block_size) + /* AES constraint (round keys + output) */
      ((r-1) * 2 * block_size) + /* Normal rounds */
      block_size + /* Normal rounds */
      (r * num_cols * num_rows * num_sbox_vars) + /* Subbytes - sboxes */
      sum_l(map(lambda([e],ev_hm_d(mul_h,e,0) +
            if e # 0 and e # 1 then ss_exp else 0),
          m2l_r(mixcolumns_matrix))) * num_cols * (r-1) +
      /* MixColumns - forward */
      (if mc_trans = aes_mc_bidirectional then
        sum_l(map(lambda([e],ev_hm_d(mul_h,e,0) +
              if e # 0 and e # 1 then ss_exp else 0),
            m2l_r(ss_mixcolumns_matrix2inv_mixcolumns_matrix(
                2,ss_exp,mixcolumns_matrix)))) else 0) * num_cols * (r-1) +
      /* MixColumns - inv */
      ((ss_exp * r) + (num_rows * r * (ss_exp + num_sbox_vars)))
      /* Key Schedule */)
  else
    return(
      (block_size * 3) + /* Input */
      (2 * r * block_size) + /* AES constraint (round keys + output) */
      (2 * r * block_size) + /* Normal rounds */
      (r * num_cols * num_rows * num_sbox_vars) + /* Subbytes - sboxes */
      sum_l(map(lambda([e],ev_hm_d(mul_h,e,0) +
            if e # 0 and e # 1 then ss_exp else 0),
          m2l_r(mixcolumns_matrix))) * num_cols * r +
      /* MixColumns - forward */
      (if mc_trans = aes_mc_bidirectional then
        sum_l(map(lambda([e],ev_hm_d(mul_h,e,0) +
              if e # 0 and e # 1 then ss_exp else 0),
            m2l_r(ss_mixcolumns_matrix2inv_mixcolumns_matrix(
                2,ss_exp,mixcolumns_matrix)))) else 0) * num_cols * r +
      /* MixColumns - inv */
      ((ss_exp * r) + (num_rows * r * (ss_exp + num_sbox_vars)))
      /* Key Schedule */))$

/* Given the appropriate parameters, computes the number of clauses
   in the small scale AES clause-list translation.

   The parameters are the number of rounds, the number of columns, the small
   scale exponent, the mixcolumns matrix to use, the number of variables
   introduced by the sbox CNF translation, a list-map from the field elements
   in the mixcolumns to the number of variables introduced in the CNF
   translation of each multiplication, whether or not to use a special
   final round, and whether to include the MixColumns inversion or not
   (aes_mc_forward vs aes_mc_bidirectional). */
ncl_ss(r,num_cols,num_rows,ss_exp,mixcolumns_matrix,
            num_sbox_cl,num_mul_cl_map,final_round_b,mc_trans) :=
block([mul_h : osm2hm(num_mul_cl_map), block_size],
  block_size : num_cols * num_rows * ss_exp,
  if final_round_b then
    return(
      4 * block_size * (r+1) + /* Addition constraints (binary) */
      (r * num_cols * num_rows * num_sbox_cl) + /* Subbytes - sboxes */
      sum_l(map(lambda([e],ev_hm_d(mul_h,e,0)),
          m2l_r(mixcolumns_matrix))) * num_cols * (r-1) +
      sum_l(map(lambda([R], 2^length(sublist(R,lambda([e],is(e#0))))),
        args(mixcolumns_matrix))) * ss_exp * num_cols * (r-1) +
      /* MixColumns - forward */
      (if mc_trans = aes_mc_bidirectional then
        sum_l(map(lambda([e],ev_hm_d(mul_h,e,0)),
            m2l_r(ss_mixcolumns_matrix2inv_mixcolumns_matrix(
                2,ss_exp,mixcolumns_matrix)))) else 0) * num_cols * (r-1) +
      (if mc_trans = aes_mc_bidirectional then
        sum_l(map(lambda([R], 2^length(sublist(R,lambda([e],is(e#0))))),
          args(ss_mixcolumns_matrix2inv_mixcolumns_matrix(
                2,ss_exp,mixcolumns_matrix)))) else 0) * ss_exp * num_cols * (r-1) +
      /* MixColumns - inv */
      ((ss_exp * r) + (num_rows * r * num_sbox_cl)) +
      if num_cols > 1 then
        ((num_rows * (num_cols-1) * 4) + ((num_rows-1) * 4) + 8) * ss_exp * r
      else
        ((num_cols-1) * num_rows + 1) * 4 * ss_exp * r
      /* Key Schedule */)
  else
    return(
      4 * block_size * (r+1) + /* Addition constraints (binary) */
      (r * num_cols * num_rows * num_sbox_cl) + /* Subbytes - sboxes */
      sum_l(map(lambda([e],ev_hm_d(mul_h,e,0)),
          m2l_r(mixcolumns_matrix))) * num_cols * r +
      sum_l(map(lambda([R], 2^length(sublist(R,lambda([e],is(e#0))))),
        args(mixcolumns_matrix))) * ss_exp * num_cols * r +
      /* MixColumns - forward */
      (if mc_trans = aes_mc_bidirectional then
        sum_l(map(lambda([e],ev_hm_d(mul_h,e,0)),
            m2l_r(ss_mixcolumns_matrix2inv_mixcolumns_matrix(
                2,ss_exp,mixcolumns_matrix)))) else 0) * num_cols * r +
      (if mc_trans = aes_mc_bidirectional then
        sum_l(map(lambda([R], 2^length(sublist(R,lambda([e],is(e#0))))),
          args(ss_mixcolumns_matrix2inv_mixcolumns_matrix(
                2,ss_exp,mixcolumns_matrix)))) else 0) * ss_exp * num_cols * r +
      /* MixColumns - inv */
      ((ss_exp * r) + (num_rows * r * num_sbox_cl)) +
      if num_cols > 1 then
        ((num_rows * (num_cols-1) * 4) + ((num_rows-1) * 4) + 8) * ss_exp * r
      else
        ((num_cols-1) * num_rows + 1) * 4 * ss_exp * r
      /* Key Schedule */))$

  
/******************************************************************
 * Data translation                                               *
 ******************************************************************
*/

/* AES data translation */

/* TODO: Move such constants to constants (i.e. AES row size, column size etc). */

output_aes_random_pc_pair(seed, num_rounds) :=
 /* Constants: AES uses the GF(2^8) field and has 4 columns and 4 rows.  */
 output_ss_random_pc_pair(seed, 2,8, ss_polynomial_2_8, 4, 4, num_rounds)$


/* Takes a hexidecimal string in the notation typically used for Rijndael blocks
   (discussed in [Design of Rijndael] and in CryptoSystems plans) and given the
   variable list (assumed to be in the correct left to right bit ordering)
   generates a PA to the given variables to the given constant.  */
aes_hex2pa(hexStr, variableList) := block(
  setify(map(
    lambda([a,b], if b = 0 then -a else a),
        variableList, 
        lappend(map(lambda([a], 
          egf_coeffs(rijn_bit_field,a,7)),hex2gf2t8l(hexStr)))
  ))
)$

/* Small scale data translation */

ss_random_matrix(b,e,mod_poly, num_rows, num_cols) :=
    genmatrix(lambda([x,y], ss_stand(nat2poly(random(b^e),b),b,mod_poly)),
      num_rows, num_cols)$

ss_matrix2pa(m,var_list,b,e,mod_poly) := block([nl, bits],
  nl : ss_m2natl(m,b),
  bits : lappend(map(lambda([a],int2polyadic_padd(a,b,e)), nl)),
  return(
    map(lambda([bit_,var_], if bit_ > 0 then var_ else -var_), bits,var_list))
  )$

/* Assumes all of var_list occur as vars in lit_set in some form */
ss_pa2matrix(lit_set, var_list,b,e,mod_poly, num_rows) := block([nl, bits],
  bits : map(lambda([a], if member(a,lit_set) then 1 else 0), var_list),
  nl : map(lambda([a], polyadic2int(a,b)),partition_elements(bits,e)),
  return(ss_natl2m(nl,b,num_rows)))$

ss_pa2matrix_std(lit_set, e,num_rows, num_cols) :=
  ss_pa2matrix(lit_set,
    create_list(i,i,e*num_rows*num_cols+1,2*e*num_rows*num_cols),
    2,e,ss_polynomial(2,e),num_rows)$

/* Outputs random plaintext, ciphertext pair as a clause-set with
   the associated unit clauses, given the small scale parameters. */
output_ss_random_pc_pair(seed, num_rounds, num_cols, num_rows,ss_exp, final_round_b) :=
  block(
    [s, plaintext, key, ciphertext, comment, filename, plaintext_vars,
     ciphertext_vars, pc_phi, pc_unit_fcs, b : 2,
     mod_poly : ss_polynomial(2,ss_exp)],
    s : make_random_state(seed),
    set_random_state(s),
    plaintext : ss_random_matrix(b,ss_exp,mod_poly,num_rows,num_cols),
    key : ss_random_matrix(b,ss_exp,mod_poly,num_rows, num_cols),
    if final_round_b then
      ciphertext : ss_encrypt_wf(plaintext, key, num_rounds, b,ss_exp)
    else
      ciphertext : ss_encrypt(plaintext, key, num_rounds, b,ss_exp),
    comment : sconcat(
      "S : ", seed, " ",
      "P : ", ss_matrix2hex(plaintext, b,ss_exp,mod_poly), " ",
      "K : ", ss_matrix2hex(key, b,ss_exp,mod_poly)," ",
      "C : ", ss_matrix2hex(ciphertext, b,ss_exp,mod_poly), " ",
      "A : ", [b,ss_exp,mod_poly,num_rows,num_cols, num_rounds]),
    filename : sconcat(
      "ssaes_pcpair_r", num_rounds , "_c", num_cols, "_rw", num_rows, "_e",
      ss_exp,"_f", if final_round_b then 1 else 0,"_s", seed, ".cnf"),
    plaintext_vars : create_list(i,i,1, ss_exp * num_rows * num_cols),
    ciphertext_vars : create_list(i,i,
      2*ss_exp * num_rows * num_cols+1, 3*ss_exp * num_rows * num_cols),
    pc_phi : append(
      ss_matrix2pa(plaintext, plaintext_vars, b, ss_exp, mod_poly),
      ss_matrix2pa(ciphertext, ciphertext_vars, b, ss_exp, mod_poly)),
    pc_unit_fcs : cs2fcs(setify(map(set, pc_phi))),
    output_fcs(comment, pc_unit_fcs, filename))$
output_ss_random_pk_pair(seed, num_rounds, num_cols, num_rows,ss_exp, final_round_b) :=
  block(
    [s, plaintext, key, ciphertext, comment, filename, plaintext_vars,
     ciphertext_vars, pc_phi, pc_unit_fcs, b : 2,
     mod_poly : ss_polynomial(2,ss_exp)],
    s : make_random_state(seed),
    set_random_state(s),
    plaintext : ss_random_matrix(b,ss_exp,mod_poly,num_rows,num_cols),
    key : ss_random_matrix(b,ss_exp,mod_poly,num_rows, num_cols),
    if final_round_b then
      ciphertext : ss_encrypt_wf(plaintext, key, num_rounds, b,ss_exp)
    else
      ciphertext : ss_encrypt(plaintext, key, num_rounds, b,ss_exp),
    comment : sconcat(
      "S : ", seed, " ",
      "P : ", ss_matrix2hex(plaintext, b,ss_exp,mod_poly), " ",
      "K : ", ss_matrix2hex(key, b,ss_exp,mod_poly)," ",
      "C : ", ss_matrix2hex(ciphertext, b,ss_exp,mod_poly), " ",
      "A : ", [b,ss_exp,mod_poly,num_rows,num_cols, num_rounds]),
    filename : sconcat(
      "ssaes_pkpair_r", num_rounds , "_c", num_cols, "_rw", num_rows, "_e",
      ss_exp,"_f", if final_round_b then 1 else 0,"_s", seed, ".cnf"),
    plaintext_vars : create_list(i,i,1, ss_exp * num_rows * num_cols),
    key_vars : create_list(i,i,
      ss_exp * num_rows * num_cols+1, 2*ss_exp * num_rows * num_cols),
    pc_phi : append(
      ss_matrix2pa(plaintext, plaintext_vars, b, ss_exp, mod_poly),
      ss_matrix2pa(key, key_vars, b, ss_exp, mod_poly)),
    pc_unit_fcs : cs2fcs(setify(map(set, pc_phi))),
    output_fcs(comment, pc_unit_fcs, filename))$
output_ss_random_kc_pair(seed, num_rounds, num_cols, num_rows,ss_exp, final_round_b) :=
  block(
    [s, plaintext, key, ciphertext, comment, filename, plaintext_vars,
     ciphertext_vars, pc_phi, pc_unit_fcs, b : 2,
     mod_poly : ss_polynomial(2,ss_exp)],
    s : make_random_state(seed),
    set_random_state(s),
    plaintext : ss_random_matrix(b,ss_exp,mod_poly,num_rows,num_cols),
    key : ss_random_matrix(b,ss_exp,mod_poly,num_rows, num_cols),
    if final_round_b then
      ciphertext : ss_encrypt_wf(plaintext, key, num_rounds, b,ss_exp)
    else
      ciphertext : ss_encrypt(plaintext, key, num_rounds, b,ss_exp),
    comment : sconcat(
      "S : ", seed, " ",
      "P : ", ss_matrix2hex(plaintext, b,ss_exp,mod_poly), " ",
      "K : ", ss_matrix2hex(key, b,ss_exp,mod_poly)," ",
      "C : ", ss_matrix2hex(ciphertext, b,ss_exp,mod_poly), " ",
      "A : ", [b,ss_exp,mod_poly,num_rows,num_cols, num_rounds]),
    filename : sconcat(
      "ssaes_kcpair_r", num_rounds , "_c", num_cols, "_rw", num_rows, "_e",
      ss_exp,"_f", if final_round_b then 1 else 0,"_s", seed, ".cnf"),
    ciphertext_vars : create_list(i,i,
      2*ss_exp * num_rows * num_cols+1, 3*ss_exp * num_rows * num_cols),
    key_vars : create_list(i,i,
      ss_exp * num_rows * num_cols+1, 2*ss_exp * num_rows * num_cols),
    pc_phi : append(
      ss_matrix2pa(plaintext, key_vars, b, ss_exp, mod_poly),
      ss_matrix2pa(key, ciphertext_vars, b, ss_exp, mod_poly)),
    pc_unit_fcs : cs2fcs(setify(map(set, pc_phi))),
    output_fcs(comment, pc_unit_fcs, filename))$


/******************************************************************************
 * Global propagation                                                         *
 ******************************************************************************
*/

aes_propagations : [prop_eq_csttl]$
ss_propagations : [prop_eq_csttl]$


/******************************************************************************
 * CNF translations                                                           *
 ******************************************************************************
*/

/* AES */

/* Translation mapping, mapping constraint templates to the corresponding
   translation functions where constraints are translated to CNF clause-set
   representations using subsets of the prime implicates: */
aes_pi_translation_mapping : [
  ["aes_add_cst", [aes_add_cst_cl, lambda([[a]],[])]],
  ["const_cst", [aes_const_cst_cl, lambda([[a]],[])]],
  ["aes_mul2_cst", [aes_mul2_pi_cst_cl, lambda([[a]],[])]],
  ["aes_mul3_cst", [aes_mul3_pi_cst_cl, lambda([[a]],[])]],
  ["aes_mul14_cst", [aes_mul14_pi_cst_cl, lambda([[a]],[])]],
  ["aes_mul13_cst", [aes_mul13_pi_cst_cl, lambda([[a]],[])]],
  ["aes_mul11_cst", [aes_mul11_pi_cst_cl, lambda([[a]],[])]],
  ["aes_mul9_cst", [aes_mul9_pi_cst_cl, lambda([[a]],[])]],
  ["aes_sbox_cst", [aes_sbox_pi_cst_cl, lambda([[a]],[])]]]$

/* Translation mapping, mapping constraint templates to the corresponding
   translation functions where constraints are translated to representations
   using subsets of the prime implicates: */
aes_ts_translation_mapping : [
  ["aes_add_cst", [aes_add_cst_cl, lambda([[a]],[])]],
  ["const_cst", [aes_const_cst_cl, lambda([[a]],[])]],
  ["aes_mul2_cst", [aes_mul2_ts_cst_cl, aes_mul2_ts_var_l]],
  ["aes_mul3_cst", [aes_mul3_ts_cst_cl, aes_mul3_ts_var_l]],
  ["aes_mul14_cst", [aes_mul14_ts_cst_cl, aes_mul14_ts_var_l]],
  ["aes_mul13_cst", [aes_mul13_ts_cst_cl, aes_mul13_ts_var_l]],
  ["aes_mul11_cst", [aes_mul11_ts_cst_cl, aes_mul11_ts_var_l]],
  ["aes_mul9_cst", [aes_mul9_ts_cst_cl, aes_mul9_ts_var_l]],
  ["aes_sbox_cst", [aes_sbox_ts_cst_cl, aes_sbox_ts_var_l]]]$

/* Small Scale */

/* Translation mapping, mapping constraint templates to the corresponding
   translation functions where constraints are translated to CNF clause-set
   representations using subsets of the prime implicates: */
ss_pi_translation_mapping : [
  ["ss_add_cst", [aes_add_cst_cl, lambda([[a]],[])]],
  ["const_cst", [aes_const_cst_cl, lambda([[a]],[])]],
  ["ss_mul_cst", [ss_mul_pi_cst_cl, lambda([[a]],[])]],
  ["ss_sbox_cst", [ss_sbox_pi_cst_cl, lambda([[a]],[])]]]$

/* Translation mapping, mapping constraint templates to the corresponding
   translation functions where constraints are translated to CNF clause-set
   representations using r_1 bases: */
ss_rbase_translation_mapping : [
  ["ss_add_cst", [aes_add_cst_cl, lambda([[a]],[])]],
  ["const_cst", [aes_const_cst_cl, lambda([[a]],[])]],
  ["ss_mul_cst", [ss_mul_rbase_cst_cl, lambda([[a]],[])]],
  ["ss_sbox_cst", [ss_sbox_rbase_cst_cl, lambda([[a]],[])]]]$

/* Translation mapping, mapping constraint templates to the corresponding
   translation functions where constraints are translated to representations
   using subsets of the prime implicates: */
ss_ts_translation_mapping : [
  ["ss_add_cst", [aes_add_cst_cl, lambda([[a]],[])]],
  ["const_cst", [aes_const_cst_cl, lambda([[a]],[])]],
  ["ss_mul_cst", [ss_mul_ts_cst_cl, ss_mul_ts_var_l]],
  ["ss_sbox_cst", [ss_sbox_ts_cst_cl, ss_sbox_ts_var_l]]]$

/*!
\endhtmlonly
*/
