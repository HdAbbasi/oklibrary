/* Matthew Gwynne, 26.3.2008 (Swansea) */
/* Copyright 2008 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/Translations.mac
  \brief Cryptanalysis functions for translations of Rijndael into active clauses etc

Use by

oklib_load("Transitional/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/Translations.mac");

*/

/*!
\htmlonly
*/

oklib_include("Transitional/ComputerAlgebra/DataStructures/Lisp/Lists.mac")$
oklib_include("Transitional/ComputerAlgebra/Cryptology/Lisp/CryptoSystems/Rijndael/AdvancedEncryptionStandard.mac")$


/* ***************************************
   * Variables                           *
   ***************************************
*/

/* Variables are 
      aes_p(i) meaning the ith bit (starting at 1) of the AES plaintext
      aes_k(i) meaning the ith bit (starting at 1) of the AES key 
      aes_c(i) meaning the ith bit (starting at 1) of the AES ciphertext 
      aes_rk(r,i) meaning the ith bit (starting at 1) of the round key for the
        rth round.
      aes_r(r,n,i) meaning the ith bit (starting 1 ) of the nth set of
        variables used for input/output in the rth round
      aes_ke(n,i) meaning the ith bit (starting 1 ) of the nth set of
        variables used for input/output in the key expansion 
      aes_sr(r,n,i) meaning the ith bit (starting 1 ) of the nth set of
        variables used for input/output in the rth round in shiftrows
      aes_sb(r,n,i) meaning the ith bit (starting 1) of the nth set of 
        variables used for input/output in the rth round in the sbox  
      aes_mc(r,n,i) meaning the ith bit (starting 1) of the nth set of 
        variables used for input/output in the rth round in the mixcolumns */
kill(aes_p);
declare(aes_p, noun);
declare(aes_p, posfun);
aes_p_var(i) := nounify(aes_p)(i)$
kill(aes_k);
declare(aes_k, noun);
declare(aes_k, posfun);
aes_k_var(i) := nounify(aes_k)(i)$
kill(aes_c);
declare(aes_c, noun);
declare(aes_c, posfun);
aes_c_var(i) := nounify(aes_c)(i)$
kill(aes_rk);
declare(aes_rk, noun);
declare(aes_rk, posfun);
aes_rk_var(r,i) := nounify(aes_rk)(r,i)$
kill(aes_io);
declare(aes_r, noun);
declare(aes_r, posfun);
aes_r_var(r,u,i) := nounify(aes_r)(r,u,i)$
declare(aes_ke, noun);
declare(aes_ke, posfun);
aes_ke_var(u,i) := nounify(aes_ke)(u,i)$
declare(aes_sr, noun);
declare(aes_sr, posfun);
aes_sr_var(r,u,i) := nounify(aes_sr)(r,u,i)$
declare(aes_sb, noun);
declare(aes_sb, posfun);
aes_sb_var(r,u,i) := nounify(aes_sb)(r,u,i)$
declare(aes_mc, noun);
declare(aes_mc, posfun);
aes_mc_var(r,u,i) := nounify(aes_mc)(r,u,i)$

/* Given a constraint, this function returns the minimum
round number associated with any variable in the variable
set associated with the constraint. */
/*aes_min_r(con) := $ */

/* ***************************************
   * Condition Evaluation Functions      *
   ***************************************
*/

/*aes_con_eval(phi) :=  $ */
/*aes_key_expansion_con_eval(phi) :=  $ */
/*aes_round_con_eval(phi) :=  $ */
/*aes_final_round_con_eval(phi) :=  $ */
/*aes_shiftrows_con_eval(phi) :=  $ */
/*aes_mixcolumns_con_eval(phi) :=  $ */
/*aes_addition_con_eval(phi) :=  $ */
/*aes_equiv_con_eval(phi) :=  $ */

/* **********************************************************
   * Condition Producing Functions or "Rewrite Rules"       *
   **********************************************************
*/

/* A constraint is a tuple containing the name of the constraint (an arbitrary
   term, the set of variables, and a function to evaluate the constraint
   given a partial assignment */
/* MG : This should be defined elsewhere more generally? */

/* Each constraint-producing function below, takes a constraint and then
   produces a new set of constraints to replace that constraint. */

/* Returns a set of constraints representing 128 bit AES */
/* MG : Should this take the block and key sizes for generalisations? */
/*aes_rewrite_rule(con) := block([rs : {}],
  if first(con) = "aes_con" then
    rs : adjoin(["aes_key_expansion_con",setify(append(makelist(aes_k_var(i),i,1,128),
      create_list(aes_rk_var(r,i),r,0,10,i,1,128))),aes_key_expansion_eval],rs),
    rs : adjoin(["aes_add_key_con",setify(append(makelist(aes_rk_var(0,i),i,1,128),
      makelist(aes_p_var(i),i,1,128), makelist(aes_r_var(1,i),i,1,128))),
      aes_add_key_con_eval],rs),
    for r : 1 thru 9 do block(
      rs :adjoin(["aes_round_con",setify(append(makelist(aes_rk_var(r,i),i,1,128),
        makelist(aes_r_var(r,i),i,1,128),makelist(aes_r_var(r+1,1,i),i,1,128))
      ),aes_round_con_eval],rs)
    ),
    rs :adjoin(["aes_final_round_con",setify(append(makelist(aes_rk_var(10,i),i,1,128),
      makelist(aes_r_var(10,1,i),i,1,128),makelist(aes_c_var(i),i,1,128))
    ),aes_final_round_con_eval],rs),
    return([rs])
  else
    return([])
)$*/

/* Given a constraint, returns a list of length 1 containing the set of 
   constraints to rewrite the input constraint to if the input constraint
   is rewritable (ie is an AES round constraint) with this rule, or the 
   empty list otherwise */
/* MG: the round number, block and key size seem trivially parameterisable */
/* MG: Somehow r must be found or there must be a way to determine which 
   variables are which from the given constraint, so they can be correctly
   passed to the next. */
/* OK: Typical problem: name of the function to short, don't know what it means ??? */
/*aes_round_rewrite_rule(con) := block([r, rs:{}],
  if first(con) = "aes_round_con" then block(
    r : aes_min_r(con),
    rs :adjoin(["aes_sbox_con",setify(append(makelist(aes_r_var(r,1,i),i,1,128),
      makelist(aes_r_var(r,2,i),i,1,128))
    ),aes_sbox_con_eval],rs),
    rs :adjoin(["aes_shiftrows_con",setify(append(
      makelist(aes_r_var(r,2,i),i,1,128),makelist(aes_r_var(r,3,i),i,1,128))),
      aes_shiftrows_con_eval],rs),
    rs :adjoin(["aes_mixcolumns_con",setify(append(
      makelist(aes_r_var(r,3,i),i,1,128),makelist(aes_r_var(r,4,i),i,1,128))),
      aes_mixcolumns_con_eval],rs),
    rs :adjoin(["aes_addition_con",setify(append(
      makelist(aes_r_var(r,4,i),i,1,128),makelist(aes_r_var(r+1,0,i),i,1,128))),
      aes_addition_con_eval],rs),
    return([rs]))
  else
    return([])
)$*/

/* Given a constraint, returns a list of length 1 containing the set of 
   constraints to rewrite the input constraint to if the input constraint
   is rewritable (ie is an AES shiftrows constraint) with this rule, or the 
   empty list otherwise */
/*aes_shiftrows_rewrite_rule(con) := block([r,rs : {}], 
  if first(con) = "aes_shiftrows_con" then block(
    r : aes_min_r(con),
    setify(map(lambda([a,b],
        ["aes_equiv_con",union(setify(a),setify(b)),aes_equiv_con_eval]), 
      partition_elements(makelist(aes_r_var(r,0,i),i,1,128),8), 
      shiftrows(partition_elements(aes_r_var(r,1,i),i,1,128),8))))
  else
    return([])
)$*/

/* Given a constraint, returns a list of length 1 containing the set of 
   constraints to rewrite the input constraint to if the input constraint
   is rewritable (ie is an AES mixcolumns constraint) with this rule, or the 
   empty list otherwise */
/* MG: This is a placeholder for later code */
/*aes_mixcolumns_rewrite_rule([bits]) := block([r,rs:{}],
  if first(con) = "aes_mixcolumns_con" then block()
  else 
    return([])
)$*/

/* Given a constraint, returns a list of length 1 containing the set of 
   constraints to rewrite the input constraint to if the input constraint
   is rewritable (ie is an AES key expansion constraint) with this rule, or the
   empty list otherwise */
/* MG: This is a placeholder for later code */
/*aes_key_expansion_rewrite_rule([bits]) := block([rs:{}],
  if first(con) = "aes_key_expansion_con" then block()
  else 
    return([])
)$*/

/* Given a constraint, returns a list of length 1 containing the set of 
   constraints to rewrite the input constraint to if the input constraint
   is rewritable (ie is an AES sbox constraint) with this rule, or the 
   empty list otherwise */
/* MG: This is a placeholder for later code */
/*aes_sbox_rewrite_rule([bits]) := block([rs:{}],
  if first(con) = "aes_sbox_con" then block()
  else 
    return([])
)$*/


/* ***************************************
   * Rewrite System/Functions            *
   ***************************************
*/

/* MG: We need something here which takes a given rewrite rule
   and applies it to the set of constraints, renaming 
   variables etc if necessary to ensure there are no clashes
   between internal variables used in one constraint and
   those used in another. */

/*apply_rewrite_eule(rule,con_set) := $ */


/*!
\endhtmlonly
*/
