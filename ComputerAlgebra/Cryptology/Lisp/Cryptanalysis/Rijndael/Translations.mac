/* Matthew Gwynne, 26.3.2008 (Swansea) */
/* Copyright 2008, 2009 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/Translations.mac
  \brief Cryptanalysis functions for translations of Rijndael into active clauses etc

Use by

oklib_load("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/Translations.mac");
  
*/

/*!
\htmlonly
*/

oklib_include("OKlib/ComputerAlgebra/DataStructures/Lisp/Lists.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/CryptoSystems/Rijndael/AdvancedEncryptionStandard.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/SboxAnalysis.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/FieldOperationsAnalysis.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/data/FieldMul2CNF.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/data/FieldMul3CNF.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/data/FieldMul11CNF.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/data/FieldMul13CNF.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/data/FieldMul14CNF.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/data/FieldMul9CNF.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/data/SboxCNF.mac")$

/* NOTE : 

  In several functions such as aes_round_cp, and aes_key_expansion_cp "blocks"
  are mentioned, which are matrices (4x4 as standard) of bytes (8 bits / boolean
  variables used as a unit of computation within the AES.

  In this translation, currently, when given as a list of variables, each block 
  is considered column by column as is standard in the literature.

*/


/* ***************************************
   * Sets of Conditions                  *
   ***************************************
*/

oklib_plain_include(graphs)$

aes_var_ordering : hash_table()$

/* Resets variable numbering back to default: */
aes_reset_vars() := block(
  aes_var_ordering : hash_table(),
  aes_cnf_var_number : 0 
)$

aes_cnf_var_number : 0$

/* Generates a list of integer variables where the values n and m are used to
   determine the range of variables to return (using an offset to ensure new
   variables are returned for each call to this function), where "name" is used
   to ensure certain special variable cases (such as plaintext variables etc)
   are given identifiable variables: */
aes_make_vars_int(name,n,m) :=
  if name = "p" then create_list(i,i,n,m)
  else if name = "k" then create_list(i,i,128 + n,128 + m)
  else if name = "c" then create_list(i,i,256 + n,256 + m)
  else block([rl], 
    rl : create_list(i,i,aes_cnf_var_number + 3 * 128 + n,
      aes_cnf_var_number+3*128+m),
    aes_cnf_var_number : aes_cnf_var_number + (m-n+1),
    return(rl))$

/* Generates a list of variables of the form name_i where
   name is given and i ranges between n and m, offset by a given value to such
   that repeated calls to this function will yield new variables */
aes_make_vars_named(name, n,m) := block(
  [val : get_hash(name,aes_var_ordering), res], 
  if val = false then block(val : 0, set_hash(name,aes_var_ordering, 0)),
  res : create_list(eval_string(concat(name,string(i))),i,val + n, val + m),
  set_hash(name,aes_var_ordering,val+m), return(res))$

/* Allows overriding of variable naming to provide a direct clause set
   translation which seems MUCH quicker than substituting for named variables 
   in the final product within maxima. */
aes_make_vars : aes_make_vars_named;

/* Number of Rounds for the AES */
aes_num_rounds : 10$

/* Returns a set of conditions representing AES given
   128 plaintext variables, 128 key variables and 128 output
   variables. */
aes_cp([bits]) := block([pBits, kBits, cBits, ekBits,ib,ob, rs : {}],
  pBits : take_elements(128,bits),
  kBits : take_elements(128,rest(bits,128)),
  cBits : rest(bits,256),
  ekBits : aes_make_vars("ek",1, (aes_num_rounds+1)*128),
  /* Key Expansion */
  rs : adjoin(apply(aes_key_expansion_c,append(kBits, ekBits)),rs),
  ib : pBits,
  all_ob : aes_make_vars("o",1,(aes_num_rounds)*128),
  ob : take_elements(128,all_ob),
  /* Initial Round Key Addition */
  rs : adjoin(apply(aes_add_c,append(ib,take_elements(128,ekBits),ob)),rs),
  ib : ob,
  /* Rounds */
  for j : 1 thru (aes_num_rounds - 1) do block(
    ob : take_elements(128,rest(all_ob,j*128)),
    rs : adjoin(
      apply(aes_round_c,append(ib,take_elements(128,rest(ekBits,j*128)),ob)),
        rs),
    ib : ob
  ),
  /* Final Round */
  /* If we have a reduced round variant, truncate rather than generalise */
  ob : cBits,
  if aes_num_rounds = 10 then 
    rs : adjoin(apply(aes_final_round_c,append(ib,take_elements(128,
            rest(ekBits,aes_num_rounds*128)),ob)),rs)
  else
    rs : adjoin(apply(aes_round_c,append(ib,take_elements(128,
            rest(ekBits,aes_num_rounds*128)),ob)),rs),
  return(rs)
)$

/* Returns a set of conditions representing AES round given
   128 plaintext variables, 128 key variables and 128 output
   variables. */
aes_round_cp([bits]) := block([iBits, rkBits, oBits,tBits,rs:{}],
  iBits : take_elements(128,bits),
  rkBits : take_elements(128,rest(bits,128)),
  oBits : rest(bits,256),
  tBits : aes_make_vars("so", 1,128),
  rs : adjoin(apply(aes_subbytes_c,append(iBits, tBits)),rs),
  iBits : tBits,
  tBits : aes_make_vars("ro", 1,128),
  rs : adjoin(apply(aes_shiftrows_c,append(iBits, tBits)),rs),
  iBits : tBits,
  tBits : aes_make_vars("mo", 1,128),
  rs : adjoin(apply(aes_mixcolumns_c,append(iBits, tBits)),rs),
  iBits : tBits,
  tBits : oBits,
  rs : adjoin(apply(aes_add_c,append(iBits, rkBits, tBits)),rs),
  return(rs)
)$

/* Returns a set of conditions representing the final AES round given
   128 plaintext variables, 128 key variables and 128 output
   variables. */
aes_final_round_cp([bits]) := block([iBits, rkBits, oBits,tBits,rs:{}],
  iBits : take_elements(128,bits),
  rkBits : take_elements(128,rest(bits,128)),
  oBits : rest(bits,256),
  tBits : aes_make_vars("so", 1,128),
  rs : adjoin(apply(aes_subbytes_c,append(iBits, tBits)),rs),
  iBits : tBits,
  tBits : aes_make_vars("ro", 1,128),
  rs : adjoin(apply(aes_shiftrows_c,append(iBits, tBits)),rs),
  iBits : tBits,
  tBits : oBits,
  rs : adjoin(apply(aes_add_c,append(iBits, rkBits, tBits)),rs),
  return(rs)
)$

/* Returns a set of conditions representing the AES Subbytes operation given
   128 plaintext variables and 128 output variables. */
aes_subbytes_cp([bits]) := block([iBits, rkBits, oBits,tBits,rs:{}],
  iBits : take_elements(128,bits),
  oBits : rest(bits,128),
  for i : 0 thru 15 do
    rs : adjoin(apply(aes_sbox_c, 
      append( take_elements(8, rest(iBits,i*8)),
        take_elements(8, rest(oBits,i*8)))
    ),rs),
  return(rs)
)$

/* Returns a set of conditions representing the AES Shiftrows operation given
   128 plaintext variables and 128 output variables. */
aes_shiftrows_cp([bits]) := block([iBits, oBits],
  iBits : take_elements(128,bits),
  oBits : take_elements(128,rest(bits,128)),
  setify(map(lambda([a,b],aes_eq_c(a,b)), oBits, 
    apply(append,
      aes_shiftrows(partition_elements(iBits,8))))
    )
)$

/* Returns a set of conditions representing the AES Mixcolumns operation given
   128 plaintext variables and 128 output variables. */
aes_mixcolumns_cp([bits]) := block([iBits, oBits, nc],
  iBits : take_elements(128,bits),
  oBits : rest(bits,128),
  nc : length(iBits)/32,
  setify(map(lambda([a,b], 
    apply(aes_mixcolumn_c,append(apply(append,a),apply(append,b)))),
    partition_elements(partition_elements(iBits,8),nc),
    partition_elements(partition_elements(oBits,8),nc)))
)$

/* Returns a set of conditions representing the AES Mixcolumn operation (the 
   individual operation applied to a single column in AES Mixcolumns) given
   128 plaintext variables and 128 output variables. */
aes_mixcolumn_cp([bits]) := block([iBits, oBits, nc,rs : {}],
  iBits : partition_elements(take_elements(32, bits),8),
  oBits : partition_elements(rest(bits, 32), 8),
  /* First element */
  for i : 0 thru 3 do block([mulAVars, mulBVars, addAVars, addBVars],
    mulAVars : aes_make_vars("mc", 1,8),
    rs : adjoin(apply(aes_mul2_c,
        append(iBits[mod(0 + i,4) + 1],mulAVars)), rs),
    mulBVars : aes_make_vars("mc", 1,8),
    rs : adjoin(apply(aes_mul3_c,
        append(iBits[mod(1 + i,4) + 1],mulBVars)), rs),
    addAVars : aes_make_vars("mc",1,8),
    rs : adjoin(apply(aes_add_c, append(mulAVars,mulBVars, addAVars)), rs),
    addBVars : aes_make_vars("mc",1,8),
    rs : adjoin(apply(aes_add_c, 
      append(iBits[mod(2 + i,4) + 1],iBits[mod(3 + i,4) + 1], addBVars)), rs),
    rs : adjoin(apply(aes_add_c, append(addAVars,addBVars, oBits[i+1])), rs)
  ),
  for i : 0 thru 3 do block(
    [mulAVars, mulBVars, mulCVars, mulDVars, addAVars, addBVars],
    mulAVars : aes_make_vars("mc", 1,8),
    rs : adjoin(apply(aes_mul14_c,
        append(oBits[mod(0 + i,4) + 1],mulAVars)), rs),
    mulBVars : aes_make_vars("mc", 1,8),
    rs : adjoin(apply(aes_mul11_c,
        append(oBits[mod(1 + i,4) + 1],mulBVars)), rs),
    mulCVars : aes_make_vars("mc", 1,8),
    rs : adjoin(apply(aes_mul13_c,
        append(oBits[mod(2 + i,4) + 1],mulCVars)), rs),
    mulDVars : aes_make_vars("mc", 1,8),
    rs : adjoin(apply(aes_mul9_c,
        append(oBits[mod(3 + i,4) + 1],mulDVars)), rs),
    addAVars : aes_make_vars("mc",1,8),
    rs : adjoin(apply(aes_add_c, append(mulAVars,mulBVars, addAVars)), rs),
    addBVars : aes_make_vars("mc",1,8),
    rs : adjoin(apply(aes_add_c, 
      append(mulCVars,mulDVars, addBVars)), rs),
    rs : adjoin(apply(aes_add_c, append(addAVars,addBVars, iBits[i+1])), rs)
  ),
  return(rs)
)$

/* Generates a set of unit clauses (initially simpler than simplifying constants
   or making partial assignments) to set the given vars (representing the bits
   of AES round constants) to the round constant for round n */
aes_round_constant(ivars, n) := block([rc_el,rc_l],
  rc_el : xreduce(lambda([a,b],aes_field_mul_data[b,a+1]),
               create_list(2,i,1,(n -1)),1),
  rc_l : egf_coeffs(rijn_bit_field,egf_num2poly(rijn_byte_field,rc_el),7),
  setify(map(
    lambda([a,b], if b = 0 then {-a} else {a}),
    ivars, rc_l
  ))
)$

/* Returns a set of conditions representing the AES keyschedule operation given
   128 key variables and 128 * (aes_num_rounds + 1) output variables
   (consecutive lots of 128 bits representing the individual round keys).
   
   The first 128 variables in the list "bits" represent the key block for the 
   cipher, and then the (i+1)'th consecutive 128 variables in "bits" represents
   the round key block for the i'th round. 
   
   */
aes_key_expansion_cp([bits]) := block(
  [n_k : 4,n_b : 4, n_r : aes_num_rounds ,kBits, rkBits, nc,rs : {}, 
  sboxVars, addVars,fMat, kMat],
  /* Primary Variables */
  kBits : take_elements(128,bits),
  rkBits : rest(bits,128),
  fBits : take_elements(128,rkBits),
  /* Split into columns */
  cols :  partition_elements(partition_elements(rkBits,8),4),
  kMat : partition_elements(partition_elements(kBits,8),4),
  fMat : partition_elements(partition_elements(fBits,8),4),
  /* Make first round key equal */
  for j : 1 thru n_k do
    for i : 1 thru 4 do
      rs : adjoin(apply(aes_eq_c,append(kMat[j][i], fMat[j][i])),rs),
  /* Setup output bits */
  for j : n_k thru (n_b * (n_r +1)) - 1 do block(
    if mod(j, n_k) = 0 then block (
      sboxVars : aes_make_vars("ke",1,8),
      rs : adjoin(apply(aes_sbox_c, append(cols[j][2], sboxVars)), rs),
      addVars : aes_make_vars("ke",1,8),
      rs : adjoin(apply(aes_add_c,
        append(cols[j-n_k+1][1],sboxVars,addVars)),rs),
      rcVars : aes_make_vars("rc",1,8),
      rs : union(rs, aes_round_constant(rcVars,floor(j/n_k))),
      rs : adjoin(apply(aes_add_c, 
        append(rcVars,addVars, 
        cols[j+1][1])),rs),
      for i : 1 thru 3 do block(
        sboxVars : aes_make_vars("ke",1,8),
        rs : adjoin(apply(aes_sbox_c, 
          append(cols[j][mod(i+1,4)+1], sboxVars)), rs),
        rs : adjoin(apply(aes_add_c, 
          append(cols[j-n_k+1][i+1],sboxVars, cols[j+1][i+1])),rs)
      )
    )
    else for i : 1 thru 4 do 
      rs : adjoin( apply(aes_add_c,
        append(cols[j][i], cols[j-n_k+1][i],cols[j+1][i])),rs)
  ),
  return(rs)
)$

/* Returns a set of conditions representing addition within GF(2^n) given
   2 * n input variables (n bits to be added to the next n bits)
   and n output variables. */
aes_add_cp([bits]) := block([ nb : floor(length(bits) / 3)],
  xreduce(union, map(lambda([a,b,c], {{-a,-b,-c},{-a,b,c},{a,-b,c},{a,b,-c}}), 
    take_elements(nb,bits),
    take_elements(nb, rest(bits,nb)), rest(bits,nb*2))))$

/* Returns a set of conditions representing equivalence over 2 sets of bits,
   given 2 consecutive lots of n bits to be represented as logically by the set
   output conditions */
aes_eq_cp([bits]) := block([ nb : floor(length(bits) / 2)],
  xreduce(union, map(lambda([a,b], {{-a,b},{a,-b}}), 
    take_elements(nb,bits), rest(bits,nb))))$

/* Generates (and caches) the canonical CNF representation as a formal clause
   set of AES Field muliplication (within the Rijndael GF(2^8) field) by p 
   (given as an integer) with new variables. 
   
   New variables are introduced for each clause in the canonical DNF 
   representation (see dualts_fcl), where the variables are of the form dts(i)
   and i is the rank in the lexiographical ordering of the clauses.

   Caching here simply means that upon the first call to the function with
   argument "p", the result of the computation for that argument is stored 
   in a global variable "aes_mul_ts_CNF[p]" which will then be returned 
   immediately on subsequent calls to "aes_mul_ts_gen" with the same argument 
   to allow for reuse of "aes_mul_ts_gen" without the overhead of 
   recomputation.
 */
aes_mul_ts_CNF : create_list(false,i,1,256)$
aes_mul_ts_gen(p) := 
  if aes_mul_ts_CNF[p+1] = false then block([plus16 : lambda([x],x+16)],
      [mul_dnf : generate_full_aes_field_mul_dnf_fcs(p)],
    aes_mul_ts_CNF[p+1] : dualts_fcl(
      [listify(mul_dnf[1]),
       sort(
         listify(mul_dnf[2]),
         lambda([a,b], is(
           rank_lex_subsets(map(plus16,a),32) < 
             rank_lex_subsets(map(plus16,b),32)))
        )]
     ),
     return(aes_mul_ts_CNF[p+1])
  ) else aes_mul_ts_CNF[p+1]$
/* Returns a set of conditions representing multiplication by 02 or "x" in the
   Rijndael GF(2^8) field given the 8 input bits and 8 output bits */
aes_mul2_cp : aes_mul2_pi_cp$
/* Representation using small subsets of prime implicates and no new
   variables*/
aes_mul2_pi_cp([bits]) := rename_fcs(FieldMul2CNF,bits)[2]$
/* Canonical representation using new variables */
aes_mul2_ts_cp([bits]) :=   
  setify(
    rename_fcl(aes_mul_ts_gen(2),append(bits,aes_make_vars("mul2",1,256)))[2])$

/* Returns a set of conditions representing multiplication by 03 or "x + 1" in
   the Rijndael GF(2^8) field given the 8 input bits and 8 output bits */
/* MG : This should ideally take the CNF to be used */
aes_mul3_cp : aes_mul3_pi_cp$
/* Representation using small subsets of prime implicates and no new
   variables */
aes_mul3_pi_cp([bits]) := rename_fcs(FieldMul3CNF,bits)[2]$
/* Canonical representation using new variables */
aes_mul3_ts_cp([bits]) :=   
  setify(
    rename_fcl(aes_mul_ts_gen(3),append(bits,aes_make_vars("mul3",1,256)))[2])$

/* Returns a set of conditions representing multiplication by 03 or "x + 1" in
   the Rijndael GF(2^8) field given the 8 input bits and 8 output bits */
/* MG : This should ideally take the CNF to be used */
aes_mul14_cp : aes_mul14_pi_cp$
/* Representation using small subsets of prime implicates and no new
   variables */
aes_mul14_pi_cp([bits]) := rename_fcs(FieldMul14CNF,bits)[2]$
/* Canonical representation using new variables */
aes_mul14_ts_cp([bits]) :=   
  setify(
    rename_fcl(aes_mul_ts_gen(14),
      append(bits,aes_make_vars("mul14",1,256)))[2])$

/* Returns a set of conditions representing multiplication by 03 or "x + 1" in
   the Rijndael GF(2^8) field given the 8 input bits and 8 output bits */
/* MG : This should ideally take the CNF to be used */
aes_mul11_cp : aes_mul11_pi_cp$
/* Representation using small subsets of prime implicates and no new
   variables */
aes_mul11_pi_cp([bits]) := rename_fcs(FieldMul11CNF,bits)[2]$
/* Canonical representation using new variables */
aes_mul11_ts_cp([bits]) :=   
  setify(
    rename_fcl(aes_mul_ts_gen(11),
      append(bits,aes_make_vars("mul11",1,256)))[2])$

/* Returns a set of conditions representing multiplication by 03 or "x + 1" in
   the Rijndael GF(2^8) field given the 8 input bits and 8 output bits */
/* MG : This should ideally take the CNF to be used */
aes_mul13_cp : aes_mul13_pi_cp$
/* Representation using small subsets of prime implicates and no new
   variables */
aes_mul13_pi_cp([bits]) := rename_fcs(FieldMul13CNF,bits)[2]$
/* Canonical representation using new variables */
aes_mul13_ts_cp([bits]) :=   
  setify(
    rename_fcl(aes_mul_ts_gen(13),
      append(bits,aes_make_vars("mul13",1,256)))[2])$

/* Returns a set of conditions representing multiplication by 03 or "x + 1" in
   the Rijndael GF(2^8) field given the 8 input bits and 8 output bits */
/* MG : This should ideally take the CNF to be used */
aes_mul9_cp : aes_mul9_pi_cp$
/* Representation using small subsets of prime implicates and no new
   variables */
aes_mul9_pi_cp([bits]) := rename_fcs(FieldMul9CNF,bits)[2]$
/* Canonical representation using new variables */
aes_mul9_ts_cp([bits]) :=   
  setify(
    rename_fcl(aes_mul_ts_gen(9),append(bits,aes_make_vars("mul9",1,256)))[2])$

/* Generates (and caches) the canonical CNF representation as a formal clause
   set of AES Sbox operator with new variables. New variables are 
   introduced for each clause in the canonical DNF representation (see
   dualts_fcl), where the new variables are of the form dts(i) and i is the 
   rank in the lexiographical ordering of the clauses.

   Caching here simply means that upon the first call to the function, the 
   result of the computation is stored in a global variable "aes_sbox_ts_CNF"
   which will then be returned immediately on subsequent calls to
   "aes_sbox_ts_gen" to allow for reuse of "aes_sbox_ts_gen" without the
   overhead of recomputation.
 */
aes_sbox_ts_CNF : false;
aes_sbox_ts_gen() := 
  if aes_sbox_ts_CNF = false then block([plus16 : lambda([x],x+16)],
      [sbox_dnf : generate_full_aes_sbox_dnf_fcs()],
    aes_sbox_ts_CNF : dualts_fcl(
      [listify(sbox_dnf[1]),
       sort(
         listify(sbox_dnf[2]),
         lambda([a,b], is(
           rank_lex_subsets(map(plus16,a),32) < 
             rank_lex_subsets(map(plus16,b),32)))
        )]
     ), 
     return(aes_sbox_ts_CNF)
  ) else aes_sbox_ts_CNF$
/* Default the translation to use the old Sbox translation. */
aes_sbox_cp : aes_sbox_pi_cp$
/* Returns a set of conditions representing the AES Sbox given the 8 input bits
   and 8 output bits */
/* MG : This should ideally take the CNF to be used */
/* Representation using small subsets of prime implicates and no new
   variables */
aes_sbox_pi_cp([bits]) := rename_fcs(Sbox44ICCNF,bits)[2]$
/* Canonical representation using new variables */
aes_sbox_ts_cp([bits]) :=
  setify(
    rename_fcl(aes_sbox_ts_gen(),append(bits,aes_make_vars("sbox",1,256)))[2])$

/* ***************************************
   * Rewrite functions                  *
   ***************************************
*/

oklib_plain_include("opsubst")$

/* Takes a given set of conditions, a condition name, and a function to
   rewrite with and then produces a new set of conditions */
rewrite_condition(con_set, con_name, con_rewrite_f) := block(
  [num_con : 0, total : length(con_set)], 
  setify(uaapply(append,map(
    lambda([b], block(
      if (oklib_monitoring and (mod(num_con,100) = 0)) then block(
        print(con_name, " = ", num_con,"/",total)),
      num_con : num_con + 1,
      if not (op(b) = con_name) then [b] 
      else
        block([result],
          result : ev(opsubst(con_rewrite_f,con_name,b),eval),
          if setp(result) then listify(result) else [result]
      ))),
  listify(con_set)
  ))
))$

/* Given a set of conditions, applies all rewrite rules in a typical order that
   would result in a simple AES translation and returns the result condition 
   set (should be a clause set) . */
/* MG : A more general formal rewrite system is obviously needed rather than 
   this strict hard coded method */
rewrite_all(rs) := block(
  rs : rewrite_condition(rs, aes_key_expansion_c,aes_key_expansion_cp),
  rs : rewrite_condition(rs, aes_round_c, aes_round_cp),
  rs : rewrite_condition(rs, aes_final_round_c, aes_final_round_cp),
  rs : rewrite_condition(rs, aes_shiftrows_c, aes_shiftrows_cp),
  rs : rewrite_condition(rs, aes_mixcolumns_c, aes_mixcolumns_cp),
  rs : rewrite_condition(rs, aes_mixcolumn_c, aes_mixcolumn_cp),
  rs : rewrite_condition(rs, aes_subbytes_c, aes_subbytes_cp),
  rs : rewrite_condition(rs, aes_mul2_c, aes_mul2_cp),
  rs : rewrite_condition(rs, aes_mul3_c, aes_mul3_cp),
  rs : rewrite_condition(rs, aes_mul14_c, aes_mul14_cp),
  rs : rewrite_condition(rs, aes_mul11_c, aes_mul11_cp),
  rs : rewrite_condition(rs, aes_mul13_c, aes_mul13_cp),
  rs : rewrite_condition(rs, aes_mul9_c, aes_mul9_cp),
  rs : rewrite_condition(rs, aes_add_c, aes_add_cp),
  rs : rewrite_condition(rs, aes_eq_c, aes_eq_cp),
  rs : rewrite_condition(rs, aes_sbox_c, aes_sbox_cp),
  return(rs)
)$

/* Produces a CNF clause set representing 128-bit AES: */
aes_cnf_cs() := block([rs : {}, aes_make_vars : aes_make_vars_int],
  aes_reset_vars(),
  rs : apply(aes_cp, 
    append(aes_make_vars("p",1,128), aes_make_vars("k",1,128),
      aes_make_vars("c",1,128))),
  rs : rewrite_all(rs),
  return(rs)
)$

/* Produces a formal CNF clause set representing 128-bit AES */
aes_cnf_fcs() := block([aes_cs : {}, aes_make_vars : aes_make_vars_int],
  aes_cs : aes_cnf_cs(),
  [create_list(i,i,1,aes_cnf_var_number+3*128), aes_cs])$
output_aes_cnf(n) :=
  output_fcs(
    sconcat("AES, 128-bit key and block, ",aes_num_rounds,
      " Rounds SAT Translation"),
    aes_cnf_fcs(), n)$
output_aes_cnf_stdname() :=
  output_aes_cnf(sconcat("AES_R",aes_num_rounds,".cnf"))$

/* Takes a hexidecimal string in the notation typically used for Rijndael blocks
   (discussed in [Design of Rijndael] and in CryptoSystems plans) and given the
   variable list (assumed to be in the correct left to right bit ordering)
   generates a PA to the given variables to the given constant.  */
aes_hex2pa(hexStr, variableList) := block(
  setify(map(
    lambda([a,b], if b = 0 then -a else a),
        variableList, 
        apply(append,map(lambda([a], 
          egf_coeffs(rijn_bit_field,a,7)),hex2gf2t8l(hexStr)))
  ))
)$

/* ***********************************************
   * Constraint template rewrite translation     *
   ***********************************************
*/

/* The translation system given below is designed to replace the above
   translation system in it's entirety but must be introduced piecewise,
   with appropriate tests. */

/* AES variables - aes_v(i,id) */
/* id here is used as an identifier such as "ks" for key schedule bits, "o"
   for output bits etc. */
/* These are used throughout for all AES constraint templates */
kill(aes_v)$
declare(aes_v, noun)$
declare(aes_v, posfun)$
aes_var(i,id) := nounify(aes_v)(i,id)$

/* Given two integers n and m, a namespace, and
   a noun identifier, returns a list of AES variables of the form
   aes_v(i,id) for n <= i <= m. */
generate_aes_constraint_vars(n,m,namespace, id) :=
  res : map(namespace,create_list(aes_var(i,id),i,n,m))$

/* ********************************************
   * Rewrite system functions                 *
   ********************************************
*/

/* Given a parent namespace namespace_p, a new namespace template
   namespace, and a constraint, returns a new namespace, which
   consists of namespace_p composed with namespace, where namespace has
    the constraint as an additional argument. */
construct_constraint_namespace(namespace_p,namespace,cst) :=
  buildq([cst,namespace,namespace_p],
      lambda([a],namespace_p(namespace(a,cst))))$

/* Given a constraint name, a list of variables in the constraint, a list
   of constraint parameters and a namespace,
   returns a constraint constructed from these parameters. */
construct_constraint(cst_n,vars,arg_l,namespace) :=
  append([cst_n,vars],arg_l,[namespace])$

/* Given a list of constraints, and a rewrite map, returns a new list of
   constraints after applying the given rewrite map. */
rewrite_all_cstl(cstl,rewrite_map) := block(
  [rewrite_hash : osm2hm(rewrite_map),cstl_new : []],
  for cst in rs do block([cstr],
    cstr : ev_hm(rewrite_hash,cst[1]),
    if cstr # false then
      cstl_new : cons(rewrite_all_cstl(cstr[1](cstl),rewrite_map),cstl_new)
    else 
      cstl_new : cons([first(rs)],rs_new),
    cstl : rest(rs)),
  return(lappend(rs_new)))$

/* Given a list of constraints, and a rewrite map, returns a list of
   new variables which would be introduced when calling rewrite_all
   with the same parameters. */
rewrite_all_vars_l(cstl,rewrite_map) := block(
  [rewrite_hash : osm2hm(rewrite_map),lookup_var_lf,varl : []],
  lookup_var_lf : lambda([cst2], block(
      [rwf : ev_hm_d(rewrite_hash,cst2[1],zero_cstrb)],
      append(
        rwf[3](cst),
        rewrite_all_vars_l(rwf[1](cst),rewrite_map)))),
  return(lappend(map(lookup_var_lf,cstl))))$

/* Constraint rewrite bundle which does nothing
   (i.e the rewrite function it represents has the identity
   as it's namespace, and no variables are introduced by it's
   rewrite function). */
zero_cstrb : [lambda([[a]],[]), lambda([a],a),lambda([[a]],[])]$


/* ***********************************************
   * Constraint template rewrite functions       *
   ***********************************************
*/

/* AES constraint rewrite bundle */
aes_cstrb : [aes_cstr_cstl,aes_namespace,aes_ns_var_l]$

/* Namespace */
kill(aes_ctr_ns)$
declare(aes_ctr_ns,noun)$
declare(aes_ctr_ns,posfun)$
aes_namespace([args]) := apply(nounify(aes_ctr_ns),args)$


/* Returns a list of the variables introduced when
   applying aes_ctr_ctl given the auxiliary parameter
   list arg_l, under the given rewrite_mapping.

   For example, given the constraint template instance

   aes_ct(1,...,384,arg_l)

   is rewritten using aes_ctr_ctl, under
   rewrite_mapping, the list of variables
   returned by this function are exactly those
   variables introduced by aes_ctr_ctl and
   any rewritten-subconstraints it introduces
   (mapped to the corresponding rewrite functions
   by variable mapping, that is, this function
   recursively generates such a variable list,
   based on sub-constraints it uses).
*/
aes_ns_var_l(cst) := block(
  [aes_num_rounds,vars : [],namespace],
  namespace : construct_constraint_namespace(
    last(cst),aes_namespace,cst),
  aes_num_rounds : cst[3],
  vars : cons(
    generate_aes_constraint_vars(1,(aes_num_rounds+1)*128,
      namespace,"k"),vars),
  vars : cons(
    generate_aes_constraint_vars(1,aes_num_rounds*128,
      namespace,"o"),vars),
  return(lappend(vars)))$
/* Rewrite function designed to rewrite the AES constraint template "aes_ct".

   Takes as arguments 385 variables, which are the arguments of the "aes_ct"
   instance being rewritten.

   The first 384 of these are 128 plaintext, 128 key and 128 ciphertext
   variables respectively. The final argument is a pair (list) of auxiliary
   arguments, the first being the namespace to place all variables introduced
   by this function within, and the second being the integer number of rounds
   which specifies which round-variant of AES is being rewritten.

   The result of this function is a list of constraint template instances
   representing the AES constraint template instance being rewritten.
*/
aes_cstr_cstl(cst) := block(
  [bits, pBits, kBits, cBits, ekBits, ib, ob, rs : [],namespace,
  aes_num_rounds],
  if not listp(cst) or length(cst) < 2 or cst[1] # "aes_cst" then return([cst]),
  aes_num_rounds : cst[3],
  bits : cst[2],
  namespace : construct_constraint_namespace(
    if length(cst) < 3 then lambda([a],a) else last(cst),
    aes_namespace,cst),
  pBits : take_elements(128,bits),
  kBits : take_elements(128,rest(bits,128)),
  cBits : rest(bits,256),
  ekBits :
    generate_aes_constraint_vars(
      1,(aes_num_rounds+1)*128,namespace,"k"),
  /* Key Expansion */
  rs : cons(
    construct_constraint(
      "aes_key_expansion_cst",append(kBits,ekBits),[aes_num_rounds],namespace),
    rs),
  ib : pBits,
  all_ob :
    generate_aes_constraint_vars(1,(aes_num_rounds)*128,namespace,"o"),
  ob : take_elements(128,all_ob),
  /* Initial Round Key Addition */
  rs : cons(
    construct_constraint(
      "aes_add_cst",append(ib,take_elements(128,ekBits),ob),[],namespace),
    rs),
  ib : ob,
  /* Rounds */
  for j : 1 thru (aes_num_rounds - 1) do block(
    ob : take_elements(128,rest(all_ob,j*128)),
    rs : cons(
      construct_constraint("aes_round_cst",
        append(ib,take_elements(128,rest(ekBits,j*128)),ob),
        [], namespace),
      rs),
    ib : ob
  ),
  /* Final Round */
  /* If we have a reduced round variant, truncate rather than generalise */
  ob : cBits,
  if aes_num_rounds = 10 then 
    rs : cons(
      construct_constraint("aes_final_round_cst",
        append(ib,take_elements(128,rest(ekBits,aes_num_rounds*128)),ob),
        [],namespace),
      rs)
  else
    rs : cons(
      construct_constraint("aes_round_cst",
        append(ib,take_elements(128,rest(ekBits,aes_num_rounds*128)),ob),
        [],namespace),
      rs),
  return(rs)
)$

/*
   AES Round

*/

aes_round_cstrb :
 [aes_round_cstr_cstl, aes_round_namespace, aes_round_ns_var_l]$

/* AES round namespace */
kill(aes_round_ns)$
declare(aes_round_ns,noun)$
declare(aes_round_ns,posfun)$
aes_round_namespace([args]) := apply(nounify(aes_round_ns),args)$

aes_round_ns_var_l(cst) := block([vars : [],namespace],
  namespace : construct_constraint_namespace(
    last(cst),aes_round_namespace,cst),
  vars : cons(generate_aes_constraint_vars(1,128,namespace,"so"),vars),
  vars : cons(generate_aes_constraint_vars(1,128,namespace,"ro"),vars),
  vars : cons(generate_aes_constraint_vars(1,128,namespace,"mo"),vars),
  return(lappend(vars)))$
/* Returns a set of conditions representing AES round given
   128 plaintext variables, 128 key variables and 128 output
   variables. */
aes_round_cstr_cstl(cst) := block(
  [namespace,bits,iBits, rkBits, oBits,tBits,rs:[]],
  bits : cst[2],
  namespace : construct_constraint_namespace(
    last(cst),aes_round_namespace,cst),
  iBits : take_elements(128,bits),
  rkBits : take_elements(128,rest(bits,128)),
  oBits : rest(bits,256),
  tBits : generate_aes_constraint_vars(1,128,namespace,"so"),
  rs : cons(
    construct_constraint("aes_subbytes_cst",
        append(iBits,tBits),
        [],namespace),
    rs),
  iBits : tBits,
  tBits : generate_aes_constraint_vars(1,128,namespace,"ro"),
  rs : cons(
    construct_constraint("aes_shiftrows_cst",
        append(iBits,tBits),
        [],namespace),
    rs),
  iBits : tBits,
  tBits : generate_aes_constraint_vars(1,128,namespace,nounify(mo)),
  rs : cons(
    construct_constraint("aes_mixcolumns_cst",
      append(iBits, tBits),
      [],namespace),
    rs),
  iBits : tBits,
  tBits : oBits,
  rs : cons(
    construct_constraint("aes_add_cst",
      append(iBits, rkBits, tBits),
      [],namespace),
    rs),
  return(rs)
)$

/*
   AES Final round
   
*/

aes_final_round_cstrb :
 [aes_final_round_cstr_cstl, aes_final_round_namespace,aes_final_round_ns_var_l]$

/* AES final round namespace */
kill(aes_final_round_ns)$
declare(aes_final_round_ns,noun)$
declare(aes_final_round_ns,posfun)$
aes_final_round_namespace([args]) := apply(nounify(aes_final_round_ns),args)$

aes_final_round_ns_var_l(cst) := block(
  [vars : [],namespace],
  namespace : construct_constraint_namespace(
    last(cst),aes_final_round_namespace,cst),
  vars : cons(generate_aes_constraint_vars(1,128,namespace,"so"),vars),
  vars : cons(generate_aes_constraint_vars(1,128,namespace,"ro"),vars),
  return(lappend(vars)))$
/* Returns a set of conditions representing AES round given
   128 plaintext variables, 128 key variables and 128 output
   variables. */
aes_final_round_cstr_cstl(cst) := block(
  [namespace,bits,iBits, rkBits, oBits,tBits,rs:[]],
  bits : cst[2],
  namespace : construct_constraint_namespace(
    last(cst),aes_final_round_namespace,cst),
  iBits : take_elements(128,bits),
  rkBits : take_elements(128,rest(bits,128)),
  oBits : rest(bits,256),
  tBits : generate_aes_constraint_vars(1,128,namespace,"so"),
  rs : cons(
    construct_constraint("aes_subbytes_cst",
        append(iBits,tBits),
        [],namespace),
    rs),
  iBits : tBits,
  tBits : generate_aes_constraint_vars(1,128,namespace,"ro"),
  rs : cons(
    construct_constraint("aes_shiftrows_cst",
        append(iBits,tBits),
        [],namespace),
    rs),
  iBits : tBits,
  tBits : oBits,
  rs : cons(
    construct_constraint("aes_add_cst",
      append(iBits, rkBits, tBits),
      [],namespace),
    rs),
  return(rs)
)$

/*
   Subbytes
   
*/

aes_subbytes_cstrb :
 [aes_subbytes_cstr_cstl,aes_subbytes_namespace,aes_subbytes_ns_var_l]$


/* AES subbytes namespace */
kill(aes_subbytes_ns)$
declare(aes_subbytes_ns,noun)$
declare(aes_subbytes_ns,posfun)$
aes_subbytes_namespace([args]) := apply(nounify(aes_subbytes_ns),args)$

aes_subbytes_ns_var_l([a]) := []$
/* Returns a set of conditions representing the AES Subbytes operation given
   128 plaintext variables and 128 output variables. */
aes_subbytes_cstr_cstl(cst) := block(
  [namespace,bits,iBits, rkBits, oBits,tBits,rs:[]],
  bits : cst[2],
  namespace : construct_constraint_namespace(
    last(cst), aes_subbytes_namespace,cst),
  iBits : take_elements(128,bits),
  oBits : rest(bits,128),
  for i : 0 thru 15 do
    rs : cons(
      construct_constraint("aes_sbox_cst",
        append(
          take_elements(8, rest(iBits,i*8)),
          take_elements(8, rest(oBits,i*8))),
        [], namespace),
      rs),
  return(rs)
)$


/*
   Shiftrows

*/

aes_shiftrows_ctrb :
 [aes_shiftrows_cstr_cstl,aes_shiftrows_namespace,aes_shiftrows_ns_var_l]$

/* AES shiftrows namespace */
kill(aes_shiftrows_ns)$
declare(aes_shiftrows_ns,noun)$
declare(aes_shiftrows_ns,posfun)$
aes_shiftrows_namespace(arg_l) := apply(nounify(aes_shiftrows_ns),arg_l)$


aes_shiftrows_ns_var_l([a]) := []$
/* Returns a set of conditions representing the AES Shiftrows operation given
   128 plaintext variables and 128 output variables. */
aes_shiftrows_cstr_cstl(cst) := block(
  [namespace,bits,iBits, oBits,count : 0],
  bits : cst[2],
  namespace : construct_constraint_namespace(
    last(cst), aes_shiftrows_namespace,cst),
  iBits : take_elements(128,bits),
  oBits : take_elements(128,rest(bits,128)),
  map(
    lambda([a,b],
      construct_constraint("aes_eq_cst",[a,b],
        [],namespace)), oBits, 
    apply(append,
      aes_shiftrows(partition_elements(iBits,8))))
)$


/*
   Mixcolumns

*/

aes_mixcolumns_ctrb :
 [aes_mixcolumns_cstr_cstl,aes_mixcolumns_namespace,aes_mixcolumns_ns_var_l]$

/* AES mixcolumns namespace */
kill(aes_mixcolumns_ns)$
declare(aes_mixcolumns_ns,noun)$
declare(aes_mixcolumns_ns,posfun)$
aes_mixcolumns_namespace([arg_l]) := apply(nounify(aes_mixcolumns_ns),arg_l)$


aes_mixcolumns_ns_var_l([a]) := []$
/* Returns a set of conditions representing the AES Mixcolumns operation given
   128 plaintext variables and 128 output variables. */
aes_mixcolumns_cstr_cstl(cst) := block(
  [namespace, bits,iBits, oBits, nc],
  bits : cst[2],
  namespace : construct_constraint_namespace(
    last(cst), aes_mixcolumns_namespace,cst),
  iBits : take_elements(128,bits),
  oBits : rest(bits,128),
  nc : length(iBits)/32,
  map(lambda([a,b,column], 
    construct_constraint("aes_mixcolumn_cst",
      append(apply(append,a),apply(append,b)),
      [],namespace)),
    partition_elements(partition_elements(iBits,8),nc),
    partition_elements(partition_elements(oBits,8),nc),
    create_list(i,i,1,4))
)$


/*
   Mixcolumn

*/

aes_mixcolumn_cstrb :
 [aes_mixcolumn_cstr_cstl,aes_mixcolumn_namespace,aes_mixcolumn_ns_var_l]$


/* AES mixcolumn namespace */
kill(aes_mixcolumn_ns)$
declare(aes_mixcolumn_ns,noun)$
declare(aes_mixcolumn_ns,posfun)$
aes_mixcolumn_namespace([args]) := apply(nounify(aes_mixcolumn_ns),args)$

aes_mixcolumn_ns_var_l(cst) := block([vars : [],namespace],
  namespace :
    construct_constraint_namespace(
      last(cst),aes_mixcolumn_namespace,cst),
  vars : cons(
      generate_aes_constraint_vars(1,32,namespace,"mc2"),vars),
  vars : cons(
      generate_aes_constraint_vars(1,32,namespace,"mc3"),vars),
  vars : cons(
      generate_aes_constraint_vars(1,32,namespace,"ad23"),vars),
  vars : cons(
      generate_aes_constraint_vars(1,32,namespace,"ad11"),vars),
  vars : cons(
      generate_aes_constraint_vars(1,32,namespace,"mc14"),vars),
  vars : cons(
      generate_aes_constraint_vars(1,32,namespace,"mc11"),vars),
  vars : cons(
      generate_aes_constraint_vars(1,32,namespace,"mc13"),vars),
  vars : cons(
      generate_aes_constraint_vars(1,32,namespace,"mc9"),vars),
  vars : cons(
      generate_aes_constraint_vars(1,32,namespace,"ad1411"),vars),
  vars : cons(
      generate_aes_constraint_vars(1,32,namespace,"ad139"),vars),
  return(lappend(vars)))$
/* Returns a set of conditions representing the AES Mixcolumn operation (the 
   individual operation applied to a single column in AES Mixcolumns) given
   128 plaintext variables and 128 output variables. */
aes_mixcolumn_cstr_cstl(cst) := block(
  [namespace,bits,iBits, oBits, nc,rs : []],
  bits : cst[2],
  namespace :
    construct_constraint_namespace(
      last(cst),aes_mixcolumn_namespace,cst),
  iBits : partition_elements(take_elements(32, bits),8),
  oBits : partition_elements(rest(bits, 32), 8),
  /* First element */
  for i : 0 thru 3 do block([mulAVars, mulBVars, addAVars, addBVars],
    mulAVars :
      generate_aes_constraint_vars(8*i + 1,8*i + 8,namespace,"mc2"),
    rs : cons(
      construct_constraint("aes_mul2_cst",
        append(iBits[mod(0 + i,4) + 1],mulAVars),
        [],namespace),
      rs),
    mulBVars :
      generate_aes_constraint_vars(8*i + 1,8*i + 8,namespace,"mc3"),
    rs : cons(
      construct_constraint("aes_mul3_cst",
        append(iBits[mod(1 + i,4) + 1],mulBVars),
        [],namespace),
      rs),
    addAVars :
      generate_aes_constraint_vars(8*i+1,8*i+8,namespace,"ad23"),
    rs : cons(
      construct_constraint("aes_add_cst",
        append(mulAVars,mulBVars, addAVars),
        [],namespace),
      rs),
    addBVars :
      generate_aes_constraint_vars(8*i+1,8*i+8,namespace,"ad11"),
    rs : cons(
      construct_constraint("aes_add_cst", 
        append(iBits[mod(2 + i,4) + 1],iBits[mod(3 + i,4) + 1], addBVars),
        [],namespace),
      rs),
    rs : cons(
      construct_constraint("aes_add_cst",
        append(addAVars,addBVars, oBits[i+1]),
        [],namespace),
      rs)
  ),
  for i : 0 thru 3 do block(
    [mulAVars, mulBVars, mulCVars, mulDVars, addAVars, addBVars],
    mulAVars :
      generate_aes_constraint_vars(8*i+1,8*i+8,namespace,"mc14"),
    rs : cons(
      construct_constraint("aes_mul14_cst",
        append(oBits[mod(0 + i,4) + 1],mulAVars),
        [],namespace),
      rs),
    mulBVars :
      generate_aes_constraint_vars(8*i+1,8*i+8,namespace,"mc11"),
    rs : cons(
      construct_constraint("aes_mul11_cst",
        append(oBits[mod(1 + i,4) + 1],mulBVars),
        [],namespace),
      rs),
    mulCVars :
      generate_aes_constraint_vars(8*i+1,8*i+8,namespace,"mc13"),
    rs : cons(
      construct_constraint("aes_mul13_cst",
        append(oBits[mod(2 + i,4) + 1],mulCVars),
        [],namespace),
      rs),
    mulDVars :
      generate_aes_constraint_vars(8*i+1,8*i+8,namespace,"mc9"),
    rs : cons(
      construct_constraint("aes_mul9_cst",
        append(oBits[mod(3 + i,4) + 1],mulDVars),
        [],namespace),
      rs),
    addAVars :
      generate_aes_constraint_vars(8*i+1,8*i+8,namespace,"ad1411"),
    rs : cons(
      construct_constraint("aes_add_cst",
        append(mulAVars,mulBVars, addAVars),
        [],namespace),
      rs),
    addBVars :
      generate_aes_constraint_vars(8*i+1,8*i+8,namespace,"ad139"),
    rs : cons(
      construct_constraint("aes_add_cst", 
        append(mulCVars,mulDVars, addBVars),
        [],namespace),
      rs),
    rs : cons(
      construct_constraint("aes_add_cst",
        append(addAVars,addBVars, iBits[i+1]),
        [],namespace),
      rs)
  ),
  return(rs)
)$


/*
   Key expansion

*/


aes_key_expansion_cstrb :
 [aes_key_expansion_cstr_cstl,aes_key_expansion_namespace,
  aes_key_expansion_ns_var_l]$

/* Generates a set of unit clauses (initially simpler than simplifying constants
   or making partial assignments) to set the given vars (representing the bits
   of AES round constants) to the round constant for round n */
aes_round_constant_l(ivars, n) := block([rc_el,rc_l],
  rc_el : xreduce(lambda([a,b],aes_field_mul_data[b,a+1]),
               create_list(2,i,1,(n -1)),1),
  rc_l : egf_coeffs(rijn_bit_field,egf_num2poly(rijn_byte_field,rc_el),7),
  return(map(lambda([a,b], if b = 0 then -a else a),ivars, rc_l))
)$

/* AES key expansion namespace */
kill(aes_key_expansion_ns)$
declare(aes_key_expansion_ns,noun)$
declare(aes_key_expansion_ns,posfun)$
aes_key_expansion_namespace([args]) :=
  apply(nounify(aes_key_expansion_ns),args)$

aes_key_expansion_ns_var_l(cst) := block(
  [n_r : cst[3],vars : [],namespace],
  namespace : construct_constraint_namespace(
    last(cst),aes_key_expansion_namespace,cst),
  vars : cons(
    generate_aes_constraint_vars(1,4*8*n_r,namespace,"sb"),vars),
  vars : cons(
    generate_aes_constraint_vars(1,8*n_r,namespace,"ke"),vars),
  vars : cons(
    generate_aes_constraint_vars(1,8*n_r,namespace,"rc"),vars),
  return(lappend(vars)))$
/* Returns a set of conditions representing the AES keyschedule operation given
   128 key variables and 128 * (aes_num_rounds + 1) output variables
   (consecutive lots of 128 bits representing the individual round keys).
   
   The first 128 variables in the list "bits" represent the key block for the 
   cipher, and then the (i+1)'th consecutive 128 variables in "bits" represents
   the round key block for the i'th round. 
   
   */
aes_key_expansion_cstr_cstl(cst) := block(
  [namespace,bits, n_k : 4,n_b : 4, n_r,kBits, rkBits, nc,rs : [],
   sboxVars, addVars,fMat, kMat],
  bits : cst[2],
  namespace : construct_constraint_namespace(
    last(cst),aes_key_expansion_namespace,cst),
  n_r : cst[3],
  /* Primary Variables */
  kBits : take_elements(128,bits),
  rkBits : rest(bits,128),
  fBits : take_elements(128,rkBits),
  /* Split into columns */
  cols :  partition_elements(partition_elements(rkBits,8),4),
  kMat : partition_elements(partition_elements(kBits,8),4),
  fMat : partition_elements(partition_elements(fBits,8),4),
  /* Make first round key equal */
  for j : 1 thru n_k do
    for i : 1 thru n_b do
      rs : cons(
        construct_constraint("aes_eq_cst",
          append(kMat[j][i], fMat[j][i]),
          [],namespace),
        rs),
  /* Setup output bits */
  for j : n_k thru (n_b * (n_r +1)) - 1 do block(
    if mod(j, n_k) = 0 then block (
      sboxVars : generate_aes_constraint_vars(
        (j-n_k)*8*(4/n_k) +1,(j-n_k)*8*(4/n_k) +8,namespace,nounify(sb)),
      rs : cons(
        construct_constraint("aes_sbox_cst",
          append(cols[j][2], sboxVars),
          [],namespace),
        rs),
      addVars : generate_aes_constraint_vars(
        (j-n_k)*(8/n_k) +1,(j-n_k)*(8/n_k) +8,namespace,nounify(ke)),
      rs : cons(
        construct_constraint("aes_add_cst",
          append(cols[j-n_k+1][1],sboxVars,addVars),
          [],namespace),
        rs),
      rcVars : generate_aes_constraint_vars(
        (j-n_k)*(8/n_k) + 1,(j-n_k)*(8/n_k) + 8,namespace,nounify(rc)),
      rs : cons(
        construct_constraint("aes_eq_cst",
            append(aes_round_constant_l(rcVars,floor(j/n_k)),
              create_list(true,i,1,8)),
            [],namespace),
        rs),
      rs : cons(
        construct_constraint("aes_add_cst", 
          append(rcVars,addVars, cols[j+1][1]),
          [],namespace),
        rs),
      for i : 1 thru 3 do block([offset: ((j-n_k)*(4/n_k) + i)*8],
        sboxVars : generate_aes_constraint_vars(
          offset + 1,offset + 8,namespace,nounify(sb)),
        rs : cons(
          construct_constraint("aes_sbox_cst", 
            append(cols[j][mod(i+1,4)+1], sboxVars),
            [],namespace),
          rs),
        rs : cons(
          construct_constraint("aes_add_cst", 
            append(cols[j-n_k+1][i+1],sboxVars, cols[j+1][i+1]),
            [],namespace),
          rs)
      )
    )
    else for i : 1 thru 4 do 
      rs : cons(
        construct_constraint("aes_add_cst",
          append(cols[j][i], cols[j-n_k+1][i],cols[j+1][i]),
          [],namespace),
        rs)
  ),
  return(rs)
)$

/* ****************************************
   * Translation functions                *
   ****************************************
*/

/* Returns a list of CNF clauses representing addition within GF(2^n) given
   an "aes_add_cst" constraint with 2 * n input variables (n bits to be added
   to the next n bits) and n output variables. */
aes_add_cst_cl(cst) := block([ nb : floor(length(cst[2]) / 3)],
  lappend(map(lambda([a,b,c], [{-a,-b,-c},{-a,b,c},{a,-b,c},{a,b,-c}]), 
    take_elements(nb,cst[2]),
    take_elements(nb, rest(cst[2],nb)), rest(cst[2],nb*2))))$

/* Returns a list of CNF clauses representing equivalence between the first
   half of the list of variables and the second half in the constraint.

   Variables in the second half may also be "true", in which case, unit
   clauses will be introduced.
*/
aes_eq_cst_cl(cst) := block([ nb : floor(length(cst[2]) / 2)],
  lappend(
    map(lambda([a,b], if b = true then [{a}] else [{-a,b},{a,-b}]), 
    take_elements(nb,cst[2]), rest(cst[2],nb))))$


/*!
\endhtmlonly
*/
