/* Matthew Gwynne, 28.9.2010 (Swansea) */
/* Copyright 2010 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/ConstraintTemplateRewriteSystem.mac
  \brief System for iteratively translating a system of constraint templates into another representation system (CNF etc).

Use by

oklib_load("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/ConstraintTemplateRewriteSystem.mac");
  
*/

/*!
\htmlonly
*/

oklib_include("OKlib/ComputerAlgebra/DataStructures/Lisp/Lists.mac")$

/* ********************************************
   * Rewrite system functions                 *
   ********************************************
*/

/* MG : Need to rewrite below so that cst is replaced by args
   and therefore we do not get the exponential blow up in
   the size of the namespaces. */

/* The idea is that the args should uniquely identify a given constraint
   within the context of it's parent constraint and therefore, as it's
   parent constraint is uniquely identified above, we have inductively
   that any variable is uniquely identified. */

/* Write descriptions of each of the datatypes */

/* Add "aes_cst_match()" function which checks whether a given object
   is a constraint with the correct name.  */

/* Expand names like  pBits etc for clarity */



/* TODO: Explain namespace */

/* TODO: Explain constraint */

/****************************
 * Namespaces               *
 ****************************
*/

/* Given a parent namespace namespace_p, a new namespace template
   namespace, and a constraint, returns a new namespace, which
   consists of namespace_p composed with namespace, where namespace has
    the constraint as an additional argument. */
cstt_namespace_new(namespace,cst_p) := block([namespace_p],
  namespace_p :
    if list_p(cst_p) and length(cst_p) < 3 then lambda([a],a) else last(cst_p),
  return(buildq([cst_p,namespace,namespace_p],
        lambda([a],namespace_p(namespace(a,cst_p))))))$


/****************************
 * Constraints              *
 ****************************
*/

/* Given a constraint name, a list of variables in the constraint, a list
   of constraint parameters and a namespace,
   returns a constraint constructed from these parameters. */
cstt_new(cst_n,vars,arg_l,namespace) :=
  append([cst_n,vars],arg_l,[namespace])$

/* Given a constraint template returns the constraint template name. */
cstt_name(cst) := first(cst)$

/* Given a constraint template returns the variables in the constraint
   template */
cstt_vars_l(cst) :=
  if listp(cst) and length(cst) > 1 and listp(cst[2]) then second(cst) else []$

/* Given a constraint template returns the constraint template
   auxiliary arguments. */
cstt_args_l(cst) :=
  if listp(cst) and length(cst) > 2 and listp(cst[3]) then cst[3] else []$

/* Given a constraint template returns the namespace of the constraint
   template. */
cstt_namespace_f(cst) :=
  if listp(cst) and length(cst) > 3 then last(cst) else lambda([a],a)$

/* Check whether a given object is a constraint template */
cstt_p(cstt) := is(listp(cstt) and length(cstt) >= 2)$

/* Check whether a given object is a constraint template with
   the given name */
cstt_named_p(cstt,name) := is(cstt_p(cstt) and cstt[1] = name)$


/********************************
 * Rewrite functions            *
 ********************************
*/

/* Given a list of constraint templates, and a rewrite map, returns a new list
   of constraint templates after applying the given rewrite map. */
rewrite_all_csttl(cstl,rewrite_map) := block(
  [rewrite_hash : osm2hm(rewrite_map),cstl_new : []],
  for cst in cstl do block([cstr],
    cstr : ev_hm(rewrite_hash,cst[1]),
    if cstr # false then
      cstl_new : cons(rewrite_all_csttl(cstr[1](cst),rewrite_map),cstl_new)
    else 
      cstl_new : cons([first(cstl)],cstl_new),
    cstl : rest(cstl)),
  return(lappend(cstl_new)))$

/* Given a list of constraint templates, and a rewrite map, returns a list of
   new variables which would be introduced when calling rewrite_all
   with the same parameters. */
rewrite_all_cstt_vars_l(cstl,rewrite_map) := block(
  [rewrite_hash : osm2hm(rewrite_map),lookup_var_lf,varl : []],
  lookup_var_lf : lambda([cst], block(
      [rwf : ev_hm_d(rewrite_hash,cst[1],zero_cstrb)],
      append(
        rwf[3](cst),
        rewrite_all_cstt_vars_l(rwf[1](cst),rewrite_map)))),
  return(lappend(map(lookup_var_lf,cstl))))$


/****************************************
 * Rewrite bundles                      *
 ****************************************
*/

/* Constraint template rewrite bundle which does nothing
   (i.e the rewrite function it represents has the identity
   as it's namespace, and no variables are introduced by it's
   rewrite function). */
zero_csttrb : [lambda([[a]],[]), lambda([a],a),lambda([[a]],[])]$

/*!
\endhtmlonly
*/
