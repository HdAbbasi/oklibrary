/* Oliver Kullmann, 17.4.2009 (Swansea) */
/* Copyright 2009, 2012 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Satisfiability/Lisp/Generators/RamseyTheory/SchurProblems.mac
  \brief %Generators for clause-sets related to Schur problems

Use by

oklib_load("OKlib/ComputerAlgebra/Satisfiability/Lisp/Generators/RamseyTheory/SchurProblems.mac");

*/

/*!
\htmlonly
*/

oklib_include("OKlib/ComputerAlgebra/Hypergraphs/Lisp/Generators/Generators.mac")$
oklib_include("OKlib/ComputerAlgebra/Hypergraphs/Lisp/Colouring.mac")$
oklib_include("OKlib/ComputerAlgebra/Satisfiability/Lisp/Generators/NonBooleanTranslations.mac")$
oklib_include("OKlib/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/NonBoolean.mac")$

/* *****************
   * Schur triples *
   *****************
*/

/* The non-boolean formal clause-set expressing the Schur problem with
   r parts and n vertices.
   Prerequisites: r, n natural numbers, n, r >= 0.
*/
schur_nbfclud(r,n) := col2sat_stdohg2stdnbfclud(schurtriples_ohg(n), create_list(i,i,1,r))$
schur_nbfcsud(r,n) :=
 nbfclud2nbfcsud(schur_nbfclud(r,n))$

/* Statistics: */
nvar_schur_nbfcsud(r,n) := nver_schurtriples_hg(n)$
nval_schur_nbfcsud(r,n) := r$
ncl_list_schur_nbfcsud(r,n) := if r=0 then [] else
 map(lambda([p],[p[1],r*p[2]]), nhyp_list_schurtriples_hg(n))$
ncl_schur_nbfcsud(r,n) := r * nhyp_schurtriples_hg(n)$


/* Adding symmetry-breaking clauses (regarding the parts (colours), forcing
   vertex 1 to be in part 1); now we must have n >= 1: */
schur_sb_nbfcsud(r,n) := block([S : schur_nbfcsud(r,n)],
 [S[1], union(setify(create_list({[1,i]},i,2,r)), S[2]), S[3]])$


/* Translation into boolean clause-sets: */

/* Translating the general forms into boolean clause-sets via the
   (strong) direct translation: */
schur_aloamo_fcl(r,n) := nbfclud2fcl_aloamo(schur_nbfclud(r,n))$
schur_aloamo_fcs(r,n) := fcl2fcs(schur_aloamo_fcl(r,n))$

/* Statistics: */
nvar_schur_aloamo_fcl(r,n) :=
 nvar_schur_nbfcsud(r,n) * nval_schur_nbfcsud(r,n)$
nvar_schur_aloamo_fcs(r,n) := nvar_schur_aloamo_fcl(r,n)$
ncl_list_schur_aloamo_fcl(r,n) := if n=0 then []
 elseif r=0 then [[0,n]]
 elseif r=1 then cons([1,n], ncl_list_schur_nbfcsud(r,n))
 elseif n=1 then if r=2 then [[2,2]] else [[2,binomial(r,2)],[r,1]]
 elseif n=2 then if r=2 then [[2,6]] else [[2,r+2*binomial(r,2)],[r,2]]
 else block([C2,C3],  /* now n >= 3, r >= 2 */
  [C2,C3] : map(second,ncl_list_schur_nbfcsud(r,n)),
  if r=2 then [[2,C2+n+n], [3,C3]]
  elseif r=3 then [[2,C2+3*n],[3,C3+n]]
  else [[2,C2+n*binomial(r,2)],[3,C3],[r,n]])$
ncl_list_schur_aloamo_fcs(r,n) := if n=0 then []
 elseif r=0 then [[0,1]] else ncl_list_schur_aloamo_fcl(r,n)$

/* Standardisation: */
/* Computing translation functions for standardising resp. de-standardising
   terms resp. individual variables:
*/
standardise_schur_aloamo(r,n) :=
  buildq([r], lambda([t], ev(t, nbv(v,i):=(v-1)*r+i, nbv)))$
invstandardise_schur_aloamo(r,n) :=
  buildq([r], lambda([i], block([d : divide(i-1,r)+1],
    nbv_var(d[1], d[2]))))$

schur_aloamo_stdfcl(r,n) := (
  [block([s : standardise_schur_aloamo(r,n)],
     s(schur_aloamo_fcl(r,n))),
   block([invs : invstandardise_schur_aloamo(r,n)],
     create_list(invs(i), i,1,n*r))])$
/* We have schur_aloamo_stdfcl(r,n) =
   standardise_fcl(schur_aloamo_fcl(r,n)).
*/

/* Output: */

/* Output the boolean clause-set (standard translation) to a file: */
/* TODO: use schur_aloamo_fcl(r,n) plus explicit standardisation */
output_schur(r,n,filename) := block(
 [FF : schur_aloamo_stdfcl(r,n)],
  output_fcl_v(
    sconcat("Schur problem with ", r, " parts and ", n, " elements, using the direct (strong) translation."),
    FF[1],
    filename,
    FF[2]))$
/* Providing a standard name: "Schur_r_n.cnf": */
output_schur_stdname(r,n) := output_schur(r,n,
  sconcat("Schur_",r,"_",n,".cnf"))$

output_schur_sb(r,n,filename) := block(
 [FF : standardise_fcs(nbfcsfd2fcs_aloamo(nbfcsud2nbfcsfd(schur_sb_nbfcsud(r,n))))],
  output_fcs_v(
    sconcat("Schur problem with ", r, " parts and ", n, " elements; symmetry breaking by putting element 1 into part 1."),
    FF[1],
    filename,
    FF[2]))$
/* Providing a standard name: "Schur_r_n.cnf": */
output_schur_sb_stdname(r,n) := output_schur_sb(r,n,
  sconcat("Schur_sb_",r,"_",n,".cnf"))$


/*!
\endhtmlonly
*/
