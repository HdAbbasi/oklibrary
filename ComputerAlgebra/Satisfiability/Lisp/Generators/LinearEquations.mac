/* Oliver Kullmann, 11.5.2013 (Swansea) */
/* Copyright 2013 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Satisfiability/Lisp/Generators/LinearEquations.mac
  \brief Generators for clause-sets related to linear equations

Use by

oklib_load("OKlib/ComputerAlgebra/Satisfiability/Lisp/Generators/LinearEquations.mac");

*/

/*!
\htmlonly
*/

oklib_include("OKlib/ComputerAlgebra/DataStructures/Lisp/Lists.mac")$
oklib_include("OKlib/ComputerAlgebra/Hypergraphs/Lisp/SetSystems.mac")$
oklib_include("OKlib/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/BasicOperations.mac")$
oklib_include("OKlib/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/PartialAssignments.mac")$
oklib_include("OKlib/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/Substitutions.mac")$
oklib_include("OKlib/ComputerAlgebra/NumberTheory/Lisp/Auxiliary.mac")$
oklib_include("OKlib/ComputerAlgebra/Satisfiability/Lisp/Generators/Generators.mac")$


/* *********************
   * Parity conditions *
   *********************
*/

/* The repetition-free clause-list of full clauses over variables 1, ..., n,
   such that the satisfying assignments are given by the condition that the
   sum over the values is even resp. odd, that is, the list of full clauses
   having an odd resp. even number of negative literals; the order is
   lexicographical:
*/
even_parity_cl(n) :=
  sublist(all_tass_l(setn(n)),
          lambda([C], oddp(sum_l(map(negsignum, listify(C))))))$
/* Now supplying the list V of variables: */
even_parity_wv_cl(V) :=
  sublist(all_tass_l(setify(V)),
          lambda([C], oddp(sum_l(map(negsignum, listify(C))))))$
/* As formal clause-list: */
even_parity_fcl(n) := [create_list(i,i,1,n),even_parity_cl(n)]$

odd_parity_cl(n) :=
  sublist(all_tass_l(setn(n)),
          lambda([C], evenp(sum_l(map(negsignum, listify(C))))))$
/* Now supplying the list V of variables: */
odd_parity_wv_cl(V) :=
  sublist(all_tass_l(setify(V)),
          lambda([C], evenp(sum_l(map(negsignum, listify(C))))))$
/* As formal clause-list: */
odd_parity_fcl(n) := [create_list(i,i,1,n),odd_parity_cl(n)]$


/* **********************
   * Parity constraints *
   **********************
*/

/*
  A "(boolean) parity-constraint" ("prt") is a list L of literals with
  different underlying variables, with meaning "sum_{x in L} x = 0",
  where the sum takes places in the 2-element field {0,1} (i.e., the sum
  is xor).
  A "general (boolean) parity-constraint" ("gprt") is a pair [L,e], where
  L is a list of literals (arbitrary) and e in {0,1}. Again, the meaning is
  "sum_{x in L} x = 0".
*/

/* Simplifying a general parity-constraint P to a parity-constraint (sorted
   by built-in-order or to false in case P is unsatisfiable:
*/
gprt2prt(P) := block([L:first(P), e:second(P), res:{}],
 for x in L do
   if elementp(x,res) then res : disjoin(x,res)
   elseif elementp(-x,res) then (res : disjoin(-x,res), e : 1-e)
   else res : adjoin(x,res),
 if e=1 then
   if emptyp(res) then return(false)
   else block([x:first_element(res)], res : adjoin(-x,disjoin(x,res))),
 listify(res))$

/* Direct translation: */
prt2cl_0(P) :=
 if evenp(sum_l(map(negsignum, listify(P)))) then
   even_parity_wv_cl(map(var_l,P))
 else odd_parity_wv_cl(map(var_l,P))$

/* Translating the sequence of equations, using the list aux of auxiliary
   variables fulfilling length(aux) >= length(P)-2:
*/
prt2cl_aux_1(P,aux) := if length(P) <= 2 then prt2cl_0(P)
 else block([F : prt2cl_0([P[1],P[2],aux[1]])],
  P : rest(P,2),
  while length(P) > 1 do (
    F : append(F, prt2cl_0([P[1],aux[1],aux[2]])),
    P : rest(P), aux : rest(aux)
  ),
  append(F, prt2cl_0([P[1],aux[1]])))$

gen_2xor_fcl(n) := if n<=2 then full_fcl(n) else
 [listn(3*n-4),
  append(prt2cl_aux_1(listn(n), listmn(n+1,2*n-2)),
         prt2cl_aux_1(endcons(-n,listn(n-1)), listmn(2*n-1,3*n-4)))]$

output_gen_2xor_fcl(n,filename) :=
 outputext_fcl(
   sconcat("2 xor-clauses with contradiction, ", n, " basic variables.
c Created by the OKlibrary at ", timedate(), "."),
   gen_2xor_fcl(n),
   filename)$

output_gen_2xor_stdname(n) := output_gen_2xor_fcl(n,
 sconcat("TwoXORclauses-",n,".cnf"))$

/*!
\endhtmlonly
*/
