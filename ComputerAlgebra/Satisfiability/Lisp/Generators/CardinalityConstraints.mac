/* Matthew Gwynne, 15.7.2009 (Swansea) */
/* Copyright 2009 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Satisfiability/Lisp/Generators/CardinalityConstraints.mac
  \brief Generators for cardinality constraints

  Encoding m <= v_1 + ... + v_k <= n for given boolean variables v_1, ..., v_k
  and natural numbers m, n.


Use by

oklib_load("OKlib/ComputerAlgebra/Satisfiability/Lisp/Generators/CardinalityConstraints.mac");

*/

/*!
\htmlonly
*/

oklib_include("OKlib/ComputerAlgebra/DataStructures/Lisp/Lists.mac")$
oklib_include("OKlib/ComputerAlgebra/Hypergraphs/Lisp/SetSystems.mac")$


/* ************************
   * Using unary encoding *
   ************************
*/

/* The algorithm below is from "Efficient CNF Encoding of Boolean Cardinality 
   Constraints" by Olivier Bailleux and Yacine Boufkhad.
   
   Journal : LNCS
   Volume : 2833
   Pages : 102-122
   Publisher : Springer Berlin
   Year : 2003
*/

/* Variables are "ctt(l,i)", meaning the i-th variable at the node whose 
   position is denoted by l where l is a list and each successive 0 or 1 
   in l means traverse the left or right child respectively in the tree
   built up by the translation. That is l = [] is the root, l = [0] is 
   the left node etc.
*/
kill(ctt)$
declare(ctt, noun)$
declare(ctt, posfun)$
ctt_var(l,i) := nounify(ctt)(l,i)$

/* Given a list S of output variables and a list E of input variables, 
   the result is a clause set F enforcing that S is a unary representation of 
   the number of variables set to true in E. That is, if p is the number of 
   variables set to 1 in E for a satisfying assignment, then the first p 
   variables in S are set to 1 and the rest to 0 (in that assignment).
   S must have the same number of variables as E.

   A special property of this clause set is that, given an arbitrary partial
   assignment, unit clause propagation will immediately pick up any forced 
   assignments. 

   For Example:

   cs : cardinality_totalizer_cs([3,4],[1,2])$
   ucp_lpa_0_cs(apply_pa({1},cs));
   [{{-4,2},{-2,4}},[{3}]]
   ucp_lpa_0_cs(apply_pa({2},cs));
   [{{-4,1},{-1,4}},[{3}]]
   ucp_lpa_0_cs(apply_pa({4},cs));
   [{},[{1,2},{3}]]

   etc. Notice how, 3 is forced by UCP (and is being set to 1) in the 
   cases where 1 or 2 is set to 1, as in the unary representation
   3 must be set to 1 if any variable is set to true.

*/
cardinality_totalizer_cs(S,E) := cardinality_totalizer_r_cs(S,E,[])$
cardinality_totalizer_r_cs(S,E, tree_pos) := 
  if length(E) < 1 then {}
  else block(
     [subtree_a : {}, subtree_b : {}, m_a,m_b, S_x, level,
      cs :{},V_a,V_b,m:length(E)],
    /* work out the temporary variables for the current level */
    if length(tree_pos) = 0 then
      S_x : S
    else
      S_x : map(lambda([a], ctt_var(tree_pos,a)),create_list(i,i,1,m)),
    /* work out variable lists for the two children of this node */
    m_a : floor(m / 2), m_b : (m - m_a),
    if m_a > 1 then (
      V_a : map(
        lambda([a],ctt_var(cons(0,tree_pos),a)),
        create_list(i,i,1,m_a)),
      subtree_a : cardinality_totalizer_r_cs([],take_elements(m_a,E), 
        cons(0,tree_pos)))
    else
      V_a : take_elements(m_a,E),
    if m_b > 1 then (
      V_b : map(
        lambda([a],ctt_var(cons(1,tree_pos),a)),
        create_list(i,i,1,m_b)),
      subtree_b : cardinality_totalizer_r_cs([],rest(E,m_a), cons(1,tree_pos)))
    else
      V_b : rest(E,m_a),
    /* generate clauses ensuring correct unary representation for this node */
    for alph : 0 thru m_a do
      for beta : 0 thru m_b do
        for sigma : 0 thru m do
          if (alph + beta) = sigma then block(
            if sigma > 0 then
              cs : adjoin(union(
                if alph > 0 then {-V_a[alph]} else {},
                if beta > 0 then {-V_b[beta]} else {},
                {S_x[sigma]}), cs),
            if sigma < m then
              cs : adjoin(union(
                if alph < m_a then {V_a[alph+1]} else {},
                if beta < m_b then {V_b[beta+1]} else {},
                {-S_x[sigma+1]}),
                cs)
          ),
    if oklib_monitoring then print("Finished level ", tree_pos),
    return(union(subtree_a, subtree_b, cs))
  )$

/* Given a list S of variables together with m, n, produces a clause-set F 
   whose satisfying assignments are those total assignments where the first
   m variables are set to true, and all variables from the (n+1)-th onwards 
   are set to false.

   Given an arbitrary partial assignment, this clause-set can be reduced to
   the empty clause-set (after applying the assignment) by UCP iff no variable
   in the first m variables of S is set to false, and no variable in the last
   (length(S) - n) variables is set to true, otherwise it reduces by UCP to the
   empty clause.
*/
cardinality_comparator_cs(S,m,n) := 
  union(
    map(set,setify(take_elements(m,S))),map(set,map("-",setify(rest(S,n)))))$

/* Given a list E of variables, returns a clause-set F which is satisfied iff 
   between m and n variables of E are set to true.
   
   A special property of this clause set is that, given an arbitrary partial
   assignment, unit clause propagation will immediately pick up any forced 
   assignments. 

   For Example:

   cs : cardinality_cs([1,2],1,1)$
   ucp_lpa_0_cs(apply_pa({1},standardise_fcs(cs_to_fcs(cs))[1][2]));
   [{},[{-4,3},{-2}]]
   ucp_lpa_0_cs(apply_pa({2},standardise_fcs(cs_to_fcs(cs))[1][2]));
   [{},[{-4,3},{-1}]]

   etc. Notice how, providing the constraint 1 + 2 = 1, and then setting
   either 1 or 2 to 1, immediately enforces that 2 or 1 (resp) must be false
   by UCP.
*/
cardinality_cs(E,m,n) := block(
  [S : map(lambda([a],ctt_var([],a)),create_list(i,i,1,length(E)))],
  return(
    union(cardinality_totalizer_cs(S,E),cardinality_comparator_cs(S,m,n))))$

/*!
\endhtmlonly
*/
