/* Oliver Kullmann, 29.11.2007 (Swansea) */
/* Copyright 2007, 2008, 2009, 2010, 2011, 2013 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Satisfiability/Lisp/Generators/Generators.mac
  \brief Basic generators for clause-sets

Use by

oklib_load("OKlib/ComputerAlgebra/Satisfiability/Lisp/Generators/Generators.mac");

*/

/*!
\htmlonly
*/

oklib_include("OKlib/ComputerAlgebra/DataStructures/Lisp/Lists.mac")$
oklib_include("OKlib/ComputerAlgebra/Hypergraphs/Lisp/SetSystems.mac")$
oklib_include("OKlib/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/BasicOperations.mac")$
oklib_include("OKlib/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/PartialAssignments.mac")$
oklib_include("OKlib/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/Substitutions.mac")$
oklib_include("OKlib/ComputerAlgebra/Satisfiability/Lisp/FiniteFunctions/Basics.mac")$
oklib_include("OKlib/ComputerAlgebra/Combinatorics/Lisp/Enumeration/Subsets.mac")$
oklib_include("OKlib/ComputerAlgebra/NumberTheory/Lisp/Auxiliary.mac")$


/* ********************
   * Full clause-sets *
   ********************
*/

/* The full clause-set over variable set or list V: */
full_fcs_v(V) := [if listp(V) then setify(V) else V, all_tass(V)]$
full_cs_v(V) := all_tass(V)$
full_fcl_v(V) := [listify(V), all_tass_l(listify(V))]$
full_cl_v(V) := all_tass_l(listify(V))$
/* We have full_fcs_v(V) = expand_fcs([V,{{}}]) for sets V. */

/* The formal full clause-set with variable set {1,...,n} and all
   possible (full) clauses (also known as "canonical CNF/DNF"): */
full_fcs(n) := full_fcs_v(setn(n))$
full_cs(n) := full_cs_v(setn(n))$
full_fcl(n) := full_fcl_v(setn(n))$
full_cl(n) := full_cl_v(setn(n))$

/* Measures */

nvar_full_fcs(n) := n$

/* List of clause-counts for full_fcs as with ncl_list_f */
ncl_list_full_fcs(n) := [[n,2^n]]$
ncl_full_fcs(n) := 2^n$

deficiency_full_fcs(n) := ncl_full_fcs(n) - nvar_full_fcs(n)$


/* Output */

output_fullcs(n,filename) :=
 outputext_fcl(
   sconcat("Canonical unsatisfiable clause-set with ", n, " variables.
c Created by the OKlibrary at ", timedate(), "."),
   full_fcl(n),
   filename)$

output_fullcs_stdname(n) := output_fullcs(n,
 sconcat("FullCls-",n,".cnf"))$


/* ************************
   * Parity formulas      *
   ************************
*/

/* The repetition-free clause-list of full clauses over variables 1, ..., n,
   such that the satisfying assignments are given by the condition that the
   sum over the values is even resp. odd, that is, the list of full clauses
   having an odd resp. even number of negative literals; the order is
   lexicographical:
*/
even_parity_cl(n) :=
  sublist(all_tass_l(setn(n)),
          lambda([C], oddp(sum_l(map(negsignum, listify(C))))))$
even_parity_fcl(n) := [create_list(i,i,1,n),even_parity_cl(n)]$

odd_parity_cl(n) :=
  sublist(all_tass_l(setn(n)),
          lambda([C], evenp(sum_l(map(negsignum, listify(C))))))$
odd_parity_fcl(n) :=
 [create_list(i,i,1,n),odd_parity_cl(n)]$


/* Expressing the linear system
     x_1 + ... + x_n = y_i for i = 1,...,m
   over the 2-element field {0,1} as a standardised formal clause-set,
   using 1,...,n for x_1,...,x_n, and n+1,...,n+m for y_1,...,y_m:
*/
fullxoreqs_fcl(m,n) := block(
 [IV:create_list(i,i,1,n)],
  return([
    create_list(i,i,1,n+m),
    lappend(create_list(
              fcl2cl(rename_fcl(even_parity_fcl(n+1), endcons(n+i, IV))),
              i,1,m))]))$
/* Now replacing the variable-list [1,...,n+m] by V: */
fullxoreqs_wv_fcl(m,n,V) := rename_fcl(fullxoreqs_fcl(m,n),V)$


/* ********************
   * Order principles *
   ********************
*/

/* Variables are "gt(i,j)", meaning that there is an edge from i to j: */
kill(gt)$
declare(gt, noun)$
declare(gt, posfun)$
gt_var(i,j) := nounify(gt)(i,j)$

/* The list of variables: */
var_ordergt(m) := lappend(map(
  lambda([p], map(lambda([po], apply(gt_var, po)), listify(permutations(p)))),
  colex_ksubsets_l(setn(m), 2)))$

/* The clauses expressing transitivity: */
ordergt_transitivity_ocs(m) :=
  lappend(map(
    lambda([S], map(
      lambda([p], {-gt_var(p[1],p[2]),-gt_var(p[2],p[3]),gt_var(p[1],p[3])}),
      listify(permutations(S)))),
    colex_ksubsets_l(setn(m), 3)))$

ordergt_nocycles_ocs(m) := map(
  lambda([p], comp_sl(map(lambda([po], apply(gt_var, po)), permutations(p)))),
  colex_ksubsets_l(setn(m), 2))$

ordergt_nosource_ocs(m) := block([M : setn(m)],
  create_list(map(lambda([x], gt_var(x,j)), disjoin(j,M)) , j,1,m))$

ordergt_ofcs(m) := [var_ordergt(m), append(ordergt_transitivity_ocs(m),ordergt_nocycles_ocs(m),ordergt_nosource_ocs(m))]$

output_ordergt(m,filename) := block(
 [FF : standardise_fcl(ordergt_ofcs(m))],
  output_fcl_v(
    sconcat("GT problem,
c created by the OKlibrary at ", timedate(),":
c with ", m, " vertices.
c Variables and associated edges:"),
    FF[1],
    filename,
    FF[2]))$
/* Providing a standard name: "OrderGT-m.cnf": */
output_ordergt_stdname(m) := output_ordergt(m,
  sconcat("OrderGT-",m,".cnf"))$


/*!
\endhtmlonly
*/
