/* Oliver Kullmann, 4.9.2008 (Swansea) */
/* Copyright 2008, 2009 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Satisfiability/Lisp/Generators/RamseyProblems.mac
  \brief Generators for %Ramsey-problems

Use by

oklib_load("OKlib/ComputerAlgebra/Satisfiability/Lisp/Generators/RamseyProblems.mac");

*/

/*!
\htmlonly
*/

oklib_load("OKlib/ComputerAlgebra/Graphs/Lisp/Generators.mac")$
oklib_include("OKlib/ComputerAlgebra/Hypergraphs/Lisp/Generators.mac")$
oklib_include("OKlib/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/BasicOperations.mac")$
oklib_include("OKlib/ComputerAlgebra/Hypergraphs/Lisp/Colouring.mac")$
oklib_include("OKlib/ComputerAlgebra/RamseyTheory/Lisp/Ramsey/Numbers.mac")$
oklib_include("OKlib/ComputerAlgebra/Hypergraphs/Lisp/SetSystems.mac")$
oklib_include("OKlib/ComputerAlgebra/Combinatorics/Lisp/Enumeration/Subsets.mac");

/* The boolean ordered formal clause-sets expressing that NR([q,q],r) < n; 
   a satisfying assignments yields a 2-colouring of the hypergraph with
   vertices all r-subsets of {1,...,n}, while the hyperedges are all
   obtained from the q-subsets of {1,...,n} by taking the set of all 
   r-subsets.
   In other words, the clause-set is satisfiable iff one can assign 0 and
   1 to the r-element subsets (the "vertices") of {1,...,n} such that for 
   every q-element subset of {1,...,n} there are two vertices which are
   subsets and which have different values assigned.
   For r=2 we have the interpretation, that the clause-set is satisfiable
   iff there exists an edge-labelling of the K_n with "colours" 1,2  such
   that no q-clique is monochromatic (w.r.t. the edges involved).
   For arbitrary r, instead of K_n^r one considers the K_n^r, the r-graph
   consisting of all r-element subsets of {1,...,n}; satisfying assignments
   are those labellings of the r-element subsets with "colours 1,2" such
   that every q-element subset of {1,...,n} contains one r-element subset
   for each colour.
*/
ramsey2_ofcs(q,r,n) := tcol2sat_ohg2fcl(ramsey_ohg(q,r,n))$

output_ramsey2(q,r,n,filename) := block(
 [FFR : standardise_fcl(ramsey2_ofcs(q,r,n))],
  output_fcl_v(
    sconcat("Ramsey problem: 2 colours, hypergraph edges of size ", r, ", (monochromatic) subsets of size ", q, ", and ", n, " elements."), 
    FFR[1],
    filename,
    FFR[2]))$
output_ramsey2_stdname(q,r,n) := 
 output_ramsey2(q,r,n,sconcat("Ramsey_",q,"_",r,"_",n,".cnf"))$


/* ***********************************
   * Symmetry breaking, first method *
   ***********************************
*/

/* XXX preliminary */
/* Yet only r=2 handled; prerequisite q >= 3. */
ramsey_symbr1_pass(q,n) := block([d : divide(n,q)[1]],
  lunion(create_list(
      block([j:(i-1)*q+1],{colv_var({j,j+1}),-colv_var({j,j+2})}),
      i,1,d)))$

/* XXX preliminary */
/* r=2, q >= 3, n >= 4 */
ramsey_symbr1e_pass(q,n) := adjoin(colv_var({1,4}), ramsey_symbr1_pass(q,n))$


/* ************************************
   * Symmetry breaking, second method *
   ************************************
*/

/* XXX preliminary */
/* Yet only r=2 handled */
ramsey_symbr2_cs(n) := block([eq_edges : [], clique_l : [], rl : [], cliq],
  clique_l : ramsey_symbr2_eqs(n), 
  for eq_edges in clique_l do block ([edges, edge, el, edge_pairs],
    edge_pairs : powerset(eq_edges,2),
    for edge in edge_pairs do block(
      el : map(lambda([e], colv_var(e)),listify(edge)),
      rl : cons({{el[1],-el[2]},{-el[1], el[2]}}, rl)
    )
  ),
  return(lunion(rl)))$

/* Given a natural number n, gives a set of sets of edges in the graph
   with n vertices which can be given equivalent labels in any N_R(p,p;2) < m
   problem for n <= m. */
ramsey_symbr2_eqs(n) := block([m : n, clique_l : [], p : 2, rl : [], cliq],
  while n >= last(ramsey_number([[p+1,p+1],2])) do p : p + 1,
  while m >= last(ramsey_number([[3,3],2])) do 
    if last(ramsey_number([[p,p],2])) <= m then block(
      clique_l : cons(setmn((n-m) + 1, (n-m) + p), clique_l),
      m : m - p
    ) else p : p - 1,
  if oklib_monitor then print("Cliques chosen : ", clique_l),
  return(map(lambda([a],powerset(a,2)),setify(clique_l))))$

/* Given a set of vertices representing the symmetric (k,2) Ramsey problem 
   with n vertices, a hashmap from the variables to their meanings (as
   edges) and a hashmap from variable meanings to their corresponding 
   variables, break symmetries of the clause-set by considering monochromatic 
   p-cliques in the subgraphs of the graph using previous Ramsey numbers. 

   If certain edges should be excluded from the symmetry breaking because they
   have, in some sense, already been considered from some previous symmetry
   breaking, then these can be passed as an additional arguments, as a set of
   variables using "ramsey2_sym_break_rec_r".

   This function returns a set of clauses to add to the clause set.
*/
ramsey2_sym_break_rec(V,f_v,f_vn) := ramsey2_sym_break_rec_r(V,f_v,f_vn,{})$
ramsey2_sym_break_rec_r(V,f_v, f_vn, exc_edges) := block(
  [vertices : {}, cur_ramsey_num : 2, len_vert, p : 2],
  if oklib_monitor then print("Excluded Edges = ", exc_edges),
  vertices : setdifference(
    lunion(map(lambda([v],f_vn(v)), V)),
    lunion(map(lambda([v],f_vn(v)), exc_edges))),
  if oklib_monitor then print("Current Vertices = ", vertices), 
  len_vert : length(vertices),
  if len_vert > 1 then block(
     [edge_vars, edge_var, F_n, sub_hm : sm2hm({}), result_sm],
    while len_vert >= last(ramsey_number([[p+1,p+1],2])) do p : p + 1,
    if oklib_monitor then print("p = ", p),
    edge_vars : map(
      f_v, complete_g(setify(take_elements(p,listify(vertices))))[2]),
    if oklib_monitor then print("p-clique chosen (as edges) = ", edge_vars),
    F_n : ramsey2_sym_break_rec_r(V,f_v, f_vn, union(exc_edges,edge_vars)),
    if oklib_monitor then print("Edge vars = ", edge_vars),
    return(union(F_n,
      map(lambda([a], {a[1], -a[2]}), 
        subset(cartesian_product(edge_vars,edge_vars),
          lambda([b],not is(b[1] = b[2])))))))
  else return({})
)$

/*!
\endhtmlonly
*/
