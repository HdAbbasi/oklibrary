/* Matthew Henderson, 1.10.2008 (Berea) */
/* Copyright 2008 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Satisfiability/Lisp/Generators/LatinSquares.mac
  \brief Generation of Latin square completion problems.

Use by

oklib_load("Transitional/ComputerAlgebra/Satisfiability/Lisp/Generators/LatinSquares.mac");

*/

/*!
\htmlonly
*/

oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/BasicOperations.mac")$
oklib_include("Transitional/ComputerAlgebra/DataStructures/Lisp/HashMaps.mac")$
oklib_include("Transitional/ComputerAlgebra/CombinatorialMatrices/Lisp/Basics.mac")$
oklib_include("Transitional/ComputerAlgebra/DataStructures/Lisp/Lists.mac")$


/* *****************
   * Basic notions *
   *****************
*/

/* A "latin square over H" is a combinatorial matrix A such that the size
   of the row index-set as well as the size of the column index-set is
   equal to the size of the set H, and such that every row and every
   column is a permutation of H: */
lso_p(A,H) := sqscom_p(A,H) and block([n : length(H)],
  is(n = length(A[1])) and
    every_s(lambda([R],length(unique(R))=n),com2ll_r(A)) and
    every_s(lambda([C],length(unique(C))=n),com2ll_c(A)))$
/* Remark: Accordingly, isomorphism of latin squares are isomorphisms of
   combinatorial matrices, and thus treat columns and rows independently.
*/

/* A "latin square" is a square combinatorial matrix A such that scom2com(A)
   is a latin square over A[1]:
*/
ls_p(A) := listp(A) and is(length(A) = 2) and lso_p(scom2com(A),A[1])$
/* We have ls_p(A) = qgrp_p(A). */
/* Remark: This notion of "latin square" follows the general convention,
   though one has to note that the true species of latin squares is given
   by (just) square-sized combinatorial matrices.
   However, since "latin squares" are thus defined as square combinatorial
   matrices, the notion of isomorphisms for them is that of square 
   combinatorial matrices (which glues columns and rows together).
   The notion of a "fully standardised latin square" kind of repairs this
   defect by standardising the first row and the first column.
*/

/* A "standardised latin square" is a square Maxima matrix A such that 
   m2scom(A) is a latin square which has i as the first entry in row i
   (for all i): */
stdls_p(A) := matrixp(A) and block([s : matrix_size(A)],
  is(s[1] = s[2]) and ls_p(m2scom(A)) and (is(s[1] = 0) or 
  is(transpose(A)[1] = create_list(i,i,1,s[1]))))$
/* A "fully standardised latin square" is a standardised latin square which
   has i as the first entry in column i (for all i): */
fstdls_p(A) := stdls_p(A) and block([s : matrix_size(A)],
  is(s[1] = 0) or is(A[1] = create_list(i,i,1,s[1])))$

/* Whether two latin squares are "orthogonal", i.e., whether the super-imposed
   values are always different (as pairs). */
/* Prerequisite: A, B are latin squares. */
ols_p(A,B) := is(A[1] = B[1]) and block([L : listify(A[1])],
  is(length(unique(create_list([A[2](i,j), B[2](i,j)], i,L, j,L))) = length(L)^2))$

/* Whether a list of latin squares is "mutually" (i.e., pairwise) orthogonal:
*/
mols_p(L) := listp(L) and block([n : length(L), is_mols : true],
  for i : 1 thru n unless not is_mols do block([A : L[i]],
    for j : i+1 thru n unless not is_mols do
      is_mols : ols_p(A,L[j])),
  is_mols)$


/* ************
   * Examples *
   ************
*/

LS_cyc3 : matrix(
 [1,2,3],
 [2,3,1],
 [3,1,2]
)$
LS_cyc3_o : matrix(
 [1,3,2],
 [2,1,3],
 [3,2,1]
)$

LS_DK : matrix(
 [1,2,3,4,5,6,7,8,9,10],
 [2,9,4,3,6,5,8,7,10,1],
 [3,10,6,7,4,1,9,5,8,2],
 [4,8,1,10,9,7,2,6,3,5],
 [5,7,8,6,3,10,1,9,2,4],
 [6,1,10,5,8,9,4,2,7,3],
 [7,6,5,8,2,4,3,10,1,9],
 [8,5,2,9,1,3,10,4,6,7],
 [9,4,7,1,10,2,6,3,5,8],
 [10,3,9,2,7,8,5,1,4,6]
)$
LS_DK_o : matrix(
 [1,3,9,6,10,5,8,4,7,2],
 [2,8,5,10,4,7,6,1,3,9],
 [3,6,7,5,9,8,1,2,10,4],
 [4,7,10,1,5,6,9,3,2,8],
 [5,9,2,8,6,4,7,10,1,3],
 [6,2,8,9,1,3,10,5,4,7],
 [7,10,1,3,8,2,4,9,5,6],
 [8,4,6,2,3,1,5,7,9,10],
 [9,1,3,4,7,10,2,8,6,5],
 [10,5,4,7,2,9,3,6,8,1]
)$


/* *****************************************
   * Latin square problems as SAT problems *
   *****************************************
*/

/* Variables are "ls(i,j,k)", meaning that field (i,j) carries number k: */
kill(ls)$
declare(ls, noun)$
declare(ls, posfun)$
ls_var(i,j,k) := nounify(ls)(i,j,k)$

/* The set of variables for latin square formulas of dimension p: */
var_ls(p) := block([N : p],
 setify(create_list(ls_var(i,j,k), i,1,N, j,1,N, k,1,N)))$

/* In the following p denotes the dimension. */

/* Different numbers in each row: */
ls_different_rows(p) := block([N : p],
 setify(create_list({- ls_var(i,j1,k), - ls_var(i,j2,k)}, i,1,N, k,1,N, j1,1,N-1, j2,j1+1,N)))$

/* Different numbers in each column: */
ls_different_columns(p) := block([N : p],
 setify(create_list({- ls_var(i1,j,k), - ls_var(i2,j,k)}, j,1,N, k,1,N, i1,1,N-1, i2,i1+1,N)))$


/* Given box coordinates 1 <= i,j <= p, the list of coordinates of fields: */
ls_positions_box(i,j,p) := block(
 [row_offset : p * (i-1), column_offset : p * (j-1)],
 create_list([row_offset + r, column_offset + c], r,1,p, c,1,p))$

/* Every field carries a number: */
ls_all_fields(p) := block([N : p],
 setify(create_list(setify(makelist(ls_var(i,j,k), k, 1, N)), i,1,N, j,1,N)))$

/* The latin square problem (weak form) as formal clause-set: */
weak_ls(p) := [var_ls(p), 
 union(ls_different_rows(p), ls_different_columns(p), ls_all_fields(p))]$

output_weak_ls(p,filename) := block([FF : standardise_fcs(weak_ls(p))],
  output_fcs_v(
    sconcat("The Latin square problem (weak form) with dimension ", p, "."), 
    FF[1],
    filename,
    FF[2]))$

/* Every row contains all numbers: */
ls_all_rows(p) := block([N : p],
 setify(create_list(setify(makelist(ls_var(i,j,k),j,1,N)), i,1,N, k,1,N)))$

/* Every column contains all numbers: */
ls_all_columns(p) := block([N : p],
 setify(create_list(setify(makelist(ls_var(i,j,k),i,1,N)), j,1,N, k,1,N)))$

/* Every field carries a different number: */
ls_different_fields(p) := block([N : p],
  setify(create_list({-ls_var(i,j,k1), -ls_var(i,j,k2)}, i,1,N, j,1,N, k1,1,N-1, k2,k1+1,N)))$

/* The latin square problem (dual weak form) as formal clause-set: */
dual_weak_ls(p) := [var_ls(p), 
 union(ls_all_rows(p), ls_all_columns(p), ls_different_fields(p))]$

output_dual_weak_ls(p,filename) := block([FF : standardise_fcs(dual_weak_ls(p))],
  output_fcs_v(
    sconcat("The Latin square problem (dual weak form) with dimension ", p, "."), 
    FF[1],
    filename,
    FF[2]))$


/* The strong Latin square problem as formal clause-set: */
strong_ls(p) := [var_ls(p), 
 union(weak_ls(p)[2], dual_weak_ls(p)[2])]$

output_strong_ls(p,filename) := block([FF : standardise_fcs(strong_ls(p))],
  output_fcs_v(
    sconcat("The Latin square problem (strong form) with dimension ", p, "."), 
    FF[1],
    filename,
    FF[2]))$


/* ****************************
   * Orthogonality conditions *
   ****************************
*/

/* Now a partially filled out latin square A is given, and
   a latin square B is sought, which is orthogonal to B.
   Matrix A is given as a square Maxima matrix of dimension p,
   with entries from {1,...,p}, and additionaly 0 for empty
   squares. For the values k in {1,...,p} the set C(k) for
   coordinates (i,j) with A[i,j] = k are computed, and then
   the orthogonality conditions are just that all C(k) must
   be multicoloured (no two different colours).
*/
/* Given A, compute the negative orthogonality conditions as boolean
   clause-set:
*/
orthogonality_cond_ls(A) := block([p : matrix_size(A)[1], a],
  a : l2ary(create_list([],i,1,p)),
  for i : 1 thru p do
    for j : 1 thru p do block([v : A[i,j]],
      if not(v = 0) then
        a[v] : cons([i,j], a[v])),
  return(setify(
    create_list({-ls_var(P[1][1],P[1][2],k2),-ls_var(P[2][1],P[2][2],k2)},
         k,1,p, P,listify(map(listify,powerset(setify(a[k]),2))), k2,1,p))))$
/* The positive orthogonality conditions as formal boolean
   clause-set:
*/
orthogonality_dualcond_ls(A) := block([p : matrix_size(A)[1], a],
  a : l2ary(create_list([],i,1,p)),
  for i : 1 thru p do
    for j : 1 thru p do block([v : A[i,j]],
      if not(v = 0) then
        a[v] : cons([i,j], a[v])),
  return(setify(
    create_list(setify(create_list(ls_var(x[1],x[2],k), x,a[t])),
        t,1,p, k,1,p))))$

orthogonality_strongcond_ls(A) := 
  union(orthogonality_cond_ls(A), orthogonality_dualcond_ls(A))$

row_symmetrybreaking_ls(p) := setify(create_list({ls_var(i,1,i)},i,1,p))$

exluding_solution_ls(A) := block([p : matrix_size(A)[1]],
  setify(create_list(-ls_var(i,j,A[i,j]), i,1,p, j,1,p)))$


/*!
\endhtmlonly
*/

