/* Oliver Kullmann, 29.11.2007 (Swansea) */
/* Copyright 2007, 2008 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Satisfiability/Lisp/ClauseSets/BasicOperations.mac
  \brief Functions for basic operations with clause-sets

Use by

oklib_load("Transitional/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/BasicOperations.mac");

*/

/*!
\htmlonly
*/

oklib_include("Transitional/ComputerAlgebra/Hypergraphs/Lisp/SetSystems.mac")$
oklib_include("Transitional/ComputerAlgebra/DataStructures/Lisp/HashMaps.mac")$

/* Guaranteed to be included: */
oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/Statistics.mac")$
oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/PartialAssignments.mac")$


/* **************************
   * Variables and literals *
   **************************
*/

/*
 A "boolean variable" might be any expression x, such that "- x" is defined
 and yields a different object, and such that abs(x) = x.
*/

v_p(v) := 
 is(is(v>0)=true) and 
 is(is(-v<0)=true) and 
 is(is(-v#v)=true) and 
 is(is(abs(v)=v)=true) and 
 is(is(abs(-v)=v)=true) and 
 is(is(--v=v)=true)$

/* 
 A "boolean literal" might be a boolean variable "v" or a negated boolean
 variable "-v".
*/

l_p(x) := 
 is(is(--x=x)=true) and 
 if is(x>0)=true then 
   is(is(abs(x)=x)=true) and v_p(x) 
 elseif is(x<0)=true then 
   is(is(abs(x)=-x)=true) and v_p(-x) 
 else false$

/* The underlying variable of a literal: */
var_l(x) := abs(x)$

/* The sign of a literal in {-1,+1}: */
sign_l(x) := block([s : sign(x)], if s = pos then 1 else -1)$

/* The literals for a set of variables: */
literals_v(V) := block([L : listify(V)],
  setify(append(L,-L)))$


/* ***********
   * Clauses *
   ***********
*/

/* complementation of a set of literals */
comp_sl(L) := map("-", L)$

/*
 A "boolean clause" is a set C of boolean literals such that
 C and comp_sl(C) have empty intersection.
*/

c_p(C) := setp(C) and every(l_p,C) and emptyp(intersection(C,comp_sl(C)))$

/* Tests whether two literal sets contain a clashing literal. */
clashp(A,B) := not emptyp(intersection(A,comp_sl(B)))$

/* The set of variables in a clause */
var_c(C) := map(var_l, C)$

/* The positive literals in a clause */
pospart_c(C) := subset(C, lambda([x], is(x>0)))$
/* The negative literals in a clause */
negpart_c(C) := subset(C, lambda([x], is(x<0)))$


/* ***************
   * Clause-sets *
   ***************
*/

/*
 A "boolean clause-set" is a set of boolean clauses.
*/

cs_p(F) := setp(F) and every(c_p,F)$

/*
 A "formal boolean clause-set" is a pair [V, F], where V is a set of
 variables, while F is a clause-set using only variables from V
 (that is, with var_cs(F) <= V).
*/

fcs_p(FF) := listp(FF) and is(length(FF) = 2) and setp(FF[1]) and
  every(v_p,FF[1]) and cs_p(FF[2]) and subsetp(var_cs(FF[2]),FF[1])$

/* The variables in a clause-set: */
var_cs(F) := if emptyp(F) then {} else xreduce(union, map(var_c, F))$
/* The variables in a formal clause-set: */
var_cs_f(FF) := FF[1]$

/* the clause-set of a formal clause-set */
clauses_f(FF) := FF[2]$

/* clause-sets to formal clause-sets */
cs_to_fcs(F) := [var_cs(F), F]$
fcs2cs(FF) := second(FF)$


/* *****************************
   * Substitution and renaming *
   *****************************
*/

/* Replace literal x via hash table h (by another literal),
   where h maps var_l(x) to some literal; if var_l(x) is
   not in the domain of the hash-map, then false resp. -false
   is returned. */
substitute_l(x,h) := if x > 0 then ev_hm(h,x) else -ev_hm(h,-x)$

/* Substitute literals in clause C via hash table h;
   possibly a pseudo-clause with clashing literals is created. */
substitute_c(C,h) := 
 map(
  lambda([x],block([y:substitute_l(x,h)], 
    if elementp(y,{false,-false}) then x else y)),
  C)$

/* Substitute literals in clause-set F via hash table h (possibly
   creating pseudo-clauses with clashing literals). */
substitute_cs(F,h) := map(lambda([C],substitute_c(C,h)), F)$

/* Given a list of literals of the same size as the set
   of variables of a formal clause-set, rename the formal
   clause-set, using the natural correspondence given by
   the given order on the set of variables. 
*/
rename_fcs(FF,L) := block(
 [V : listify(FF[1]), h],
  h : osm2hm(map(lambda([a,b],[a,b]),V,L)),
  [setify(abs(L)), substitute_cs(FF[2],h)])$

/* Translating variable names of a formal clause-set into natural numbers;
   outputs a pair consisting of the translated formal clause-set and
   the list of old variable names (positions corresponding to new
   variable-numbers) */
standardise_fcs(FF) := block([L : create_list(i,i,1,nvar_f(FF))],
 [rename_fcs(FF,L), listify(var_cs_f(FF))])$

/* Make a list of formal clause-sets variable-disjoint, using
   variables from 1 on. Returns a pair consisting of the renamed
   list and the total number n of variables (so the next free
   variable is n+1). */
make_vardisjoint_fcs(LFF) := block([index : 0, result : []],
  for FF in LFF do block([n : nvar_f(FF)],
    result : endcons(rename_fcs(FF,create_list(index + i, i,1,n)), result),
    index : index + n),
  return([result, index]))$


/* ***********************************
   * Selecting parts of a clause-set *
   ***********************************
*/

/* All clauses of length k of a clause-set. */
scls_k(F,k) := subset(F, lambda([C], is(length(C) = k)))$

/* All clauses of a clause-set containing a literal. */
scls_l(F,l) := subset(F, lambda([C], elementp(l,C)))$

/* All clauses of a clause-set containing a variable. */
scls_v(F,v) := subset(F, lambda([C], elementp(v,var_c(C))))$
/* More generally, all clauses containing some of a given set of variables: */
scls_V(F,V) := subset(F, lambda([C], not disjointp(var_c(C),V)))$

/* *****************************************
   * Printing clause-sets in Dimacs-format *
   *****************************************
*/

/* output a literal */
dimacs_l_string(x) := sconcat(x," ")$

/* output a clause */
dimacs_c_string(C) := xreduce(sconcat, map(dimacs_l_string, C))$

/* print a string without line-breaks */
print_nlb(s) := block([old_linel : linel],
  linel : slength(s) + 1,
  print(s),
  linel : old_linel)$

/* print a formal clause-set in Dimacs format */
print_cs_f(comment,FF) := (
  print_nlb(sconcat("c ", comment)),
  print_nlb(sconcat("p cnf ", nvar_f(FF), " ", length(clauses_f(FF)))),
  for C in clauses_f(FF) do print_nlb(sconcat(dimacs_c_string(C), "0"))
)$

/* output formal clause-set FF to file n */
output_cs_f(comment,FF,n) := with_stdout(n, print_cs_f(comment,FF))$

/* print a formal clause-set in Dimacs format, together with a map
   which explains the variable meaning */
print_cs_f_v(comment,FF,varlist) := (
  print_nlb(sconcat("c ", comment)),
  for i from 1 thru length(varlist) do print_nlb(sconcat("c ", i, " : ", varlist[i])),
  print_nlb(sconcat("p cnf ", nvar_f(FF), " ", length(clauses_f(FF)))),
  for C in clauses_f(FF) do print_nlb(sconcat(dimacs_c_string(C), "0"))
)$

/* output formal clause-set FF to file n, using a variable-list */
output_cs_f_v(comment,FF,n,varlist) := 
  with_stdout(n, print_cs_f_v(comment,FF,varlist))$


/*!
\endhtmlonly
*/
