/* Oliver Kullmann, 29.11.2007 (Swansea) */
/* Copyright 2007 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Satisfiability/Lisp/ClauseSets/BasicOperations.mac
  \brief Functions for basic operations with clause-sets

Use by

load("$OKPLATFORM/OKsystem/Transitional/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/BasicOperations.mac");

where $OKPLATFORM has to be replaced by the path to the OKplatform directory.

Needs 

 - ComputerAlgebra/Hypergraphs/Lisp/SetSystems.mac.

*/

/*!
\htmlonly
*/

/* **************************
   * Variables and literals *
   **************************
*/

/*
 A "boolean variable" might be any expression x, such that "- x" is defined
 and yields a different object, and such that abs(x) = x.
*/

/* 
 A "boolean literal" might be a boolean variable "v" or a negated boolean
 variable "-v".
*/

/* the underlying variable of a literal */
var_l(x) := abs(x)$

/* ***************************
   * Clauses and clause-sets *
   ***************************
*/

/* complementation of a set of literals */
comp_sl(L) := map(lambda([l], -l), L)$

/*
 A "boolean clause" is a set C of boolean literals such that
 C and comp_sl(C) have empty intersection.
*/

var_c(C) := map(var_l, C)$

/*
 A "boolean clause-set" is a set of boolean clauses.
*/

/*
 A "formal boolean clause-set" is a pair [V, F], where V is a set of
 variables, while F is a clause-set using only variables from V
 (that is, with var_cs(F) <= V).
*/

/* the variables in a clause-set */
var_cs(F) := if emptyp(F) then {} else xreduce(union, map(var_c, F))$
/* the variables in a formal clause-set */
var_cs_f(FF) := FF[1]$

/* number of variables of a formal clause-set */
nvar_f(FF) := length(var_cs_f(FF))$

/* the clause-set of a formal clause-set */
clauses_f(FF) := FF[2]$

/* complementation (literal-wise) of a clause-set */
comp_cs(F) := map(comp_sl, F)$


/* ***********************
   * Partial assignments *
   ***********************
*/

/*
 A "partial boolean assignment" is a boolean clause, interpreted
 as setting its elements to true.
*/

/* apply a partial assignment to a boolean clause-set */
apply_pa(phi,F) := setdifference2(remove_non_disjoint(F,phi), comp_sl(phi))$
/* apply a partial assignment to a formal boolean clause-set */
apply_pa_f(phi,FF) := [setdifference(var_cs_f(FF), var_c(phi)),
  apply_pa(phi, clauses_f(FF))]$


/* *****************************************
   * Printing clause-sets in Dimacs-format *
   *****************************************
*/

/* output a literal */
dimacs_l_string(x) := sconcat(x," ")$

/* output a clause */
dimacs_c_string(C) := xreduce(sconcat, map(dimacs_l_string, C))$

/* print a string without line-breaks */
print_nlb(s) := block([old_linel : linel],
  linel : slength(s) + 1,
  print(s),
  linel : old_linel)$

/* print a formal clause-set in Dimacs format */
print_cs_f(comment,FF) := (
  print_nlb(sconcat("c ", comment)),
  print_nlb(sconcat("p cnf ", nvar_f(FF), " ", length(clauses_f(FF)))),
  for C in clauses_f(FF) do print_nlb(sconcat(dimacs_c_string(C), "0"))
)$

/* output formal clause-set FF to file n */
output_cs_f(comment,FF,n) := with_stdout(n, print_cs_f(comment,FF))$

/*!
\endhtmlonly
*/
