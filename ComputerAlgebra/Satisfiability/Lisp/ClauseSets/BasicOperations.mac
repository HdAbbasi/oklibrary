/* Oliver Kullmann, 29.11.2007 (Swansea) */
/* Copyright 2007, 2008 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Satisfiability/Lisp/ClauseSets/BasicOperations.mac
  \brief Functions for basic operations with clause-sets

Use by

oklib_load("Transitional/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/BasicOperations.mac");

*/

/*!
\htmlonly
*/

oklib_include("Transitional/ComputerAlgebra/Hypergraphs/Lisp/SetSystems.mac")$
oklib_include("Transitional/ComputerAlgebra/DataStructures/Lisp/HashMaps.mac")$

/* Guaranteed to be included: */
oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/Statistics.mac")$


/* **************************
   * Variables and literals *
   **************************
*/

/*
 A "boolean variable" might be any expression x, such that "- x" is defined
 and yields a different object, and such that abs(x) = x.
*/

/* 
 A "boolean literal" might be a boolean variable "v" or a negated boolean
 variable "-v".
*/

/* the underlying variable of a literal */
var_l(x) := abs(x)$

/* The sign of a literal in {-1,+1}. */
sign_l(x) := block([s : sign(x)], if s = pos then 1 else -1)$

/* the literals for a set of variables */
literals_v(V) := block([L : listify(V)],
  setify(append(L,-L)))$


/* ***********
   * Clauses *
   ***********
*/

/* complementation of a set of literals */
comp_sl(L) := map(lambda([l], -l), L)$

/*
 A "boolean clause" is a set C of boolean literals such that
 C and comp_sl(C) have empty intersection.
*/

/* Tests whether two literal sets contain a clashing literal. */
clashp(A,B) := not emptyp(intersection(A,comp_sl(B)))$

/* The set of variables in a clause */
var_c(C) := map(var_l, C)$

/* The positive literals in a clause */
pospart_c(C) := subset(C, lambda([x], is(x>0)))$
/* The negative literals in a clause */
negpart_c(C) := subset(C, lambda([x], is(x<0)))$


/* ***************
   * Clause-sets *
   ***************
*/

/*
 A "boolean clause-set" is a set of boolean clauses.
*/

/*
 A "formal boolean clause-set" is a pair [V, F], where V is a set of
 variables, while F is a clause-set using only variables from V
 (that is, with var_cs(F) <= V).
*/

/* the variables in a clause-set */
var_cs(F) := if emptyp(F) then {} else xreduce(union, map(var_c, F))$
/* the variables in a formal clause-set */
var_cs_f(FF) := FF[1]$

/* the clause-set of a formal clause-set */
clauses_f(FF) := FF[2]$

/* clause-sets to formal clause-sets */
cs_to_fcs(F) := [var_cs(F), F]$


/* *****************************
   * Substitution and renaming *
   *****************************
*/

/* Replace literal x via hash table h (by another literal),
   where h maps var_l(x) to some literal; if var_l(x) is
   not in the domain of the hash-map, then false resp. -false
   is returned. */
substitute_l(x,h) := if x > 0 then get_hash(x,h) else -get_hash(-x,h)$

/* Substitute literals in clause C via hash table h;
   possibly a pseudo-clause with clashing literals is created. */
substitute_c(C,h) := 
 map(
  lambda([x],block([y:substitute_l(x,h)], 
    if elementp(y,{false,-false}) then x else y)),
  C)$

/* Substitute liteals in clause-set F via hash table h (possibly
   creating pseudo-clauses with clashing literals). */
substitute_cs(F,h) := map(lambda([C],substitute_c(C,h)), F)$

/* Given a list of variables of the same size as the set
   of variables of a formal clause-set, rename the formal
   clause-set, using the natural correspondence given by
   the given order on the set of variables. 
*/
rename_fcs(FF,L) := block(
 [V : listify(FF[1]), h],
  h : create_hash_map(setify(makelist([V[i],L[i]], i,1,length(V)))),
  [setify(L), substitute_cs(FF[2],h)])$

/* Translating variable names of a formal clause-set into natural numbers;
   outputs a pair consisting of the translated formal clause-set and
   the list of old variable names (positions corresponding to new
   variable-numbers) */
standardise_fcs(FF) := block([L : makelist(i,i,1,nvar_f(FF))],
 [rename_fcs(FF,L), listify(var_cs_f(FF))])$

/* Make a list of formal clause-sets variable-disjoint, using
   variables from 1 on. Returns a pair consisting of the renamed
   list and the total number n of variables (so the next free
   variable is n+1). */
make_vardisjoint_fcs(LFF) := block([index : 0, result : []],
  for FF in LFF do block([n : nvar_f(FF)],
    result : endcons(rename_fcs(FF,makelist(index + i, i,1,n)), result),
    index : index + n),
  return([result, index]))$


/* ***********************************
   * Selecting parts of a clause-set *
   ***********************************
*/

/* all clauses of length k of a clause-set */
scls_k(F,k) := subset(F, lambda([C], is(length(C) = k)))$

/* All clauses of a clause-set containing a literal */
scls_l(F,l) := subset(F, lambda([C], elementp(l,C)))$


/* ***********************
   * Partial assignments *
   ***********************
*/

/*
 A "partial boolean assignment" is a boolean clause, interpreted
 as setting its elements to true.
*/

/* The variables in a partial assignment. */
var_pa(phi) := var_c(phi)$

/* Restricting a partial assignment phi to a set V of variables. */
restr_pa(phi,V) := subset(phi, lambda([x], elementp(var_l(x),V)))$

/* apply a partial assignment to a boolean clause-set */
apply_pa(phi,F) := setdifference2(remove_non_disjoint(F,phi), comp_sl(phi))$
/* apply a partial assignment to a formal boolean clause-set */
apply_pa_f(phi,FF) := [setdifference(var_cs_f(FF), var_c(phi)),
  apply_pa(phi, clauses_f(FF))]$

/* The set of satisfied clauses for a partial assignment w.r.t. a clause-set */
sat_pa(phi,F) := subset(F, lambda([C], is(apply_pa(phi,{C}) = {})))$

/* Test for a satisfying assignment w.r.t. a clause-set */
satisfyingpap(phi,F) := is(sat_pa(phi,F) = F)$

/* The set of satisfied, falsified, untouched and critical (original) clauses
   for a partial assignment w.r.t. a clause-set. */
analyse_pa(phi,F) := block([V : var_c(phi), s : {}, f : {}, u : {}, c : {}],
 for C in F do block([r : apply_pa(phi,{C})],
  if r = {} then s : adjoin(C,s)
  elseif r = {{}} then f : adjoin(C,f)
  elseif disjointp(var_c(C), V) then u : adjoin(C,u) 
  else c : adjoin(C,c)),
 return([s,f,u,c]))$

/* The set of all partial assignments over a set of variables */
all_pass(V) := if emptyp(V) then {{}} else
 block([e : choose_element(V), S],
  S : all_pass(disjoin(e,V)),
  return(union(S, map(lambda([phi],adjoin(e,phi)),S),map(lambda([phi],adjoin(-e,phi)),S))))$
   


/* *****************************************
   * Printing clause-sets in Dimacs-format *
   *****************************************
*/

/* output a literal */
dimacs_l_string(x) := sconcat(x," ")$

/* output a clause */
dimacs_c_string(C) := xreduce(sconcat, map(dimacs_l_string, C))$

/* print a string without line-breaks */
print_nlb(s) := block([old_linel : linel],
  linel : slength(s) + 1,
  print(s),
  linel : old_linel)$

/* print a formal clause-set in Dimacs format */
print_cs_f(comment,FF) := (
  print_nlb(sconcat("c ", comment)),
  print_nlb(sconcat("p cnf ", nvar_f(FF), " ", length(clauses_f(FF)))),
  for C in clauses_f(FF) do print_nlb(sconcat(dimacs_c_string(C), "0"))
)$

/* output formal clause-set FF to file n */
output_cs_f(comment,FF,n) := with_stdout(n, print_cs_f(comment,FF))$

/* print a formal clause-set in Dimacs format, together with a map
   which explains the variable meaning */
print_cs_f_v(comment,FF,varlist) := (
  print_nlb(sconcat("c ", comment)),
  for i from 1 thru length(varlist) do print_nlb(sconcat("c ", i, " : ", varlist[i])),
  print_nlb(sconcat("p cnf ", nvar_f(FF), " ", length(clauses_f(FF)))),
  for C in clauses_f(FF) do print_nlb(sconcat(dimacs_c_string(C), "0"))
)$

/* output formal clause-set FF to file n, using a variable-list */
output_cs_f_v(comment,FF,n,varlist) := 
  with_stdout(n, print_cs_f_v(comment,FF,varlist))$


/*!
\endhtmlonly
*/
