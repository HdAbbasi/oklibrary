/* Oliver Kullmann, 29.11.2007 (Swansea) */
/* Copyright 2007 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Satisfiability/Lisp/ClauseSets/BasicOperations.mac
  \brief Functions for basic operations with clause-sets

Use by

oklib_load("Transitional/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/BasicOperations.mac");

*/

/*!
\htmlonly
*/

oklib_include("Transitional/ComputerAlgebra/Hypergraphs/Lisp/SetSystems.mac")$

/* **************************
   * Variables and literals *
   **************************
*/

/*
 A "boolean variable" might be any expression x, such that "- x" is defined
 and yields a different object, and such that abs(x) = x.
*/

/* 
 A "boolean literal" might be a boolean variable "v" or a negated boolean
 variable "-v".
*/

/* the underlying variable of a literal */
var_l(x) := abs(x)$

/* ***************************
   * Clauses and clause-sets *
   ***************************
*/

/* complementation of a set of literals */
comp_sl(L) := map(lambda([l], -l), L)$

/*
 A "boolean clause" is a set C of boolean literals such that
 C and comp_sl(C) have empty intersection.
*/

var_c(C) := map(var_l, C)$

/*
 A "boolean clause-set" is a set of boolean clauses.
*/

/*
 A "formal boolean clause-set" is a pair [V, F], where V is a set of
 variables, while F is a clause-set using only variables from V
 (that is, with var_cs(F) <= V).
*/

/* the variables in a clause-set */
var_cs(F) := if emptyp(F) then {} else xreduce(union, map(var_c, F))$
/* the variables in a formal clause-set */
var_cs_f(FF) := FF[1]$

/* the clause-set of a formal clause-set */
clauses_f(FF) := FF[2]$

/* clause-sets to formal clause-sets */
cs_to_fcs(F) := [var_cs(F), F]$


/* complementation (literal-wise) of a clause-set */
comp_cs(F) := map(comp_sl, F)$


/* ************
   * Renaming *
   ************
*/

load(graphs)$ /* needed for the hash-table */

/* rename literal x via hash table h */
rename_literal(x,h) := if x > 0 then get_hash(x,h) else -get_hash(-x,h)$

/* rename clause C via hash table h */
rename_clause(C,h) := map(lambda([x],rename_literal(x,h)), C)$

/* Translating variable names of a formal clause-set into natural numbers; 
   outputs a pair consisting of the translated formal clause-set and
   the list of old variable names (positions corresponding to new
   variable-numbers */
standardise_fcs(FF) := block([h : hash_table(), V : listify(FF[1])],
 for i : 1 thru length(V) do set_hash(V[i], h, i),
 return([[setn(length(V)), map(lambda([C],rename_clause(C,h)), FF[2])],V]))$


/* ************
   * Measures *
   ************
*/

/* number of variables of a formal clause-set */
nvar_f(FF) := length(var_cs_f(FF))$

/* number of clauses of a formal  clause-set */
ncl_f(FF) := length(clauses_f(FF))$

/* number of literal occurrences in a clause-set */
nlitocc(F) := block([s : 0],
 for C in F do s : s + length(C), return(s))$
 
/* the list of pairs
   [occurring clause-lengths, number of clauses of this length],
   sorted by ascending clause-length.
*/
ncl_list_f(FF) := block([counts : make_array(fixnum, length(FF[1])+1), res : []],
 for C in FF[2] do block([l : length(C)],
  counts[l] : counts[l] + 1),
 for i : 0 thru length(FF[1]) do
  if counts[i] # 0 then res : endcons([i, counts[i]], res),
 return(res))$


/* ***********************
   * Partial assignments *
   ***********************
*/

/*
 A "partial boolean assignment" is a boolean clause, interpreted
 as setting its elements to true.
*/

/* apply a partial assignment to a boolean clause-set */
apply_pa(phi,F) := setdifference2(remove_non_disjoint(F,phi), comp_sl(phi))$
/* apply a partial assignment to a formal boolean clause-set */
apply_pa_f(phi,FF) := [setdifference(var_cs_f(FF), var_c(phi)),
  apply_pa(phi, clauses_f(FF))]$


/* *****************************************
   * Printing clause-sets in Dimacs-format *
   *****************************************
*/

/* output a literal */
dimacs_l_string(x) := sconcat(x," ")$

/* output a clause */
dimacs_c_string(C) := xreduce(sconcat, map(dimacs_l_string, C))$

/* print a string without line-breaks */
print_nlb(s) := block([old_linel : linel],
  linel : slength(s) + 1,
  print(s),
  linel : old_linel)$

/* print a formal clause-set in Dimacs format */
print_cs_f(comment,FF) := (
  print_nlb(sconcat("c ", comment)),
  print_nlb(sconcat("p cnf ", nvar_f(FF), " ", length(clauses_f(FF)))),
  for C in clauses_f(FF) do print_nlb(sconcat(dimacs_c_string(C), "0"))
)$

/* output formal clause-set FF to file n */
output_cs_f(comment,FF,n) := with_stdout(n, print_cs_f(comment,FF))$

/* print a formal clause-set in Dimacs format, together with a map
   which explains the variable meaning */
print_cs_f_v(comment,FF,varlist) := (
  print_nlb(sconcat("c ", comment)),
  for i from 1 thru length(varlist) do print_nlb(sconcat("c ", i, " : ", varlist[i])),
  print_nlb(sconcat("p cnf ", nvar_f(FF), " ", length(clauses_f(FF)))),
  for C in clauses_f(FF) do print_nlb(sconcat(dimacs_c_string(C), "0"))
)$

/* output formal clause-set FF to file n, using a variable-list */
output_cs_f_v(comment,FF,n,varlist) := 
  with_stdout(n, print_cs_f_v(comment,FF,varlist))$


/*!
\endhtmlonly
*/
