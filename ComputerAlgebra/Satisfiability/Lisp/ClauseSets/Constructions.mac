/* Oliver Kullmann, 23.2.2008 (Swansea) */
/* Copyright 2008 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Satisfiability/Lisp/ClauseSets/Constructions.mac
  \brief basic constructions for clause-sets

Use by

oklib_load("Transitional/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/Constructions.mac");

*/

/*!
\htmlonly
*/

oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/BasicOperations.mac")$
oklib_include("Transitional/ComputerAlgebra/Hypergraphs/Lisp/SetSystems.mac")$


/* **************************
   * Syntactical operations *
   **************************
*/

/* Complementation (literal-wise) of a clause-set or clause-list */
comp_cs(F) := map(comp_sl, F)$


/* **********************
   * Logical operations *
   **********************
*/

/* The natural representation of the "and" of two clause-sets as cnf's
   (as n-ary operation) */
and_cs([L]) := apply(union,L)$

/* All non-clashing unions of the clauses of two given clause-sets, which
   represents the "or" of the clause-sets as cnf's. */
or_cs2(F1,F2) := 
 map(list_sets_union,
  subset(cartesian_product(F1,F2), lambda([P],not clashp(P[1],P[2]))))$
/* As n-ary operation */
or_cs([L]) := block([l : length(L)],
 if l = 0 then {{}} elseif l = 1 then L[1] 
 else apply(or_cs, cons(or_cs2(L[1],L[2]), rest(L,2))))$

/* The natural DNF-representation of a clause-set F as CNF */
dual_cs(F) := apply(or_cs,
 makelist(setify(makelist({x},x,listify(C))), C,listify(F)))$
/* Subsumption elimination applied to the result yields the set of
   all prime implicants (all minimal satisfying partial assignments). */

/* The natural negation of a clause-set */
neg_cs(F) := dual_cs(comp_cs(F))$


/* ****************************
   * Combinatorial operations *
   ****************************
*/

vardisjoint_sum_fcs([LFF]) := block([VD : make_vardisjoint_fcs(LFF)],
 [setn(VD[2]), list_sets_union(map(clauses_f,VD[1]))])$

vardisjoint_full_gluing(FF1,FF2) := block(
 [vd : make_vardisjoint_fcs([FF1, FF2]), GG1,GG2, n],
  [GG1,GG2] : vd[1], n : vd[2],
  return([if FF1[2] = {} and FF2[2] = {} then {} else setn(n+1), 
          union(add_element(n+1,GG1[2]), add_element(-(n+1),GG2[2]))]))$

/*!
\endhtmlonly
*/

