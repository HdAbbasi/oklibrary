/* Oliver Kullmann, 29.11.2007 (Swansea) */
/* Copyright 2007 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Satisfiability/Lisp/ClauseSets/Generators.mac
  \brief Functions for basic operations with clause-sets

Use by

load("$OKPLATFORM/OKsystem/Transitional/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/Generators.mac");

where $OKPLATFORM has to be replaced by the path to the OKplatform directory.

Needs 

 - ComputerAlgebra/Hypergraphs/Lisp/Generators.mac
 - ComputerAlgebra/Satisfiability/Lisp/ClauseSets/BasicOperations.mac.

*/

/*!
\htmlonly
*/

/* ********************
   * Full clause-sets *
   ********************
*/

/* a formal full clause set with variable set {1,...,n} and all possible (full) clauses */
full_fcs(n) := if n=0 then [{}, {{}}] else [setn(n), map(setify, apply(cartesian_product, makelist({-i,i},i,1,n)))];


/* ************************
   * Pigeon-hole formulas *
   ************************
*/

/* Variables are "php(i,j)", meaning that pigeon i is in hole j */
declare(php, noun);
declare(php, posfun);

/* The set of variables for the pigeonhole formulas with m pigeons and n holes */
var_php(m,n) := block([L : []],
 for i : 1 thru m do
  for j : 1 thru n do
   L : append(L, [php(i,j)]),
 setify(L));

/* In the following m denotes the number of pigeons, n the number of holes */

/* no two pigeon in the same hole */
pigeons_different_holes(m,n) := block([L : []],
 for i : 1 thru m-1 do
  for j : i+1 thru m do
   for k : 1 thru n do
    L : append(L, [{- php(i,k), - php(j,k)}]),
 setify(L));

/* every pigeon in one hole */
pigeons_in_holes(m,n) := block([L : []],
 for i : 1 thru m do
  L : append(L, [setify(makelist(php(i,j), j, 1, n))]),
 setify(L));

/* the weak pigeon formula as formal clause-set */
weak_php(m,n) := [var_php(m,n), 
 union(pigeons_different_holes(m,n), pigeons_in_holes(m,n))];

output_weak_php(m,n,filename) := 
  output_cs_f(
    sconcat("The weak pigeonhole principle: ", m, " pigeons, ", n, " holes."), 
    weak_php(m,n),
    filename);


/* ***************************
   * Van der Waerden problem *
   ***************************
*/

/* Boolean clause-sets, wholes solutions are the partitionings of {1,...,n}
 into two parts such that none of them contains an arithmetic progression
 of size k */
VanDerWaerden2_cs_f(k,n) := block([G : ArithmeticProgressions(k,n)], [G[1], union(G[2], comp_cs(G[2]))]);

output_VanDerWaerden2_cs_f(k,n,filename) := 
  output_cs_f(
    sconcat("Van der Waerden problem: 2 parts, arithmetic progressions of size ", k, ", ", n, " elements."), 
    VanDerWaerden2_cs_f(k,n),
    filename);

/*!
\endhtmlonly
*/
