/* Oliver Kullmann, 30.4.2008 (Guangzhou) */
/* Copyright 2008 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Satisfiability/Lisp/MinimalUnsatisfiability/data/uhit_def.mac
  \brief Classification of unsatisfiable hitting clause-sets in dependency on the deficiency, only considering clause-sets which are reduced w.r.t. singular DP-reduction

  Only small datasets here; others are excluded from for example "uhit_def_4.mac"
  for deficiency 4.

Use by

oklib_load("Transitional/ComputerAlgebra/Satisfiability/Lisp/MinimalUnsatisfiability/data/uhit_def.mac");

*/

/*!
\htmlonly
*/

oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/Generators/Generators.mac")$
oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/Symmetries/Symmetries.mac")$
oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/BasicOperations.mac")$
oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/Constructions.mac")$
oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/ConflictCombinatorics/HittingClauseSets.mac")$
oklib_include("Transitional/ComputerAlgebra/Hypergraphs/Lisp/tests/SetSystems.mac")$

kill(uhit_def)$

/* The list of available deficiencies. */
uhit_def[0,"info"] : makelist(k,k,1,12)$

/* For a given deficiency k, the info-field uhit_def[k,"info] contains:
 - true if the classification is complete, and false/unknown otherwise
 - the smallest possible n resp. a lower bound
 - the largest possible n resp. an upper bound
 - the list of available n-values, represented as pairs [n,true/false/unknown],
   stating whether or not for this n the list is complete.
*/
/* Complete means that every possible isomorphism type is
   represented (exactly once). */
/* "false" here means that definitely some cases are missing. */


/* Deficiency 1 */

uhit_def[1,"info"] : [true,0,0,[[0,true]]]$
uhit_def[1,0] : [{{}}]$


/* Deficiency 2 */

uhit_def[2,"info"] : [true,2,3,[[2,true],[3,true]]]$
uhit_def[2,2] : [musatd2(2)[2]]$
uhit_def[2,3] : [max_var_hitting_def(2)[2]]$


/* Deficiency 3 */

uhit_def[3,"info"] : [unknown,3,inf,[[3,true],[4,true],[5,unknown],[6,unknown],[7,unknown]]]$
uhit_def[3,3] : [
 {{1,2,3},{-1,2,3},{1,-2,3},{-1,-2,3},{1,-3},{-1,-3}},
 {{-3,-2},{-3,-1,2},{-3,1,2},{-2,-1,3},{-1,2,3},{1,3}},
 {{-3,-2},{-3,-1,2},{-3,1,2},{-2,-1,3},{-2,1,3},{2,3}}
]$
uhit_def[3,4] : [
 {{-4,-3},{-4,-1,2,3},{-4,1,2,3},{-3,-2,4},{-2,-1,3},{-2,1,3},{2,4}},
 {{-4,-3},{-4,-1,2,3},{-4,1,2,3},{-3,4},{-2,-1,3},{-2,1,3},{2,3,4}},
 {{-4,-3},{-4,-1,2,3},{-4,1,3},{-3,-2,-1,4},{-2,-1,3},{-2,1,4},{2,4}},
 {{-4,-3},{-4,2,3},{-3,-2,1,4},{-3,-1,4},{-2,3},{-1,2,3,4},{1,2,4}},
 {{-4,-3},{-4,2,3},{-3,-1,4},{-3,1,4},{-2,-1,3},{-2,1,3},{2,3,4}},
 {{-4,-3,-2},{-4,-2,3},{-3,-2,-1,4},{-3,-2,1,4},{-2,3,4},{-1,2},{1,2}},
 {{-4,-3,-2},{-4,2},{-3,-1,4},{-3,1,4},{-2,-1,3},{-2,1,3},{2,3,4}},
 {{-4,-3,-1},{-4,-3,1,2},{-4,-2,-1,3},{-4,-2,1},{-4,2,3},{-3,4},{3,4}},
 {{1,2,3,4},{-1,2},{-2,3},{-3,1},{-1,-2,-3,4},{-4,1,2,3},{-1,-2,-3,-4}},
 {{-4,-3},{-4,-2,-1,3},{-4,-2,1,3},{-4,-1,2,3},{-4,1,2,3},{-3,4},{3,4}}
]$
uhit_def[3,5] : [
 vardisjoint_full_gluing(musatd2(2),musatd2(2))[2],
 {{1,2,3},{-1,2,3},{1,-2,4},{-1,-2,4},{2,-3,5},{2,-3,-5},{-2,-4,5},{-2,-4,-5}},
 {{-5,-4,-2},{-5,-2,3,4},{-4,-3,-2,5},{-3,-2,-1,4},{-3,-2,1,4},{-2,3,5},{-1,2},{1,2}},
 {{-5,-4,-2,-1},{-5,-4,-2,1},{-5,-2,-1,4},{-5,-2,1,4},{-5,2,3},{-3,-2,5},{-3,2},{3,5}},
 {{-5,-4},{-5,4},{-4,5},{-3,-2,-1,4,5},{-3,1,4,5},{-2,3,4,5},{-1,2,4,5},{1,2,3,4,5}},
 {{-5,-4},{-5,-3,4},{-4,-2,-1,3,5},{-4,-2,1,3,5},{-4,-1,2,3,5},{-4,1,2,3,5},{-3,5},{3,4}}
]$
uhit_def[3,6] : [
 vardisjoint_full_gluing(musatd2(2),musatd2(3))[2]
]$
uhit_def[3,7] : [
 max_var_hitting_def(3)[2]
]$



/* Deficiency 4 */

uhit_def[4,"info"] : [false,3,inf,[[3,true],[4,true],[11,unknown]]]$
uhit_def[4,3] : [
 nearly_full_hitting_fcs(3)[2]
]$
oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/MinimalUnsatisfiability/data/uhit_def4.mac")$
uhit_def[4,11] : [
  max_var_hitting_def(4)[2]
]$


/* Deficiency 5 */

uhit_def[5,"info"] : [false,3,inf,[[3,true],[4,true],[15,unknown]]]$
uhit_def[5,3] : [
 full_fcs(3)[2]
]$
oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/MinimalUnsatisfiability/data/uhit_def5.mac")$
uhit_def[5,15] : [
  max_var_hitting_def(5)[2]
]$


/* Deficiency 6 */

uhit_def[6,"info"] : [false,4,inf,[[4,true]]]$
oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/MinimalUnsatisfiability/data/uhit_def6.mac")$


/* Deficiency 7 */

uhit_def[7,"info"] : [false,4,inf,[[4,true]]]$
oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/MinimalUnsatisfiability/data/uhit_def7.mac")$


/* Deficiency 8 */

uhit_def[8,"info"] : [false,4,inf,[[4,true]]]$
oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/MinimalUnsatisfiability/data/uhit_def8.mac")$


/* Deficiency 9 */

uhit_def[9,"info"] : [false,4,inf,[[4,true]]]$
uhit_def[9,4] : [
{{-4,-3},{-4,-2,-1,3},{-4,-2,1,3},{-4,-1,2,3},{-4,1,2,3},{-3,-2,-1,4},{-3,-2,1,4},{-3,-1,2,4},{-3,1,2,4},{-2,-1,3,4},{-2,1,3,4},{-1,2,3,4},{1,2,3,4}}, 
{{-4,-3,-2},{-4,-3,-1,2},{-4,-3,1,2},{-4,-2,-1,3},{-4,-2,1,3},{-4,2,3},{-3,-2,-1,4},{-3,-2,1,4},{-3,2,4},{-2,-1,3,4},{-2,1,3,4},{-1,2,3,4},{1,2,3,4}}, 
{{-4,-3,-2},{-4,-3,1,2},{-4,-2,-1,3},{-4,-2,1,3},{-4,-1,2},{-4,1,2,3},{-3,-2,-1,4},{-3,-2,1,4},{-3,-1,2,4},{-3,1,2,4},{-2,-1,3,4},{-1,2,3,4},{1,3,4}}, 
{{-4,-3,-2},{-4,-3,1,2},{-4,-2,-1,3},{-4,-2,1,3},{-4,-1,2},{-4,1,2,3},{-3,-2,-1,4},{-3,-2,1,4},{-3,-1,2,4},{-2,-1,3,4},{-2,1,3,4},{-1,2,3,4},{1,2,4}}, 
{{-4,-3,-2},{-4,-3,1,2},{-4,-2,-1,3},{-4,-2,1,3},{-4,-1,2},{-4,1,2,3},{-3,-2,-1,4},{-3,-1,2,4},{-3,1,2,4},{-2,-1,3,4},{-2,1,4},{-1,2,3,4},{1,2,3,4}}, 
{{-4,-3,-2},{-4,-3,1,2},{-4,-2,-1,3},{-4,-2,1,3},{-4,-1,2},{-4,1,2,3},{-3,-2,1,4},{-3,-1,2,4},{-3,1,2,4},{-2,-1,4},{-2,1,3,4},{-1,2,3,4},{1,2,3,4}}, 
{{-4,-3,-2},{-4,-3,1,2},{-4,-2,-1,3},{-4,-1,2},{-4,1,2,3},{-3,-2,-1,4},{-3,-2,1,4},{-3,-1,2,4},{-3,1,2,4},{-2,-1,3,4},{-2,1,3},{-1,2,3,4},{1,2,3,4}}, 
{{-4,-3,-2},{-4,-3,1,2},{-4,-2,-1,3},{-4,-1,2},{-4,1,3},{-3,-2,-1,4},{-3,-2,1,4},{-3,-1,2,4},{-3,1,2,4},{-2,-1,3,4},{-2,1,3,4},{-1,2,3,4},{1,2,3,4}}, 
{{-4,-3,-2},{-4,-3,2},{-4,-2,-1,3},{-4,-2,1,3},{-4,-1,2,3},{-4,1,2,3},{-3,-2,-1,4},{-3,-2,1,4},{-3,-1,2,4},{-3,1,2,4},{-2,1,3,4},{-1,3,4},{1,2,3,4}}, 
{{-4,-3,-2},{-4,-3,2},{-4,-2,-1,3},{-4,-2,1,3},{-4,-1,2,3},{-4,1,2,3},{-3,-2,-1,4},{-3,-2,1,4},{-3,-1,2,4},{-3,1,2,4},{-2,3,4},{-1,2,3,4},{1,2,3,4}}, 
{{-4,-3,-2},{-4,-3,2},{-4,-2,1,3},{-4,-1,2,3},{-4,1,2,3},{-3,-2,-1,4},{-3,-2,1,4},{-3,-1,2,4},{-3,1,2,4},{-2,-1,3},{-2,1,3,4},{-1,2,3,4},{1,2,3,4}}, 
{{-4,-3,-2},{-4,-3,2},{-4,-2,1,3},{-4,-1,3},{-4,1,2,3},{-3,-2,-1,4},{-3,-2,1,4},{-3,-1,2,4},{-3,1,2,4},{-2,-1,3,4},{-2,1,3,4},{-1,2,3,4},{1,2,3,4}}, 
{{-4,-3,-2},{-4,-3,2},{-4,-2,3},{-4,-1,2,3},{-4,1,2,3},{-3,-2,-1,4},{-3,-2,1,4},{-3,-1,2,4},{-3,1,2,4},{-2,-1,3,4},{-2,1,3,4},{-1,2,3,4},{1,2,3,4}}, 
{{-4,-3,-2},{-4,-2,-1,3},{-4,-2,1,3},{-4,-1,2},{-4,1,2,3},{-3,-2,-1,4},{-3,-2,1,4},{-3,-1,2,4},{-3,1,2},{-2,-1,3,4},{-2,1,3,4},{-1,2,3,4},{1,2,3,4}}
]$ 


/* Deficiency 10 */

uhit_def[10,"info"] : [false,4,inf,[[4,true],[35,unknown]]]$

uhit_def[10,4] : [
 {{-4,-3,-2},{-4,-3,-1,2},{-4,-3,1,2},{-4,-2,-1,3},{-4,-2,1,3},
  {-4,-1,2,3},{-3,-2,-1,4},{-3,-2,1,4},{-3,-1,2,4},{-3,1,2,4},
  {-2,-1,3,4},{-2,1,3,4},{-1,2,3,4},{1,2,3}},
 {{-4,-3,-2,-1},{-4,-3,-2,1},{-4,-3,-1,2},{-4,-2,-1,3},
  {-4,-2,1,3},{-4,-1,2,3},{-3,-2,-1,4},{-3,-2,1,4},{-3,-1,2,4},
  {-3,1,2},{-2,-1,3,4},{-2,1,3,4},{-1,2,3,4},{1,2,3}},
 {{-4,-3,-2,-1},{-4,-3,-1,2},{-4,-3,1},{-4,-2,-1,3},{-4,-2,1,3},
  {-4,-1,2,3},{-3,-2,-1,4},{-3,-2,1,4},{-3,-1,2,4},{-3,1,2,4},
  {-2,-1,3,4},{-2,1,3,4},{-1,2,3,4},{1,2,3}},
 {{-4,-3,-2,-1},{-4,-3,-1,2},{-4,-3,1,2},{-4,-2,-1,3},{-4,-2,1,3},
  {-4,-1,2,3},{-3,-2,-1,4},{-3,-2,1},{-3,-1,2,4},{-3,1,2,4},
  {-2,-1,3,4},{-2,1,3,4},{-1,2,3,4},{1,2,3}},
 {{-4,-3,-2,1},{-4,-3,-1,2},{-4,-3,1,2},{-4,-2,-1,3},{-4,-2,1,3},
  {-4,-1,2,3},{-3,-2,-1},{-3,-2,1,4},{-3,-1,2,4},{-3,1,2,4},
  {-2,-1,3,4},{-2,1,3,4},{-1,2,3,4},{1,2,3}}
]$
uhit_def[10,35] : [
  max_var_hitting_def(10)[2]
]$


/* Deficiency 11 */

uhit_def[11,"info"] : [false,4,inf,[[4,true],[39,unknown]]]$

uhit_def[11,4] : [nearly_full_hitting_fcs(4)[2]]$
uhit_def[11,39] : [
  max_var_hitting_def(11)[2]
]$



/* Deficiency 12 */

uhit_def[12,"info"] : [false,4,inf,[[4,true],[43,unknown]]]$

uhit_def[12,4] : [full_fcs(4)[2]]$
uhit_def[12,43] : [
  max_var_hitting_def(12)[2]
]$


/* ****************************
   * Evaluating the catalogue *
   ****************************
*/

/* Apply function f to all elements of the catalogue:
   Call f(k,n,i,F), store the results in a list. */
apply_uhit(f) := block([list_def : uhit_def[0,"info"], result : []],
  for k in list_def do block([list_n : map(first,uhit_def[k,"info"][4])],
    for n in list_n do block([L : uhit_def[k,n]],
      for i : 1 thru length(L) do block([F : L[i]],
        result : endcons(f(k,n,i,F),result)))
  ),
  return(result))$


/* Collecting all clause-sets from the uhit-catalogue for a
   given number of variables and a range of deficiencies. */
collect_uhit_n(n,k0,k1) :=
  setify(apply(append,makelist(uhit_def[k,n],k,k0,k1)))$

/* The set of all known non-singular unsatisfiable hitting 
   clause-sets for a given number of variables. */
/* uhit_n(-1,true) yields the list of available n-values. */
/* The info-entry uhit_n(n,true) states whether the
   list is complete or not (similar to above). */
/* uhit_n(n,false) is the set of available clause-sets. */
uhit_n(n,info) := block(
 [info_data : [[0,1,2,3,4],true,true,true,true,true],
  def_data : [[1,1],[],[2,2],[2,5],[3,12]]],
 if info then info_data[n+2]
 else block([K : def_data[n+1]],
   if emptyp(K) then return({})
   else return(collect_uhit_n(n,K[1],K[2]))))$


/* For a list of candidate clause-sets, determine whether F is
   reduced unsatisfiable hitting, and in the positive case
   determine whether F is contained in the catalogue or not,
   where in the positive case the index-triple is returned.
*/
classify_candidates_uhit_def(L) := block([result : []],
  for F in L do block([check : check_hitting_nsing_def(F)],
    if length(check) = 0 then result : endcons(false,result)
    else block([element : [check[1], nvar_cs(F)], catalist],
      catalist : uhit_def[element[1], element[2]],
      if not listp(catalist) then result : endcons([element,"new"],result)
      else block([found : false],
        for i : 1 thru length(catalist) unless found do
          if is_isomorphic_btr_cs(F, catalist[i]) then (
            found : true,
            result : endcons([element, i],result)
          ),
        if not found then result : endcons([element,"new"],result)
      )
    )
  ),
  return(result))$

    


/*!
\endhtmlonly
*/
