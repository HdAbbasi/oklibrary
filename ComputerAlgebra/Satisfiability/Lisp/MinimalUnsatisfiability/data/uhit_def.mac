/* Oliver Kullmann, 30.4.2008 (Guangzhou) */
/* Copyright 2008 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Satisfiability/Lisp/MinimalUnsatisfiability/data/uhit_def.mac
  \brief Classification of unsatisfiable hitting clause-sets in dependency on the deficiency, only considering clause-sets which are reduced w.r.t. singular DP-reduction

  Only small datasets here; others are excluded from for example "uhit_def_4.mac"
  for deficiency 4.

Use by

oklib_load("Transitional/ComputerAlgebra/Satisfiability/Lisp/MinimalUnsatisfiability/data/uhit_def.mac");

*/

/*!
\htmlonly
*/

oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/MinimalUnsatisfiability/Deficiency2.mac")$
oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/Symmetries/Symmetries.mac")$
oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/BasicOperations.mac")$
oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/Constructions.mac")$
oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/ConflictCombinatorics/HittingClauseSets.mac")$
oklib_include("Transitional/ComputerAlgebra/Hypergraphs/Lisp/tests/SetSystems.mac")$
oklib_include("Transitional/ComputerAlgebra/Hypergraphs/Lisp/SetSystems.mac")$
oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/Reductions/DP-Reductions.mac")$
oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/MinimalUnsatisfiability/Deficiency3.mac")$


kill(uhit_def)$

/* The list of available deficiencies. */
uhit_def[0,"info"] : append(makelist(k,k,1,12),[24,26,27,43,58])$

/* For a given deficiency k, the info-field uhit_def[k,"info] contains:
 - true if the classification is complete, and false/unknown otherwise
 - the smallest possible n resp. a lower bound
 - the largest possible n resp. an upper bound
 - the list of available n-values, represented as pairs [n,true/false/unknown],
   stating whether or not for this n the list is complete.
*/
/* Complete means that every possible isomorphism type is
   represented (exactly once). */
/* "false" here means that definitely some cases are missing. */


/* Deficiency 1 */

uhit_def[1,"info"] : [true,0,0,[[0,true]]]$
uhit_def[1,0] : [{{}}]$


/* Deficiency 2 */

uhit_def[2,"info"] : [true,2,3,[[2,true],[3,true]]]$
uhit_def[2,2] : [musatd2(2)[2]]$
uhit_def[2,3] : [max_var_hitting_def(2)[2]]$


/* Deficiency 3 */

uhit_def[3,"info"] : [unknown,3,inf,[[3,true],[4,true],[5,unknown],[6,unknown],[7,unknown]]]$
uhit_def[3,3] : [
 minvdegdef3(2)[2],
 {{1,2,3},{-1,2,3},{1,-2,3},{-1,-2,3},{1,-3},{-1,-3}},
 {{-3,-2},{-3,-1,2},{-3,1,2},{-2,-1,3},{-2,1,3},{2,3}}
]$
uhit_def[3,4] : [
 {{-4,-3},{-4,-1,2,3},{-4,1,2,3},{-3,-2,4},{-2,-1,3},{-2,1,3},{2,4}},
 {{-4,-3},{-4,-1,2,3},{-4,1,2,3},{-3,4},{-2,-1,3},{-2,1,3},{2,3,4}},
 {{-4,-3},{-4,-1,2,3},{-4,1,3},{-3,-2,-1,4},{-2,-1,3},{-2,1,4},{2,4}},
 {{-4,-3},{-4,2,3},{-3,-2,1,4},{-3,-1,4},{-2,3},{-1,2,3,4},{1,2,4}},
 {{-4,-3},{-4,2,3},{-3,-1,4},{-3,1,4},{-2,-1,3},{-2,1,3},{2,3,4}},
 {{-4,-3,-2},{-4,-2,3},{-3,-2,-1,4},{-3,-2,1,4},{-2,3,4},{-1,2},{1,2}},
 {{-4,-3,-2},{-4,2},{-3,-1,4},{-3,1,4},{-2,-1,3},{-2,1,3},{2,3,4}},
 {{-4,-3,-1},{-4,-3,1,2},{-4,-2,-1,3},{-4,-2,1},{-4,2,3},{-3,4},{3,4}},
 {{1,2,3,4},{-1,2},{-2,3},{-3,1},{-1,-2,-3,4},{-4,1,2,3},{-1,-2,-3,-4}},
 {{-4,-3},{-4,-2,-1,3},{-4,-2,1,3},{-4,-1,2,3},{-4,1,2,3},{-3,4},{3,4}}
]$
uhit_def[3,5] : [
 vardisjoint_full_gluing(musatd2(2),musatd2(2))[2],
 {{1,2,3},{-1,2,3},{1,-2,4},{-1,-2,4},{2,-3,5},{2,-3,-5},{-2,-4,5},{-2,-4,-5}},
 {{-5,-4,-2},{-5,-2,3,4},{-4,-3,-2,5},{-3,-2,-1,4},{-3,-2,1,4},{-2,3,5},{-1,2},{1,2}},
 {{-5,-4,-2,-1},{-5,-4,-2,1},{-5,-2,-1,4},{-5,-2,1,4},{-5,2,3},{-3,-2,5},{-3,2},{3,5}},
 {{-5,-4},{-5,4},{-4,5},{-3,-2,-1,4,5},{-3,1,4,5},{-2,3,4,5},{-1,2,4,5},{1,2,3,4,5}},
 {{-5,-4},{-5,-3,4},{-4,-2,-1,3,5},{-4,-2,1,3,5},{-4,-1,2,3,5},{-4,1,2,3,5},{-3,5},{3,4}},
 {{-5,-4},{-5,4},{-4,-3,5},{-3,4,5},{-2,-1,3,5},{-2,1,3,5},{-1,2,3,5},{1,2,3,5}},
 {{-5,-4},{-5,4},{-4,-2,-1,3,5},{-3,-2,5},{-3,1,2,5},{-2,-1,3,4,5},{-1,2,5},{1,3,5}},
 {{-5,-4},{-5,4},{-4,-1,3,5},{-3,-2,5},{-3,2,5},{-2,1,3,5},{-1,3,4,5},{1,2,3,5}}
]$
uhit_def[3,6] : [
 vardisjoint_full_gluing(musatd2(2),musatd2(3))[2]
]$
uhit_def[3,7] : [
 max_var_hitting_def(3)[2]
]$



/* Deficiency 4 */

uhit_def[4,"info"] : [false,3,inf,[[3,true],[4,true],[5,unknown],[6,unknown],[7,unknown],[11,unknown]]]$
uhit_def[4,3] : [
 nearly_full_hitting_fcs(3)[2]
]$
oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/MinimalUnsatisfiability/data/uhit_def4.mac")$
uhit_def[4,11] : [
  max_var_hitting_def(4)[2]
]$


/* Deficiency 5 */

uhit_def[5,"info"] : [false,3,inf,[[3,true],[4,true],[15,unknown]]]$
uhit_def[5,3] : [
 full_fcs(3)[2]
]$
oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/MinimalUnsatisfiability/data/uhit_def5.mac")$
uhit_def[5,15] : [
  max_var_hitting_def(5)[2]
]$


/* Deficiency 6 */

uhit_def[6,"info"] : [false,4,inf,[[4,true],[19,unknown]]]$
oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/MinimalUnsatisfiability/data/uhit_def6.mac")$
uhit_def[6,19] : [
 max_var_hitting_def(6)[2]
]$


/* Deficiency 7 */

uhit_def[7,"info"] : [false,4,inf,[[4,true]]]$
oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/MinimalUnsatisfiability/data/uhit_def7.mac")$
uhit_def[7,23] : [
 max_var_hitting_def(7)[2]
]$


/* Deficiency 8 */

uhit_def[8,"info"] : [false,4,inf,[[4,true]]]$
oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/MinimalUnsatisfiability/data/uhit_def8.mac")$
uhit_def[8,27] : [
 max_var_hitting_def(8)[2]
]$


/* Deficiency 9 */

uhit_def[9,"info"] : [false,4,inf,[[4,true]]]$
uhit_def[9,4] : [
{{-4,-3},{-4,-2,-1,3},{-4,-2,1,3},{-4,-1,2,3},{-4,1,2,3},{-3,-2,-1,4},{-3,-2,1,4},{-3,-1,2,4},{-3,1,2,4},{-2,-1,3,4},{-2,1,3,4},{-1,2,3,4},{1,2,3,4}}, 
{{-4,-3,-2},{-4,-3,-1,2},{-4,-3,1,2},{-4,-2,-1,3},{-4,-2,1,3},{-4,2,3},{-3,-2,-1,4},{-3,-2,1,4},{-3,2,4},{-2,-1,3,4},{-2,1,3,4},{-1,2,3,4},{1,2,3,4}}, 
{{-4,-3,-2},{-4,-3,1,2},{-4,-2,-1,3},{-4,-2,1,3},{-4,-1,2},{-4,1,2,3},{-3,-2,-1,4},{-3,-2,1,4},{-3,-1,2,4},{-3,1,2,4},{-2,-1,3,4},{-1,2,3,4},{1,3,4}}, 
{{-4,-3,-2},{-4,-3,1,2},{-4,-2,-1,3},{-4,-2,1,3},{-4,-1,2},{-4,1,2,3},{-3,-2,-1,4},{-3,-2,1,4},{-3,-1,2,4},{-2,-1,3,4},{-2,1,3,4},{-1,2,3,4},{1,2,4}}, 
{{-4,-3,-2},{-4,-3,1,2},{-4,-2,-1,3},{-4,-2,1,3},{-4,-1,2},{-4,1,2,3},{-3,-2,-1,4},{-3,-1,2,4},{-3,1,2,4},{-2,-1,3,4},{-2,1,4},{-1,2,3,4},{1,2,3,4}}, 
{{-4,-3,-2},{-4,-3,1,2},{-4,-2,-1,3},{-4,-2,1,3},{-4,-1,2},{-4,1,2,3},{-3,-2,1,4},{-3,-1,2,4},{-3,1,2,4},{-2,-1,4},{-2,1,3,4},{-1,2,3,4},{1,2,3,4}}, 
{{-4,-3,-2},{-4,-3,1,2},{-4,-2,-1,3},{-4,-1,2},{-4,1,2,3},{-3,-2,-1,4},{-3,-2,1,4},{-3,-1,2,4},{-3,1,2,4},{-2,-1,3,4},{-2,1,3},{-1,2,3,4},{1,2,3,4}}, 
{{-4,-3,-2},{-4,-3,1,2},{-4,-2,-1,3},{-4,-1,2},{-4,1,3},{-3,-2,-1,4},{-3,-2,1,4},{-3,-1,2,4},{-3,1,2,4},{-2,-1,3,4},{-2,1,3,4},{-1,2,3,4},{1,2,3,4}}, 
{{-4,-3,-2},{-4,-3,2},{-4,-2,-1,3},{-4,-2,1,3},{-4,-1,2,3},{-4,1,2,3},{-3,-2,-1,4},{-3,-2,1,4},{-3,-1,2,4},{-3,1,2,4},{-2,1,3,4},{-1,3,4},{1,2,3,4}}, 
{{-4,-3,-2},{-4,-3,2},{-4,-2,-1,3},{-4,-2,1,3},{-4,-1,2,3},{-4,1,2,3},{-3,-2,-1,4},{-3,-2,1,4},{-3,-1,2,4},{-3,1,2,4},{-2,3,4},{-1,2,3,4},{1,2,3,4}}, 
{{-4,-3,-2},{-4,-3,2},{-4,-2,1,3},{-4,-1,2,3},{-4,1,2,3},{-3,-2,-1,4},{-3,-2,1,4},{-3,-1,2,4},{-3,1,2,4},{-2,-1,3},{-2,1,3,4},{-1,2,3,4},{1,2,3,4}}, 
{{-4,-3,-2},{-4,-3,2},{-4,-2,1,3},{-4,-1,3},{-4,1,2,3},{-3,-2,-1,4},{-3,-2,1,4},{-3,-1,2,4},{-3,1,2,4},{-2,-1,3,4},{-2,1,3,4},{-1,2,3,4},{1,2,3,4}}, 
{{-4,-3,-2},{-4,-3,2},{-4,-2,3},{-4,-1,2,3},{-4,1,2,3},{-3,-2,-1,4},{-3,-2,1,4},{-3,-1,2,4},{-3,1,2,4},{-2,-1,3,4},{-2,1,3,4},{-1,2,3,4},{1,2,3,4}}, 
{{-4,-3,-2},{-4,-2,-1,3},{-4,-2,1,3},{-4,-1,2},{-4,1,2,3},{-3,-2,-1,4},{-3,-2,1,4},{-3,-1,2,4},{-3,1,2},{-2,-1,3,4},{-2,1,3,4},{-1,2,3,4},{1,2,3,4}}
]$ 
uhit_def[9,31] : [
 max_var_hitting_def(9)[2]
]$


/* Deficiency 10 */

uhit_def[10,"info"] : [false,4,inf,[[4,true],[35,unknown]]]$

uhit_def[10,4] : [
 {{-4,-3,-2},{-4,-3,-1,2},{-4,-3,1,2},{-4,-2,-1,3},{-4,-2,1,3},
  {-4,-1,2,3},{-3,-2,-1,4},{-3,-2,1,4},{-3,-1,2,4},{-3,1,2,4},
  {-2,-1,3,4},{-2,1,3,4},{-1,2,3,4},{1,2,3}},
 {{-4,-3,-2,-1},{-4,-3,-2,1},{-4,-3,-1,2},{-4,-2,-1,3},
  {-4,-2,1,3},{-4,-1,2,3},{-3,-2,-1,4},{-3,-2,1,4},{-3,-1,2,4},
  {-3,1,2},{-2,-1,3,4},{-2,1,3,4},{-1,2,3,4},{1,2,3}},
 {{-4,-3,-2,-1},{-4,-3,-1,2},{-4,-3,1},{-4,-2,-1,3},{-4,-2,1,3},
  {-4,-1,2,3},{-3,-2,-1,4},{-3,-2,1,4},{-3,-1,2,4},{-3,1,2,4},
  {-2,-1,3,4},{-2,1,3,4},{-1,2,3,4},{1,2,3}},
 {{-4,-3,-2,-1},{-4,-3,-1,2},{-4,-3,1,2},{-4,-2,-1,3},{-4,-2,1,3},
  {-4,-1,2,3},{-3,-2,-1,4},{-3,-2,1},{-3,-1,2,4},{-3,1,2,4},
  {-2,-1,3,4},{-2,1,3,4},{-1,2,3,4},{1,2,3}},
 {{-4,-3,-2,1},{-4,-3,-1,2},{-4,-3,1,2},{-4,-2,-1,3},{-4,-2,1,3},
  {-4,-1,2,3},{-3,-2,-1},{-3,-2,1,4},{-3,-1,2,4},{-3,1,2,4},
  {-2,-1,3,4},{-2,1,3,4},{-1,2,3,4},{1,2,3}}
]$
uhit_def[10,35] : [
  max_var_hitting_def(10)[2]
]$


/* Deficiency 11 */

uhit_def[11,"info"] : [false,4,inf,[[4,true]]]$

uhit_def[11,4] : [nearly_full_hitting_fcs(4)[2]]$
/*
uhit_def[11,39] : [
  max_var_hitting_def(11)[2]
]$
*/


/* Deficiency 12 */

uhit_def[12,"info"] : [false,4,inf,[[4,true],[5,unknown],[7,false]]]$
uhit_def[12,4] : [full_fcs(4)[2]]$
oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/MinimalUnsatisfiability/data/uhit_def12.mac")$
uhit_def[12,7] : [
  rbrouwer1999[2]
]$
/*
uhit_def[12,43] : [
  max_var_hitting_def(12)[2]
]$
*/


/* Deficiency 24 */

uhit_def[24,"info"] : [false,5,inf,[[8,false]]]$
uhit_def[24,8] : [
  brouwer1999[2]
]$
/*
uhit_def[24,91] : [
  max_var_hitting_def(24)[2]
]$
*/


/* Deficiency 26 */

uhit_def[26,"info"] : [false,5,inf,[[5,true]]]$
uhit_def[26,5] : [nearly_full_hitting_fcs(5)[2]]$
/*
uhit_def[27,103] : [
 max_var_hitting_def(27)[2]
]$
*/


/* Deficiency 27 */

uhit_def[27,"info"] : [false,5,inf,[[5,true]]]$
uhit_def[27,5] : [full_fcs(5)[2]]$
/*
uhit_def[27,103] : [
 max_var_hitting_def(27)[2]
]$
*/


/* Deficiency 43 */

uhit_def[43,"info"] : [false,6,inf,[[6,false]]]$
uhit_def[43,6] : [

{{-6,-5},{-6,-4,-3,-2,-1,5},{-6,-4,-3,-2,1,5},{-6,-4,-3,-1,2,5},{-6,-4,-3,1,2,5},
 {-6,-4,-2,-1,3,5},{-6,-4,-2,1,3,5},{-6,-4,-1,2,3,5},{-6,-4,1,2,3,5},{-6,-3,-2,-1,4,5},
 {-6,-3,-2,1,4,5},{-6,-3,-1,2,4,5},{-6,-3,1,2,4,5},{-6,-2,-1,3,4,5},{-6,-2,1,3,4,5},
 {-6,-1,2,3,4,5},{-6,1,2,3,4,5},{-5,-4,-3,-2,-1,6},{-5,-4,-3,-2,1,6},{-5,-4,-3,-1,2,6},
 {-5,-4,-3,1,2,6},{-5,-4,-2,-1,3,6},{-5,-4,-2,1,3,6},{-5,-4,-1,2,3,6},{-5,-4,1,2,3,6},
 {-5,-3,-2,-1,4,6},{-5,-3,-2,1,4,6},{-5,-3,-1,2,4,6},{-5,-3,1,2,4,6},{-5,-2,-1,3,4,6},
 {-5,-2,1,3,4,6},{-5,-1,2,3,4,6},{-5,1,2,3,4,6},{-4,-3,-2,-1,5,6},{-4,-3,-2,1,5,6},
 {-4,-3,-1,2,5,6},{-4,-3,1,2,5,6},{-4,-2,-1,3,5,6},{-4,-2,1,3,5,6},{-4,-1,2,3,5,6},
 {-4,1,2,3,5,6},{-3,-2,-1,4,5,6},{-3,-2,1,4,5,6},{-3,-1,2,4,5,6},{-3,1,2,4,5,6},
 {-2,-1,3,4,5,6},{-2,1,3,4,5,6},{-1,2,3,4,5,6},{1,2,3,4,5,6}}

]$
/*
uhit_def[43,127] : [
 max_var_hitting_def(43)[2]
]$
*/

/* Deficiency 58 */

uhit_def[58,"info"] : [false,6,inf,[[6,true]]]$
uhit_def[58,6] : [full_fcs(6)[2]]$
/*
uhit_def[58,227] : [
 max_var_hitting_def(58)[2]
]$
*/



/* *************************************
   * Bounds on the deficiency and on n *
   *************************************
*/

/* For given number of variables n, the maximal deficiency k
  such that an unsatisfiable hitting clause-set with these parameters 
  exists. This unique clause-set is full_fcs(n)[2], which is non-singular
  for n <> 1. */
max_def_uhit_n(n) := 2^n - n$

/* For given deficiency k, the conjectured ([OK,XSZ, 2008]) minimal n
   for which unsatisfiable non-singular hitting clause-sets exist: */
/* The smallest n with max_def_uhit_n(n) >= k. */
/* Using the Lambert-function lambertW(z,x) from Mupad, this is
   ceil(-k - lambertW(-1, -exp(-k))).
*/
min_n_uhit_def_i(k) := for n : 0 do if 2^n - n >= k then return(n)$
/* Alternative computation using the Lambert-W-function. */
/* This computation is much slower and also error-prone, but there might be
   some theoretical interest in it. */
min_n_uhit_def_l(k) := if k=1 then 0 else
 ceiling(-k - lambert_w_b(-2^(-k), 2))$
/* The branch "-1" of the Lambert-W-function: */
lambert_w1(z):= block([eps :  bfloat(10^(-fpprec+1))],
 z : bfloat(z),
 block(
  [w1, w2 : 0, p : bfloat(-sqrt(2*%e*z+2))],
   w1 : bfloat(((((((-221/8505*p)+769/17280)*p-43/540)*p+11/72)*p-1/3)*p+1)*p-1),
   while w2 - w1 >= eps do (w2 : w1, w1 : bfloat(log(z/w1))),
   return(w1)))$
/* Using this branch, the slightly generalised Lambert-W-function
   for base b (instead of e): */
lambert_w_b(x,b) := block([fpprec : 20],
 bfloat(lambert_w1(log(b) * x) / log(b)))$


/* ****************************
   * Evaluating the catalogue *
   ****************************
*/

/* Apply function f to all elements of the catalogue:
   Call f(k,n,i,F), store the results in a list. */
apply_uhit(f) := block([list_def : uhit_def[0,"info"], result : []],
  for k in list_def do block([list_n : map(first,uhit_def[k,"info"][4])],
    for n in list_n do block([L : uhit_def[k,n]],
      for i : 1 thru length(L) do block([F : L[i]],
        result : endcons(f(k,n,i,F),result)))
  ),
  return(result))$


/* Collecting all clause-sets from the uhit-catalogue for a
   given number of variables and a range of deficiencies. */
collect_uhit_n(n,k0,k1) :=
  setify(apply(append,sublist(
    makelist(uhit_def[k,n],k,k0,k1),
    lambda([L], is(op(L) # uhit_def)))))$

/* The set of all known non-singular unsatisfiable hitting 
   clause-sets for a given number of variables. */
/* uhit_n(-1,true/false) yields the list of available n-values. */
/* The info-entry uhit_n(n,true) states whether the
   list is complete or not (similar to above). */
/* uhit_n(n,false) is the set of available clause-sets. */
/* BUG: yet only the catalogue data given by info_data
   and def_data is accessible. */
uhit_n(n,info) := block(
 [info_data : [[0,1,2,3,4,5,6,8],true,true,true,true,true,false,false,false],
  def_data : [ [1,1],[],[2,2],[2,5],[3,12],[3,27],[3,58],[24,24] ] 
 ],
 if n = -1 then return(info_data[1])
 elseif not elementp(n,setify(info_data[1])) then
   if info then return(false) else return({})
 elseif info then return(info_data[n+2])
 else block([K : def_data[n+1]],
   if emptyp(K) then return({})
   else return(collect_uhit_n(n,K[1],K[2]))))$


/* For a list of candidate clause-sets, determine whether F is
   reduced unsatisfiable hitting, and in the positive case
   determine whether F is contained in the catalogue or not,
   where in the positive case the index-triple is returned.
   So for each F the corresponding entry in the return list
   is either false or [[k,n],i] or [[k,n],"new"].
*/
classify_candidates_uhit_def(L) := block([result : []],
  for F in L do block([check : check_hitting_nsing_def(F)],
    if length(check) = 0 then result : endcons(false,result)
    else block([element : [check[1], nvar_cs(F)], catalist],
      catalist : uhit_def[element[1], element[2]],
      if not listp(catalist) then result : endcons([element,"new"],result)
      else block([found : false],
        for i : 1 thru length(catalist) unless found do
          if is_isomorphic_btr_cs(F, catalist[i]) then (
            found : true,
            result : endcons([element, i],result)
          ),
        if not found then result : endcons([element,"new"],result)
      )
    )
  ),
  return(result))$

/* Compute the reduced isomorphism type of a clause-set F w.r.t. 
   non-singular unsatisfiable hitting clause-sets:
    - [false] iff F is not unsatisfiable or not a hitting clause-set
      after singular DP-reduction
    - [[k,n],"new"] iff not in the catalogue
    - [[k,n],i] iff in the catalogue, with deficiency k, number of 
      variables n and index i.
*/
/* According to [Kullmann, Zhao, 2008] for unsatisfiable hitting
   clause-sets F the result of singular_dp_reduction(F) is unique
   up to isomorphism. */
redisotype_uhit_def(F) := classify_candidates_uhit_def(
  [singular_dp_reduction(F)])[1]$

/* For all clause-sets in the catalogue with number of variables at most
   n_bound, apply all partial assignments, followed by iterated elimination
   of singular variables, and compute the non-isomorphic cases found not to 
   be in the catalogue, in the form of a repository of isomorphism types,
   whose name is passed by name. Returned is the number of new clause-sets
   found in this way. */
closure_uhit_def_pass(n_bound, _hash_repo) := block(
 [min_n_unknown, /* the smallest n for which we don't have a
                         complete classification */
  count : 0],
  _hash_repo :: sm2hm({}),
  for n : 0 unless numberp(min_n_unknown) do
    if not uhit_n(n,true) then min_n_unknown : n,
  for n : min_n_unknown + 1 thru n_bound do
    for F in uhit_n(n,false) do
      for npass : 1 thru n - min_n_unknown do block([P : all_pass_n(setn(n),npass)],
        for phi in P do block(
         [G : singular_dp_reduction(apply_pa(phi,F)), V],
          V : var_cs(G),
          if 
            length(V) >= min_n_unknown and
            classify_candidates_uhit_def([G])[1][2] = ["new"] and
            manage_repository_isomorphism_types([V,G],ev(_hash_repo)) then
            count : count + 1
        )
      ),
  return(count))$
        

/*!
\endhtmlonly
*/
