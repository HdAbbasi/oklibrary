/* Oliver Kullmann, 29.11.2007 (Swansea) */
/* Copyright 2007, 2008 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Satisfiability/Lisp/MinimalUnsatisfiability/Basics.mac
  \brief Operations regarding minimally unsatisfiable clause-sets

Use by

oklib_load("Transitional/ComputerAlgebra/Satisfiability/Lisp/MinimalUnsatisfiability/Basics.mac");

*/

/*!
\htmlonly
*/

oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/BasicOperations.mac");


/* Predicate to decide whether formal clause-set FF implies clause C,
   using solver S. */
impliesp_f(FF,C,S) := not S(apply_pa_f(comp_sl(C),FF))$
/* The variation for clause-sets F. */
impliesp(F,C,S) := not S(cs_to_fcs(apply_pa(comp_sl(C),F)))$


/* Returns true iff input FF (formal clause-set) is minimally unsatisfiable.
   The second input, the "solver", shall just return true or false. */
min_unsat_bydef(FF, solver) := not solver(FF) and 
 block([all_sat : true],
  for C in FF[2] unless not all_sat do 
   all_sat : solver([FF[1], disjoin(C, FF[2])]),
  return(all_sat))$
/* More generally, returns true iff input FF (formal clause-set) is 
   irredundant. */
irredundant_bydef(FF, solver) := 
 block([V : FF[1], F : FF[2], redundancy : false],
  for C in F unless redundancy do
   redundancy : impliesp_f([V,disjoin(C,F)],C,S),
  return(not redundancy))$


/* Returns the set of all irredundant clauses (for unsatisfiable
   clause-sets also called necessary clauses) for input FF. */
all_irrcl_bydef(FF,S) := block([V : FF[1], F : FF[2], I : {}],
  for C in F do 
    if not impliesp_f([V,disjoin(C,F)],C,S) then I : adjoin(C,I),
  return(I))$


/*!
\endhtmlonly
*/
