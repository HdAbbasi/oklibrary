/* Oliver Kullmann, 29.11.2007 (Swansea) */
/* Copyright 2007, 2008, 2009, 2010, 2011 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Satisfiability/Lisp/MinimalUnsatisfiability/Basics.mac
  \brief Operations regarding minimally unsatisfiable clause-sets

Use by

oklib_load("OKlib/ComputerAlgebra/Satisfiability/Lisp/MinimalUnsatisfiability/Basics.mac");

*/

/*!
\htmlonly
*/

oklib_include("OKlib/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/BasicOperations.mac")$
oklib_include("OKlib/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/Statistics.mac")$
oklib_include("OKlib/ComputerAlgebra/NumberTheory/Lisp/Auxiliary.mac")$
oklib_include("OKlib/ComputerAlgebra/DataStructures/Lisp/Lists.mac")$
oklib_include("OKlib/ComputerAlgebra/Satisfiability/Lisp/Backtracking/DLL_solvers.mac")$


/* *************************
   * Deciding irredundancy *
   *************************
*/

/* Predicate to decide whether formal clause-set FF implies clause C,
   using solver S: */
/* RENAME: impliesp_fcs */
impliesp_f(FF,C,S) := not S(apply_pa_f(comp_sl(C),FF))$
impliesp_fcs(FF,C,S) := impliesp_f(FF,C,S)$
/* The variation for clause-sets F. */
/* RENAME: impliesp_cs */
impliesp(F,C,S) := not S(cs2fcs(apply_pa_cs(comp_sl(C),F)))$
impliesp_cs(F,C,S) := impliesp(F,C,S)$

/* Returns true iff input FF (formal clause-set) is minimally unsatisfiable.
   The second input, the "solver", shall just return true or false. */
min_unsat_bydef(FF, solver) := not solver(FF) and 
 block([all_sat : true],
  for C in FF[2] unless not all_sat do 
   all_sat : solver([FF[1], disjoin(C, FF[2])]),
  return(all_sat))$
/* More generally, returns true iff input FF (formal clause-set) is 
   irredundant. */
irredundant_bydef(FF, solver) := 
 block([V : FF[1], F : FF[2], redundancy : false],
  for C in F unless redundancy do
   redundancy : impliesp_f([V,disjoin(C,F)],C,solver),
  return(not redundancy))$
irredundant_bydef_fcs(FF) := irredundant_bydef(FF, current_satsolver)$
irredundant_bydef_cs(F) := irredundant_bydef_fcs(cs2fcs(F))$


/* *****************************
   * Classification of clauses *
   *****************************
*/

/* Returns the set of all irredundant clauses (for unsatisfiable
   clause-sets also called necessary clauses) for input FF: */
all_irrcl_bydef(FF,S) := block([V : FF[1], F : FF[2], I : {}],
  for C in F do 
    if not impliesp_f([V,disjoin(C,F)],C,S) then I : adjoin(C,I),
  return(I))$
all_irrcl_bydef_fcs(FF) := all_irrcl_bydef(FF,current_satsolver)$
all_irrcl_bydef_cs(F) := all_irrcl_bydef_fcs(cs2fcs(F))$

/* Returns true iff input FF is saturated minimally unsatisfiable: */
saturated_min_unsat_bydef(FF, solver) := min_unsat_bydef(FF,solver) and
 every_s(lambda([x],min_unsat_bydef(apply_pa_f({x},FF),solver)), 
         literals_v(FF[1]))$

/* Return the set of partial assignments of size at most 1 which after
   application do not result in a minimally unsatisfiable clause-set. */
/* So saturated_min_unsat_bydef(FF) = true iff 
   non_saturating_pas_bydef(FF) = {}.
*/
non_saturating_pas_bydef(FF,solver) := block(
 [assignments : union({{}}, map(set,literals_v(FF[1]))),
  result : {}],
  for phi in assignments do
    if not min_unsat_bydef(apply_pa_f(phi,FF),solver) then
      result : adjoin(phi,result),
  return(result))$


/* ***************************
   * Maximal min-var-degrees *
   ***************************
*/

/* An upper bound on the maximal min-var-degree of a minimally unsatisfiable
   clause-set of deficiency k, according to [OK, XSZ, SAT 2011]. */
/* This bound is sharp at least for 
 - k = 2^n-n (realised by full_fcs(n))
 - k=2 (realised by musatd2_fcs(n))
 - k=3 (realised by minvdegdef3(n))
 - k=4 (realised by minvdegdef4(n)). */
/* I.e., min_unsat_bydef(F) and is(deficiency_cs(F) <= k) -> 
         min_variable_degree_cs(F) <= nonmersenne[k]. */
/* First the recursive computation: */
nonmersenne_rec[k] := 
 if k = 1 then 2 else
 lmax(create_list(min(2*i,nonmersenne_rec[k-i+1]+i),i,2,k))$
/* This is sequence A062289 (http://www.research.att.com/~njas/sequences/),
   and accordingly we have 
   nonmersenne_rec[k] = nonmersenne_law(k). */
nonmersenne_law(k) := k + fld(k+1 + fld(k+1))$
/* A natural lower bound: */
nonmersenne_lb(k) := k + fld(k+1)$
/* A natural upper bound: */
nonmersenne_ub(k) := k + 1 + fld(k)$

/* Compare Lisp/ConflictCombinatorics/HittingClauseSets.mac
   for the treatmeant of hitting clause-sets.
*/

/* Analysis of the recurrence behaviour:
   Return [] iff k=1, else return the list of tuples T_i for 2 <= i <= k where
   min(2i,nonmersenne_rec[k-i+1]+i) = nonmersenne_rec[k],
   where the last component of T_i is
    - "a" if the first component is strictly less than the second,
    - "ab" if they are equal,
    - and "b" otherwise,
   where in the first case T_i has a leading i, and otherwise leading i, k-i+1.
*/
analyse_nonmersenne_rec(k) := 
 if k=1 then []
 else block([res : [], maxv : minf],
  for i : 2 thru k do block(
   [a : 2 * i, b : nonmersenne_rec[k-i+1]+i, minv],
    minv : min(a,b),
    if minv >= maxv then (
      if minv > maxv then(maxv : minv,  res : []),
      if a < b then res : cons([i,"a"], res)
      elseif a = b then res : cons([i,k-i+1,"ab"], res)
      else res : cons([i,k-i+1,"b"], res)
    )
  ),
  return(reverse(res)))$

/* Computation of the "primary recursion index", the smallest i in {2,...,k}
   with i >= nonmer(k-i+1) + i.
   Prerequisite: k >= 2.
*/
index_nonmersenne_rec(k) :=
  block([i : 2],
    while i < nonmersenne_rec[k-i+1] do i : i + 1,
  return(i))$
/* The alternative recursive formula for nonmersenne_rec[k]: */
nonmersenne_rec2(k) := if k=1 then 2 else block(
 [i : index_nonmersenne_rec(k)],
  nonmersenne_rec[k-i+1]+i)$

/* Analysis of the various steps, for k >= 2:
  [Delta nonmer(k),
   Delta (k -> nonmer(k-i(k)+1))(k),
   i(k+1)-i(k),
   i(k) - nonmer(k-i(k)+1)].
*/
step_nonmersenne_rec(k) := block(
 [i : index_nonmersenne_rec(k),
  ip : index_nonmersenne_rec(k+1)],
  [
   nonmersenne_rec[k+1] - nonmersenne_rec[k],
   nonmersenne_rec[(k+1)-ip+1] - nonmersenne_rec[k-i+1],
   ip-i,
   i - nonmersenne_rec[k-i+1]
  ])$


/* An alternative recursion for nonmersenne(k) for k >= 2:
   The maximal s in {4,...,2k} such that there exists (e_0,e_1) in {2,...,k}^2
   with e_0 + e_1 >= s and nonmersenne(k-e_i+1)+e_i >= s for both i in {0,1}.
*/
nonmersenne_rec3[k] := if k=1 then 2 else last(
 sublist(create_list(i,i,4,2*k),
         lambda([s],
                some_s(lambda([i], is(nonmersenne_rec3[k-i+1]+i >= s
                         and nonmersenne_rec3[k-(s-i)+1]+(s-i) >= s)),
                       create_list(i,i,max(s-k,2),min(s-2,k)))
   )))$


/* For deficiency k and considered minimal variable degree m of a saturated
   non-singular minimally unsatisfiable F of deficiency k, the possible
   pairs [e0,e1] with e0+e1=m and e0 <= e1 of degrees of a variable v of F
   realising degree m, using the upper bound nonmersenne(k') on the degree
   of minimally unsatisfiable clause-sets of deficiency k', obtained by
   splitting on v.
   Additionally to [e0,e1] the triple [k0,d0,k1,d1] is computed, with k0,k1
   the deficiencies after splitting, and d0, d1 the resulting upper bounds
   on the degree of v.
   Prerequisites: k >= 2, 4 <= m <= nonmersenne(k).
*/
possible_degree_pairs_nm(k,m) := block([res : []],
  for e0 : 2 thru min(k,m/2) do block(
   [e1 : m - e0, k0,k1, d0,d1],
    k0 : k-e0+1, k1 : k-e1+1,
    d0 : nonmersenne_rec[k0]+e0, d1 : nonmersenne_rec[k1]+e1,
    if d0 >= m and d1 >= m then res : cons([[e0,e1],[k0,d0,k1,d1]],res)),
  return(reverse(res)))$

/*!
\endhtmlonly
*/
