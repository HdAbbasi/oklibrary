/* Oliver Kullmann, 29.11.2007 (Swansea) */
/* Copyright 2007, 2008 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Satisfiability/Lisp/MinimalUnsatisfiability/Basics.mac
  \brief Operations regarding minimally unsatisfiable clause-sets

Use by

oklib_load("Transitional/ComputerAlgebra/Satisfiability/Lisp/MinimalUnsatisfiability/Basics.mac");

*/

/*!
\htmlonly
*/

oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/BasicOperations.mac");


/* Predicate to decide whether formal clause-set FF implies clause C,
   using solver S. */
impliesp_f(FF,C,S) := not S(apply_pa_f(comp_sl(C),FF))$


/* Returns true iff input FF (formal clause-set) is minimally unsatisfiable.
   The second input, the "solver", shall just return true or false. */
min_unsat_bydef(FF, solver) := not solver(FF) and 
 block([all_sat : true],
  for C in FF[2] unless not all_sat do 
   all_sat : solver([FF[1], disjoin(C, FF[2])]),
  return(all_sat))$
/* More generally, returns true iff input FF (formal clause-set) is 
   irredundant. */
irredundant_bydef(FF, solver) := 
 block([V : FF[1], F : FF[2], redundancy : false],
  for C in F unless redundancy do
   redundancy : impliesp_f([V,disjoin(C,F)],C,S),
  return(not redundancy))$


/* Returns the minimum size of a minimally unsatisfiable sub-clause-set
   of clause-set F; uses sat-solver S */
min_size_mus_bydef(F, S) := if S([var_cs(F),F]) then inf else
 block([k : 0, scls : {}],
  while every(lambda([G], S([var_cs(G),G])), scls) do (
   k : k+1, scls : powerset(F, k)),
 return(k))$

/* Decides whether clause-set F contains a (minimally) unsatisfiable 
   sub-clause-set of size at most k; uses sat-solver S */
contains_us_bydef(F, k, S) := 
 not every(lambda([G], S([var_cs(G),G])), powerset(F,k))$

/* Returns some minimally unsatisfiable sub-clause-set of input FF,
   a formal unsatisfiable clause-set (trivial heuristics, removing
   the first possible clause). */
first_mus_fcs(FF, S) := block(
 [V : FF[1], F : FF[2], Core : {}],
  for C in FF[2] do (
      if S([V, disjoin(C,F)]) then 
        Core : adjoin(C,Core) 
      else F : disjoin(C,F)),
  return([V,Core]))$
/* More generally, returns some irredundant core of input FF,
   (trivial heuristics, removing the first possible clause). */
first_irr_fcs(FF, S) := block(
 [V : FF[1], F : FF[2], Core : {}],
    for C in FF[2] do
      if not impliesp_f([V,disjoin(C,F)],C,S) then 
        Core : adjoin(C,Core)
      else F : disjoin(C,F),
  return([V,Core]))$

/* Returns the set of all irredundant clauses (for unsatisfiable
   clause-sets also called necessary clauses) for input FF. */
all_irr_bydef(FF,S) := block([V : FF[1], F : FF[2], I : {}],
  for C in F do 
    if not impliesp_f([V,disjoin(C,F)],C,S) then I : adjoin(C,I),
  return(I))$

/* The set of all irredundant cores of a formal clause-set, using
   solver S. */

monitor_message_all_irr_cores_bydef() := 
  if oklib_monitor and oklib_monitor_level >= 1 then
    print("all_irr_cores_bydef: ENTRY;", statistics_cs(FF[2]), ",", statistics_cs(I))$

all_irr_cores_bydef(FF,S) := block(
 [I : all_irr_bydef(FF,S), counter_irr : 0], 
  monitor_message_all_irr_cores_bydef(),
  all_forced_irr_cores_bydef(I, setdifference(FF[2],I), S))$


/* The set of all irredundant cores of union(Forced,Possible) which contain 
   the given "forced" clauses. Prerequisite: 
    - Forced is irredundant,
    - Forced, Possible are disjoint. */
/* Uses inherited variable counter_irr. */

monitor_message_1_all_forced_irr_cores_bydef() := 
  if oklib_monitor and oklib_monitor_level >= 2 then (
    print("all_forced_irr_cores_bydef:"),
    print("Forced:", statistics_cs(Forced)),
    print("Possible:", statistics_cs(Possible)))$
monitor_message_2_all_forced_irr_cores_bydef() := 
  if oklib_monitor then (
    counter_irr : counter_irr + 1, 
    print("all_forced_irr_cores_bydef: found no.", counter_irr, ",", statistics_cs(Forced)),
    if oklib_monitor_level >= 2 then print(Forced))$
monitor_message_3_all_forced_irr_cores_bydef() := 
  if oklib_monitor and oklib_monitor_level >= 2 then 
    print("all_forced_irr_cores_bydef: candidate =", C)$

all_forced_irr_cores_bydef(Forced, Possible, S) := block(
 [V : var_cs(Forced), candidate : []],
  monitor_message_1_all_forced_irr_cores_bydef(),
  for C in Possible unless not emptyp(candidate) do (
    Possible : disjoin(C, Possible),
    if not impliesp_f([V,Forced],C,S) then candidate : [C]),
  if emptyp(candidate) then (
    monitor_message_2_all_forced_irr_cores_bydef(),
    return({Forced})
  ),
  block(
   [C : candidate[1], FF : cs_to_fcs(union(Forced,Possible)), Cores_with_C],
    monitor_message_3_all_forced_irr_cores_bydef(),
    Cores_with_C : all_forced_irr_cores_bydef(adjoin(C,Forced),Possible,S),
    if not impliesp_f(FF,C,S) then
      return(Cores_with_C)
    else 
      return(union(Cores_with_C,all_forced_irr_cores_bydef(Forced,Possible,S)))))$


/*!
\endhtmlonly
*/
