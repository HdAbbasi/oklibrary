/* Oliver Kullmann, 29.7.2007 (Swansea) */
/* Copyright 2007 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Satisfiability/Lisp/BranchingTuples/Basic.mac
  \brief Maxima-implementations for the tau-function    

Use by

load("$OKPLATFORM/OKsystem/Transitional/ComputerAlgebra/Satisfiability/Lisp/BranchingTuples/Basic.maxima");

where $OKPLATFORM has to be replaced by the path to the OKplatform directory.
*/

/*!
\htmlonly
*/

/*
*******************************************************
*   Computing the tau-function                        *
*******************************************************
*/

chi(t,x) := apply("+", x^(-t));

/* Computing the tau-function by the Newton-method
   (using (standard) floating point numbers): */
load (descriptive)$
load (newton1)$
tau_eps(t,eps) := (local(t,eps,xl), newton(chi(t,xl)-1, xl, length(t)^(1/mean(t)), eps));
taun_eps([v]) := (local(v), tau_eps(rest(v,-1), last(v)));
tau(t) := (local(t), tau_eps(float(t), 10^-15));
taun([v]) := (local(v), tau(v));
tau2(x,y) := (local(x,y), taun(x,y));
tau3(x,y,z) := (local(x,y,z), taun(x,y,z));
/* floatnump(tau(t)) is true */

/* The tau-function, using interval-halving: */
tau_ih(t) := (local(t, xl),
    if (length(t) = 1) then 1 else
    block( [ lb : float(length(t)^(1/mean(t))), ub : float(length(t)^(1/lmin(t)))],
      if (signum(chi(t,lb)-1) * signum(chi(t,ub)-1) >= 0) then
        return(ub)
      else
        return(find_root(chi(t,xl)=1, xl, lb, ub))
    ));
taun_ih([t]) := (local(t), tau(t));
tau2_ih(x,y) := (local(x,y), taun(x,y));
tau3_ih(x,y,z) := (local(x,y,z), taun(x,y,z));

/*
*******************************************************
*   Derivatives of the tau-function                   *
*******************************************************
*/

/* The total differential for the tau-function */
Dtau(t) := (local(t), block( [ tv : tau(t)], block( [pv : tv^(-t) ],
  return((- tv * log(tv) / apply("+", t * pv)) * pv)
)));
Dtaun([t]) := (local(t), Dtau(t));
Dtau2(x,y) := (local(x,y), Dtaun(x,y));
Dtau3(x,y,z) := (local(x,y,z), Dtaun(x,y,z));

/* Symbolic differentiation of tau2 */
Dtau2s(x,y) := (local(x,y), block( [ tv : tau2s(x,y)], block( [pv : tv^(-[x,y]) ] ,
  return((- tv * log(tv) / apply("+", [x,y] * pv)) * pv)
)));
gradef(tau2s(x,y), Dtau2s(x,y)[1], Dtau2s(x,y)[2]);

/*
*******************************************************
*   The induced probability distribution              *
*******************************************************
*/

/* The probability distribution derived from a branching tuple: */
tprob(t) := (local(t), tau(t)^(-t));
tprobn([t]) := (local(t), tprob(t));
tprob2(x,y) := (local(x,y), tprobn(x,y));
tprob3(x,y,z) := (local(x,y,z), tprobn(x,y,z));

/*
**********************************************************************
*   Convexity considerations: the associated super-linear functions  *
**********************************************************************
*/

/* Auxiliary function to test for zero */
zerop(x) := (local(x), is(equal(x,0)));
notzerop(x) := (local(x), not zerop(x));
/* Auxiliary function to test whether all entries of a list are zero */
lzerop(l) := (local(l), is(emptyp(sublist_indices(l, notzerop))));
taumean(t) := (local(t), if lzerop(t) then 0 else float(log(length(t))) / log(tau(t)));
/* assume length(t) >= 2 */
taumeann([t]) := (local(t), taumean(t));
taumean2(x,y) := (local (x,y), taumeann(x,y));
taumean3(x,y,z) := (local(x,y,z), taumeann(x,y,z));

meann([t]) := (local(t), mean(t));
gmean(t) := (local(t), apply("*", t)^(1/length(t)));
gmeann([t]) := (local(t), gmean(t));
hmean(t) := (local(t), length(t) / apply("+", t^(-1)));
hmeann([t]) := (local(t), hmean(t));
genmean(t, p) := (local(t,p), if is(equal(p,0)) then gmean(t) else
  mean(t^p)^(1/p));
genmeann([u]) := (local(u), genmean(rest(u,-1), last(u)));
genmean2(x,y,p) := (local(x,y,p), genmeann(x,y,p));
genmean3(x,y,z,p) := (local(x,y,z,p), genmeann(x,y,z,p));

/*
*******************************************************
*   Convexity considerations: line versions           *
*******************************************************
*/


/* Considerung for a branching tuple t0 and a direction d0 (a real vector of the same
length as t) the function x -> tau(t0 + x * d0) : */

tau_line(x) := (local(x), tau(t0 + x * d0));
logtau_line(x) := (local(x), log(tau(t0 + x * d0)));
loglogtau_line(x) := (local(x), log(logtau_line(x)));
tprob_line(x) := (local(x), tprob(t0 + x * d0)[i0]);
taumean_line(x) := (local(x), taumean(t0 + x * d0));
/* assume(length(t0) >= 1), assume(t0[i] > 0) */
taumeandiff_line(x) := (local(x, t), 
  block([t : t0 + x * d0], taumean(t) - genmean(t, p0))
);

/* Returning the interval bounds (for the open interval): */
tau_line_dom() := block(
  [pos : sublist_indices(d0, lambda([x], x > 0)), neg : sublist_indices(d0, lambda([x], x < 0))],
  [lmax(- part(t0, pos) / part(d0,pos)), lmin(- part(t0, neg) / part(d0, neg))]
);


/* The chi-function on a line (but chi(t,x) only for x > 1): */
chi_line(x) := (local(x), chi(t0 + x * d0, a0 + x * b0));
/* assume(length(t0) >= 2), assume(t0[i] > 0), assume(a0 > 1) */

chi_line_dom() :=
 block([ts : append(t0, [a0 - 1]), ds : append(d0, [b0])], 
   block(
    [pos : sublist_indices(ds, lambda([x], x > 0)), neg : sublist_indices(ds, lambda([x], x < 0))],
    [lmax(- part(ts, pos) / part(ds,pos)), lmin(- part(ts, neg) / part(ds, neg))]
));

chin([u]) := (local(u), chi(rest(u,-1), last(u)));
chi2(t1,t2,x) := (local(t1,t2,x), chin(t1,t2,x));
chi3(t1,t2,t3,x) := (local(t1,t2,t3,x), chin(t1,t2,t3,x));

hess_chi2 : hessian(chi2(t1,t2,x),[t1,t2,x]);
/* if for example x has a value, then apply remvalue(x), or, better, kill(x) */

eigen_chi2(a,b,c) := (local(a,b,c), eigens_by_jacobi(at(hess_chi2, [t1=a,t2=b,x=c])));
/* a, b > 0, c > 1 */
test_posdef_chi2(a,b,c) := (local(a,b,c), lmin(eigen_chi2(a,b,c)[1]));

/*!
\endhtmlonly
*/
