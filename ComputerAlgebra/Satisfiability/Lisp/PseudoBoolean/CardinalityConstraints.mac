/* Matthew Gwynne, 15.7.2009 (Swansea) */
/* Copyright 2009, 2010 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Satisfiability/Lisp/PseudoBoolean/CardinalityConstraints.mac
  \brief Translating cardinality constraints into CNF

  Encoding p <= x_1 + ... + x_k <= q for given boolean literals x_1, ..., x_k
  and natural numbers p, q.


Use by

oklib_load("OKlib/ComputerAlgebra/Satisfiability/Lisp/PseudoBoolean/CardinalityConstraints.mac");

*/

/*!
\htmlonly
*/

oklib_include("OKlib/ComputerAlgebra/DataStructures/Lisp/Lists.mac")$
oklib_include("OKlib/ComputerAlgebra/Hypergraphs/Lisp/SetSystems.mac")$
oklib_include("OKlib/ComputerAlgebra/DataStructures/Lisp/HashMaps.mac")$


/*
  A "(boolean) cardinality-constraint" ("crd") is a triple [a,L,b],
  where a, b are natural numbers >= 0 or inf, while L is a list of
  (boolean) literals (allowing repetitions and complementary literals).
  The meaning is "a <= sum(L) <= b", where sum(L) counts the satisfied
  literals.
*/

/* ***************************************
   * Simplifying cardinality constraints *
   ***************************************
*/

/*
  A "sorted cardinality constraint" ("scrd") is a triple [lb,C0,ub] similar
  to above, but where C0 now is an ordered set-map, sorted by descending
  values, which assigns to the occurring literals their counts (natural
  numbers >= 1).
*/

/* Translating a cardinality constraint into a sorted cardinality constraint,
   sorting literals with equal counts in the build-in order:
*/
crd2scrd(C) := [C[1], sort(list_distribution(C[2]), lambda([p1,p2], is(second(p1)>=second(p2)))), C[3]]$

/* Removing tautologies from a sorted cardinality constraint.
   Returned is the equivalent sorted cardinality constraint, where for
   every clashing pair of literals the literal(s) attaining the min-count
   are removed, while the bounds are reduced by the min-count.
*/
remove_tautologies_scrd(C) := block(
[a : C[1], b : C[3], h : osm2hm(C[2]), NC],
 NC : map(
  lambda([P], block([cneg : ev_hm(h,-P[1])],
    if cneg=false then P
    else block([cpos : ev_hm(h,P[1])],
      if cpos=0 then 0
      else (
        set_hm(h,-P[1],0),
        [a,b] : [a,b] - cneg,
        if cpos=cneg then 0
        else [P[1],cpos-cneg]
      )))),
  C[2]),
 [a,delete(0,NC),b])$


/* **********************
   * Direct translation *
   **********************
*/

/* Translating a cardinality constraint into a CNF-clause-list (which has
   first the clauses for the lower bound, and then the clauses for the
   upper bound):
*/
direct_crd2cl(C) := block([R : remove_tautologies_scrd(crd2scrd(C)), a, b, D],
 [a : R[1], D : R[2], b : R[3]],
  append(direct_crd2cl_ge(D, a), direct_crd2cl_lt(D, b+1)))$

/*  Given a sorted cardinality constraint [0,D,ub-1] without tautological
    literal-pairs, compute the equivalent clause-list.
    The order of the clause-list is as follows:
 1. The major sorting is given by the order of D (regarding the literals).
 2. For a given literal x, first the clauses containing -x and then the clauses
    not containing the underlying variable are taken.
*/
direct_crd2cl_lt(D,ub) := if ub <= 0 then [{}]
 elseif emptyp(D) then []
 else block([p : first(D), x, c, with_x, without_x],
  x : first(p),
  c : second(p),
  with_x : direct_crd2cl_lt(rest(D), ub-c),
  without_x : direct_crd2cl_lt(rest(D), ub),
  with_x : remove_elements(without_x,with_x),
  with_x : add_element_l(-x,with_x),
  append(with_x, without_x)
)$

/* Given a sorted cardinality constraint [lb,D,inf] without tautological
   literal-pairs, compute the equivalent clause-list: */
direct_crd2cl_ge(D,lb) := if lb <= 0 then [] else
 block([s : sum_l(map(second,D))],
  if lb > s then [{}]
  else direct_crd2cl_lt(map(lambda([p], [-first(p),second(p)]),D), s-lb+1))$

/* Translating a list of cardinality constraints into a list of
   CNF-clause-lists:
*/
direct_crdl2cl(F) := lappend(map(direct_crd2cl,F))$

/* Translating a formal clause-cardinality-list into a formal clause-list:
*/
direct_fccrdl2fcl(FF) := [FF[1], append(FF[2], direct_crdl2cl(FF[3]))]$


/* ************************
   * Using unary encoding *
   ************************
*/

/* The algorithm below is from "Efficient CNF Encoding of Boolean Cardinality 
   Constraints" by Olivier Bailleux and Yacine Boufkhad, LNCS 2833 (Springer),
   2003, pages 102-122.
*/

/*
   A "CNF representation of a cardinality constraint [a,L,b]" is a clause-set
   F with var(L) <= var(F), whose satisfying assignments restricted to var(L)
   are exactly those of the condition [a,L,b], and such that every satisfying
   assignment for [a,L,b] has exactly one extension to a satisfying assignment
   of F.

   A CNF representation of a boolean cardinality constraint [a,L,b] with
   "detection of forced assignments via UCP" is a CNF representation of [a,L,b]
   with the property that for every partial assignment phi with
   var(phi) <= var(L) and every forced assignment <v -> e> for apply_pa(phi,F)
   with v in var(L), applying unit-clause-propagation to apply_pa(phi,F)
   includes this forced assignment (i.e., UCP derives all forced assignments
   for apply_pa(phi,F) which concern the cardinality constraint).
*/

/*
   The following algorithm, from the above mentioned paper, computes a CNF
   representation F of the cardinality constraint [a,L,b] with detection of
   forced assignments via UCP.
OK: which algorithm??? Obviously all the explanation must directly relate
to the functions implemented here.

   The algorithm takes as input a list E of literals, and then introduces
   a list of new (distinct) variables S of the same size as E, which under any
   assignment will have the unary representation (ones/trues appearing from
   the left) of the cardinality of E. The remainder of the algorithm consists
   of two phases, the totalizer and the comparator, and the clauses
   generated (and variables introduced) by these phases are then appended
   together to produce the final clause-set. The totalizer enforces that
   S is the unary representation of the cardinality of L and the comparator
   enforces that this unary representation represents a number in the range
   a to b.

   The totalizer takes as input a list E of input variables, and as
   output a list S of cardinality variables, and returns a list of
   clauses that enforce that S is a unary representation of E. This
   is done in a recursive manner, through the introduction of new variables,
   and clauses enforcing unary addition.
   
   In the totalizer, E is split into two sublists E_1 and E_2, where E_1 is
   the list of the first floor(length(E)/2) elements and E_2 is the remainder
   of E. The algorithm then introduces two lists of new (distinct) variables
   S_1 and S_2, where S_1 and S_2 are the same size as E_1 and E_2
   respectively. Totalizer is then run again for each of these sublists E_1
   with S_1 and E_2 with S_2 returning (new) variable and clause lists V_1,C_1
   and V_2,C_2 respectively, and then the following clauses (C_3) are
   generated to enforce that in any satisfying assignment of F, we have that S
   is the unary addition of S_1 and S_2:


     for every 
       0 <= a <= length(E_1) and 
       0 <= b <= length(E_2) and
       0 <= c <= length(L) such that
       a + b = c we add the clauses

         1) {-S_1[a],-S_2[b],S[c]} and
	 2) {S_1[a+1], S_2[b+1], S[c+1]}

   where (1) ensures (S_1[a] and S_2[b]) => S[a+b]), i.e., the unary
   addition holds in one direction and (2) ensures
   (S[a+b+1] => (S_1[a+1] or S_2[b+1]), i.e., the other direction, and we have
       
     S_1[0] = S_2[0] = S[0] = 1 and 
     S_1[length(E_1)+1] = S_2[length(E_2)+1] = S[length(L)+1] = 0

   for the extreme cases for the above clauses.

   In the base case where length(E) = 1, totalizer takes S_1 = E_1, and
   S_2 = E2, since E_1 and E_2 are their own unary representations.

   The comparator generates a list of unit clauses

       [{S[1]},...,{S[a]},{S[b+1]},...,{S[length(L)]}]

   which ensures that, given that the totalizer ensures that S is the unary
   representation of the cardinality of E, any satisfying assignment
   which results in E having a cardinality less than a, or greater than b, 
   is a falsifying assignment for F.

   To use this algorithm see cardinality_cl.

*/

/* Variables are "ctt(a,b,i)", meaning the i-th new variable in the
   list of variables which are used for the unary representation of the
   sublist [S[a],...,S[b]] of S. 
*/
kill(ctt)$
declare(ctt, noun)$
declare(ctt, posfun)$
ctt_var(a,b,i) := nounify(ctt)(a,b,i)$

/* Given a list S of "output" variables and a list E of "input" literals
   of the same length, the result is a clause-list F encoding that S is a 
   unary representation of the cardinality of L, where any forced
   assignments follow by UCP. Note that S and E should be disjoint, and S
   should contain distinct variables, although E may contain repetitions.
   
   Here var_cs(F) = append(S,E,V) where variables in V are described
   in the definition of "ctt" above.
 
   The list of new variables introduced by this function can therefore be 
   recursively defined using a function vc, where
   V = rest(vc(E,1,length(E)), length(E)):

   vc(E,a,b) = [] if a == b
             else append(
               E, 
               vc([ctt(a,ceiling((a+b)/2-1),1),...,
                   ctt(a,ceiling((a+b)/2-1),floor(length(E)/2))],
                 a,floor((a+b)/2)),
               vc([ctt(ceiling((a+b)/2-1)+1,b,1),...,
                 ctt(ceiling((a+b)/2-1)+1,ceiling(length(E)/2))],
                 ceiling((a+b)/2-1)+1,b))

   Therefore the number of new variables introduced given length(E) = n is
   nvc(n) - n where nvc is defined recursively in the following way:

   nvc(n) = 0 if n < 1
            n + nvc(floor(n/2)) + nvc(ceiling(n/2)) otherwise

   Assuming S is without complimentary literals, a partial assignment phi
   satisfies F iff phi is total and given n is the cardinality of E under phi,
   we have that

     phi(S[i]) = 1 for 1 <= i <= n and phi(S[i]) = 0 for i > n,

   and given m is the cardinality of E[1,...,floor(length(E)/2)] we have

     phi(ctt(1,floor(length(E)/2),i)) = 1 for 1 <= i <= m and
     phi(ctt(1,floor(length(E)/2),i)) = 0 otherwise

   and given m' is the cardinality of E[floor(length(E)/2)+1,...,length(E)]
   we have
   
     phi(ctt(floor(length(E)/2)+1,length(E),i)) = 1 for 1 <= i <= m' and
     phi(ctt(floor(length(E)/2)+1,length(E),i)) = 0 otherwise

   and for all a and b such that we have a new variable ctt(a,b,i) for some i,
   if b-a = 2 then we have

     phi(ctt(a,b,1)) = phi(E[a]) xor phi(E[b])
     phi(ctt(a,b,2)) = phi(E[a]) and phi(E[b])

   if b-a = 3 then we have

     phi(ctt(a,b,1)) = phi(E[a]) or phi(ctt(a+1,b,1))
     phi(ctt(a,b,2)) = (phi(E[a]) and phi(ctt(a+1,b,1))) or phi(ctt(a+1,b,2))
     phi(ctt(a,b,3)) = phi(E[a]) and phi(ctt(a+1,b,2))

   and if b-a > 3 then we have

     phi(ctt(a,b,i)) =
       there exist j,k such that j+k=i
         phi(ctt(a,ceiling(a+b/2-1),j)) and phi(ctt(ceiling(a+b/2-1)+1,b,k))

   i.e., in each case [ctt(a,b,1),...,ctt(a,b,b-a+1)] is the
   representation of the unary addition of E[a] and E[b], E[a] and
   [ctt(a+1,b,1),ctt(a+1,b,2)] or [ctt(a,b',1),...,ctt(a,b',b'-a+1)] and
   [ctt(b'+1,b,1),...,ctt(b'+1,b,b-b')] respectively depending on
   a and b, where b' = ceiling((a+b)/2-1).

   cardinality_totalizer_r_cl is a function with additional parameters
   to keep track of any new variables introduced, and has the same
   specification as cardinality_totalizer_cl, except
   V = rest(vc(E,a,b), length(E)).
   
*/
cardinality_totalizer_cl(S,E) := cardinality_totalizer_r_cl(S,E,1,length(E))$
cardinality_totalizer_r_cl(S,E, a,b) := 
  if length(E) < 1 then []
  else block(
     [subtree_a : [], subtree_b : [], m_a,m_b, level,
      cs :[],V_a,V_b,m:length(E)],
    /* work out CNFs for the two children of this node */
    m_a : floor(m / 2), m_b : (m - m_a),
    if m_a > 1 then (
      V_a : map(
        lambda([i],ctt_var(a,ceiling((a+b)/2-1),i)),
        create_list(i,i,1,m_a)),
      subtree_a : cardinality_totalizer_r_cl(V_a,take_elements(m_a,E), 
        a,ceiling((a+b)/2-1)))
    else
      V_a : take_elements(m_a,E),
    if m_b > 1 then (
      V_b : map(
        lambda([i],ctt_var(ceiling((a+b)/2-1)+1,b,i)),
        create_list(i,i,1,m_b)),
      subtree_b : cardinality_totalizer_r_cl(V_b,rest(E,m_a),
        ceiling((a+b)/2-1)+1,b))
    else
      V_b : rest(E,m_a),
    /* generate clauses ensuring correct unary representation for this node */
    for alph : 0 thru m_a do
      for beta : 0 thru m_b do block([sigma : alph+beta],
        if sigma > 0 then
        cs : cons(union(
            if alph > 0 then {-V_a[alph]} else {},
            if beta > 0 then {-V_b[beta]} else {},
            {S[sigma]}), cs),
        if sigma < m then
        cs : cons(union(
            if alph < m_a then {V_a[alph+1]} else {},
            if beta < m_b then {V_b[beta+1]} else {},
            {-S[sigma+1]}),
          cs)
      ),
    if oklib_monitoring then print("Finished level ", tree_pos),
    return(append(subtree_a, subtree_b, cs))
  )$


/* Given a list S of variables together with p, q, produces a clause-list F 
   whose satisfying assignments are those total assignments where the first
   p variables are set to true, and all variables from the (q+1)-th onwards 
   are set to false.

   The clause list returned is simply a list of length(S) - (q-p) unit clauses
   where the first p variables in S occur as the first p (positive) literals in
   unit clauses and the last (length(S)-q+1) variables occur as negative
   literals in the later unit clauses.

   No new variables are introduced.
*/
cardinality_comparator_cl(S,p,q) := 
  append(
    map(set,take_elements(p,S)),map(set,map("-",rest(S,q))))$

/* Given a list E of literals, and integers p and q returns a clause-list F
   which is a CNF representation of the boolean cardinality constraint [p,E,q]
   with detection of forced assignments via UCP.

   The variables V in the output clause-list F are append(E,S,S') where
   S = [ctt([],1),...,ctt([],length(E))] and S' is the list of new
   variables introduced by cardinality_totalizer_cl(S,E) (see definition).

   The satisfying partial assignments for F are those assignments which
   satisfy both cardinality_comparator_cl(S,p,q) and
   cardinality_totalizer_cl(S,E) where
   S = create_list(ctt(1,length(E),i),i,1,length(E)) .

*/
cardinality_cl(C) := block(
  [p : C[1], E : C[2], q : C[3],S],
  S : create_list(ctt_var(1,length(E),i),i,1,length(E)),
  return(
    append(cardinality_totalizer_cl(S,E),cardinality_comparator_cl(S,p,q))))$

/*!
\endhtmlonly
*/
