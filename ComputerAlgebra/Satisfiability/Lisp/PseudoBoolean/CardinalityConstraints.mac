/* Matthew Gwynne, 15.7.2009 (Swansea) */
/* Copyright 2009, 2010 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Satisfiability/Lisp/PseudoBoolean/CardinalityConstraints.mac
  \brief Translating cardinality constraints into CNF

  Encoding p <= x_1 + ... + x_k <= q for given boolean literals x_1, ..., x_k
  and natural numbers p, q.


Use by

oklib_load("OKlib/ComputerAlgebra/Satisfiability/Lisp/PseudoBoolean/CardinalityConstraints.mac");

*/

/*!
\htmlonly
*/

oklib_include("OKlib/ComputerAlgebra/DataStructures/Lisp/Lists.mac")$
oklib_include("OKlib/ComputerAlgebra/Hypergraphs/Lisp/SetSystems.mac")$
oklib_load("OKlib/ComputerAlgebra/DataStructures/Lisp/HashMaps.mac")$


/*
  A "(boolean) cardinality-constraint" ("crd") is a triple [a,L,b],
  where a, b are natural numbers >= 0 or inf, while L is a list of
  (boolean) literals (allowing repetitions and complementary literals).
  The meaning is "a <= sum(L) <= b", where sum(L) counts the satisfied
  literals.
*/

/* ***************************************
   * Simplifying cardinality constraints *
   ***************************************
*/

/*
  A "sorted cardinality constraint" ("scrd") is a triple [lb,C0,ub] similar
  to above, but where C0 now is an ordered set-map, sorted by descending
  values, which assigns to the occurring literals their counts (natural
  numbers >= 1).
*/

/* Translating a cardinality constraint into a sorted cardinality constraint,
   sorting literals with equal counts in the build-in order:
*/
crd2scrd(C) := [C[1], sort(list_distribution(C[2]), lambda([p1,p2], is(second(p1)>=second(p2)))), C[3]]$

/* Removing tautologies from a sorted cardinality constraint.
   Returned is the equivalent sorted cardinality constraint, where for
   every clashing pair of literals the literal(s) attaining the min-count
   are removed, while the bounds are reduced by the min-count.
*/
remove_tautologies_scrd(C) := block(
[a : C[1], b : C[3], h : osm2hm(C[2]), NC],
 NC : map(
  lambda([P], block([cneg : ev_hm(h,-P[1])],
    if cneg=false then P
    else block([cpos : ev_hm(h,P[1])],
      if cpos=0 then 0
      else (
        set_hm(h,-P[1],0),
        [a,b] : [a,b] - cneg,
        if cpos=cneg then 0
        else [P[1],cpos-cneg]
      )))),
  C[2]),
 [a,delete(0,NC),b])$


/* **********************
   * Direct translation *
   **********************
*/

/* Translating a cardinality constraint into a CNF-clause-list (which has
   first the clauses for the lower bound, and then the clauses for the
   upper bound):
*/
direct_crd2cl(C) := block([R : remove_tautologies_scrd(crd2scrd(C)), a, b, D],
 [a : R[1], D : R[2], b : R[3]],
  append(direct_crd2cl_ge(D, a), direct_crd2cl_lt(D, b+1)))$

/*  Given a sorted cardinality constraint [0,D,ub-1] without tautological
    literal-pairs, compute the equivalent clause-list.
    The order of the clause-list is as follows:
 1. The major sorting is given by the order of D (regarding the literals).
 2. For a given literal x, first the clauses containing -x and then the clauses
    not containing the underlying variable are taken.
*/
direct_crd2cl_lt(D,ub) := if ub <= 0 then [{}]
 elseif emptyp(D) then []
 else block([p : first(D), x, c, with_x, without_x],
  x : first(p),
  c : second(p),
  with_x : direct_crd2cl_lt(rest(D), ub-c),
  without_x : direct_crd2cl_lt(rest(D), ub),
  with_x : remove_elements(without_x,with_x),
  with_x : add_element_l(-x,with_x),
  append(with_x, without_x)
)$

/* Given a sorted cardinality constraint [lb,D,inf] without tautological
   literal-pairs, compute the equivalent clause-list: */
direct_crd2cl_ge(D,lb) := if lb <= 0 then [] else
 block([s : sum_l(map(second,D))],
  if lb > s then [{}]
  else direct_crd2cl_lt(map(lambda([p], [-first(p),second(p)]),D), s-lb+1))$

/* Translating a list of cardinality constraints into a list of
   CNF-clause-lists:
*/
direct_crdl2cl(F) := lappend(map(direct_crd2cl,F))$

/* Translating a formal clause-cardinality-list into a formal clause-list:
*/
direct_fccrdl2fcl(FF) := [FF[1], append(FF[2], direct_crdl2cl(FF[3]))]$


/* ************************
   * Using unary encoding *
   ************************
*/

/* The algorithm below is from "Efficient CNF Encoding of Boolean Cardinality 
   Constraints" by Olivier Bailleux and Yacine Boufkhad.
   Journal : LNCS
   Volume : 2833
   Pages : 102-122
   Publisher : Springer Berlin
   Year : 2003
*/

/*
   A CNF representation of a boolean cardinality constraint [a,L,b] with
   detection of forced assignments via UCP is a CNF F with var(L) as a subset
   of var(F) and the property that for every partial assignment phi, if there
   is a forced assignment psi on apply_pa(phi,F) then applying unit clause
   propagation to apply_pa(phi,F) is the same as applying psi to
   apply_pa(phi,F), (i.e., UCP derives all forced assignments of
   apply_pa(phi,F)).

   The following algorithm, from the above mentioned paper, given a boolean
   cardinality constraint [a,L,b], computes a CNF representation F of the
   cardinality constraint with detection of forced assignments via UCP.

   The algorithm takes as input a list E of literals, and then introduces
   a list of new (distinct) variables S of the same size as E, which under any
   assignment will have the unary representation (ones/trues appearing from
   the left) of the cardinality of E. The remainder of the algorithm consists
   of two phases, the totalizer and the comparator, and the clauses
   generated (and variables introduced) by these phases are then appended
   together to produce the final clause-set. The totalizer enforces that
   S is the unary representation of the cardinality of L and the comparator
   enforces that this unary representation represents a number in the range
   a to b.

   The totalizer takes as input a list E of input variables, and as
   output a list S of cardinality variables, and returns a list of
   clauses that enforce that S is a unary representation of E. This
   is done in a recursive manner, through the introduction of new variables,
   and clauses enforcing unary addition.
   
   In the totalizer, E is split into two sublists E_1 and E_2, where E_1 is
   the list of the first floor(length(E)/2) elements and E_2 is the remainder
   of E. The algorithm then introduces two lists of new (distinct) variables
   S_1 and S_2, where S_1 and S_2 are the same size as E_1 and E_2
   respectively. Totalizer is then run again for each of these sublists E_1
   with S_1 and E_2 with S_2 returning (new) variable and clause lists V_1,C_1
   and V_2,C_2 respectively, and then the following clauses (C_3) are
   generated to enforce that in any satisfying assignment of F, we have that S
   is the unary addition of S_1 and S_2:


     for every 
       0 <= a <= length(E_1) and 
       0 <= b <= length(E_2) and
       0 <= c <= length(L) such that
       a + b = c we add the clauses

         1) {-S_1[a],-S_2[b],S[c]} and
	 2) {S_1[a+1], S_2[b+1], S[c+1]}

   where (1) ensures (S_1[a] and S_2[b]) => S[a+b]), i.e., the unary
   addition holds in one direction and (2) ensures
   (S[a+b+1] => (S_1[a+1] or S_2[b+1]), i.e., the other direction, and we have
       
     S_1[0] = S_2[0] = S[0] = 1 and 
     S_1[length(E_1)+1] = S_2[length(E_2)+1] = S[length(L)+1] = 0

   for the extreme cases for the above clauses.

   In the base case where length(E) = 1, totalizer takes S_1 = E_1, and
   S_2 = E2, since E_1 and E_2 are their own unary representations.

   The comparator generates a list of unit clauses

       [{S[1]},...,{S[a]},{S[b+1]},...,{S[length(L)]}]

   which ensures that, given that the totalizer ensures that S is the unary
   representation of the cardinality of E, any satisfying assignment
   which results in E having a cardinality less than a, or greater than b, 
   is a falsifying assignment for F.

   To use this algorithm, currently one needs to use cardinality_cl(L,a,b).

*/

/* Variables are "ctt(L,i)", meaning the i-th new variable at the node whose
   position is denoted by L in the recursive tree generated by the totalizer
   in the algorithm discussed above where L is a list of 0s and 1s, denoting
   a path from the root of a tree to a node in the tree, where each 0 or 1
   from the left of the list, refers to taking the left or right path resp.
   from each node in the tree, starting from the root.

   So for example, given the input [a,L,b], the first set of new variables S
   used for the unary representation of the cardinality of L is
   [ctt([],1),...,ctt([],length(L))] and then for E_1 and E_2
   S_1 = [ctt([0],1),...,ctt([0],length(E_1))] and
   S_2 = [ctt([1],1),...,ctt([1],length(E_2))] and then when totalizer
   is run with E_1 and S_1 the S_1' and S_2' generated in this second call to
   totalizer has
     S_1' = [ctt([0,0],1),...,ctt([0,0],length(E_1'))]
     S_2' = [ctt([0,1],1),...,ctt([0,1],length(E_2'))]
   and when totalizer is run with E_2 and S_2, then the S_1'' and S_2''
   generated by this run of totalizer has
     S_1'' = [ctt([1,0],1),...,ctt([1,0],length(E_1''))]
     S_2'' = [ctt([1,1],1),...,ctt([1,1],length(E_2''))]
   etc.
*/
kill(ctt)$
declare(ctt, noun)$
declare(ctt, posfun)$
ctt_var(L,i) := nounify(ctt)(L,i)$

/* Given a list S of "output" variables and a list E of "input" literals
   of the same length, the result is a clause-list F encoding that S is a 
   unary representation of the cardinality of L. Note that S and E should
   be disjoint, and S should contain distinct variables, although E may
   contain repetitions.
   
   Here var_cs(F) = append(S,E,V) where variables in V are described
   in the definition of "ctt" above.
 
   The list of new variables introduced by this function can therefore be 
   recursively defined using a function vc, where
   V = rest(vc(E,[]), length(E)):

   vc(E,l) = [] if length(E) <= 1
             else append(
               E, 
               vc([ctt(cons(l,0),1),...,ctt(cons(l,0),floor(length(E)/2))],
                 cons(l,0)),
               vc([ctt(cons(l,1),1),...,ctt(cons(l,1),ceiling(length(E)/2))],
                 cons(l,1)))

   Therefore the number of new variables introduced given length(E) = n is
   nvc(n) - n where nvc is defined recursively in the following way:

   nvc(n) = 0 if n < 1
            n + nvc(floor(n/2)) + nvc(ceiling(n/2)) otherwise

*/
cardinality_totalizer_cl(S,E) := cardinality_totalizer_r_cl(S,E,[])$
cardinality_totalizer_r_cl(S,E, tree_pos) := 
  if length(E) < 1 then []
  else block(
     [subtree_a : [], subtree_b : [], m_a,m_b, S_x, level,
      cs :[],V_a,V_b,m:length(E)],
    /* work out the temporary variables for the current level */
    if length(tree_pos) = 0 then
      S_x : S
    else
      S_x : map(lambda([a], ctt_var(tree_pos,a)),create_list(i,i,1,m)),
    /* work out variable lists for the two children of this node */
    m_a : floor(m / 2), m_b : (m - m_a),
    if m_a > 1 then (
      V_a : map(
        lambda([a],ctt_var(cons(0,tree_pos),a)),
        create_list(i,i,1,m_a)),
      subtree_a : cardinality_totalizer_r_cl([],take_elements(m_a,E), 
        cons(0,tree_pos)))
    else
      V_a : take_elements(m_a,E),
    if m_b > 1 then (
      V_b : map(
        lambda([a],ctt_var(cons(1,tree_pos),a)),
        create_list(i,i,1,m_b)),
      subtree_b : cardinality_totalizer_r_cl([],rest(E,m_a), cons(1,tree_pos)))
    else
      V_b : rest(E,m_a),
    /* generate clauses ensuring correct unary representation for this node */
    for alph : 0 thru m_a do
      for beta : 0 thru m_b do block([sigma : alph+beta],
        if sigma > 0 then
        cs : cons(union(
            if alph > 0 then {-V_a[alph]} else {},
            if beta > 0 then {-V_b[beta]} else {},
            {S_x[sigma]}), cs),
        if sigma < m then
        cs : cons(union(
            if alph < m_a then {V_a[alph+1]} else {},
            if beta < m_b then {V_b[beta+1]} else {},
            {-S_x[sigma+1]}),
          cs)
      ),
    if oklib_monitoring then print("Finished level ", tree_pos),
    return(append(subtree_a, subtree_b, cs))
  )$


/* Given a list S of variables together with p, q, produces a clause-list F 
   whose satisfying assignments are those total assignments where the first
   p variables are set to true, and all variables from the (q+1)-th onwards 
   are set to false.

   The clause list returned is simply a list of length(S) - (q-p) unit clauses
   where the first p variables in S occur as the first p (positive) literals in
   unit clauses and the last (length(S)-q+1) variables occur as negative
   literals in the later unit clauses.

   No new variables are introduced.
*/
cardinality_comparator_cl(S,p,q) := 
  append(
    map(set,take_elements(p,S)),map(set,map("-",rest(S,q))))$

/* Given a list E of literals, and integers p and q returns a clause-list F
   which is a CNF representation of the boolean cardinality constraint [p,E,q]
   with detection of forced assignments via UCP.

   The variables V in the output clause-list F are append(E,S,S') where
   S = [ctt([],1),...,ctt([],length(E))] and S' is the list of new
   variables introduced by cardinality_totalizer_cl(S,E) (see definition).

*/
cardinality_cl(E,p,q) := block(
  [S : map(lambda([a],ctt_var([],a)),create_list(i,i,1,length(E)))],
  return(
    append(cardinality_totalizer_cl(S,E),cardinality_comparator_cl(S,p,q))))$

/*!
\endhtmlonly
*/
