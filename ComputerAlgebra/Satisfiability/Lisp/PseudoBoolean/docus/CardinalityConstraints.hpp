// Matthew Gwynne, 29.7.2009 (Swansea)
/* Copyright 2009 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Satisfiability/Lisp/PseudoBoolean/docus/CardinalityConstraints.hpp
  \brief How to use the translations of cardinality constraint generators into CNF


  <h1> Cardinality constraints via Maxima in the OKlibrary </h1>


  <h2> Translating cardinality constraints into CNF </h2>

  <ul>
   <li> Assuming the user has some SAT problem with variable set V,
   and some subset W of V, for which the user wishes to express that
   p <= sum(W) <= q, then a clause set representing the additional clauses
   can be generated in the following way:
   \verbatim
W : {1,2,3,4,5}$
p : 2$ q : 4$
F : cardinality_cs(listify(W),p,q);
   \endverbatim
   </li>
   <li> New variables of the form ctt(l,i) where l is a list of 1's and 0's
   and i is a non-negative integer, are included in the generated clause set
   (see
   ComputerAlgebra/Satisfiability/Lisp/PseudoBoolean/CardinalityConstraints.mac for
   further details), and so care must be taken to avoid clashing variables
   when adding the additional clauses generated by cardinality_cs to the
   original problem. </li>
  </ul>


  <h2> Special properties of specific generators </h2>

  <ul>
   <li> A property of the clause-set generated by cardinality_cs is 
   that, given an arbitrary partial assignment, unit-clause propagation will 
   "pick up" any forced assignments. </li> 
   <li> For example:
   \verbatim
F : cardinality_cs([1,2],1,1);
ucp_lpa_0_cs(apply_pa_cs({1},F))[2];
  [{ctt([],1),-ctt([],2)},{-2}]
ucp_lpa_0_cs(apply_pa_cs({2},F))[2];
  [{ctt([],1),-ctt([],2)},{-1}]
   \endverbatim
   etc. Notice how, providing the constraint "1 + 2" = 1, and then setting
   either 1 or 2 to 1, immediately enforces by UCP that variable 2 or 1 
   (resp.) must be false. </li> 
   <li> A property of the clause-set generated by
   cardinality_totalizer_cs is that, given an arbitrary partial assignment, 
   unit clause propagation will immediately pick up any forced assignments.
   </li>
OK: What is the meaning of the next example??? There are NO EXPLANATIONS!
   <li> For example:
   \verbatim
F : cardinality_totalizer_cs([3,4],[1,2]);
ucp_lpa_0_cs(apply_pa_cs({1},F));
[{{-4,2},{-2,4}},[{3}]]
ucp_lpa_0_cs(apply_pa_cs({2},F));
[{{-4,1},{-1,4}},[{3}]]
ucp_lpa_0_cs(apply_pa_cs({4},F));
[{},[{1,2},{3}]]
   \endverbatim
   </li>
   etc. Notice how, variable 3 is forced by UCP (and is being set to 1) in the 
   cases where 1 or 2 is set to 1, as, in the unary representation
   3 must be set to 1 if any variable is set to true. </li>
   <li> Given an arbitrary partial assignment, the clause-set generated by
   cardinality_comparator_cs can be reduced to the empty clause-set (after 
   applying the assignment) by UCP iff no variable in the first m variables of
   S is set to false, and no variable in the last (length(S) - n) variables is 
   set to true, otherwise it reduces by UCP to the empty clause. </li>
  </ul>

*/
