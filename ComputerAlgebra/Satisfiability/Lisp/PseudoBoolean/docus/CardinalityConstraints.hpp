// Matthew Gwynne, 29.7.2009 (Swansea)
/* Copyright 2009 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Satisfiability/Lisp/Generators/docus/CardinalityConstraints.hpp
  \brief How to use the cardinality constraint generators


  <h1> Cardinality constraints via Maxima in the OKlibrary </h1>


  <h2> Generating cardinality constraints </h2>

  <ul>
   <li> Assuming the user has some other SAT problem with variable set "V",
   and some subset "W" of "V", for which the user wishes to express that
   n <= sum(W) <= m, then a clause set representing the additional clauses
   can be generated in the following way:
   \verbatim
W : {1,2,3,4,5}$
n : 2$ m : 4$
cs : cardinality_cs(listify(W),n,m)$
   \endverbatim
   </li>
   <li> New variables of the form "ctt(l,i)" where "l" is a list of 1's and 0's
   and i is a non-negative integer are included in the generated clause set
   (See
   ComputerAlgebra/Satisfiability/Lisp/Generators/CardinalityConstraints.mac for
   further details) and so care must be taken to avoid clashing literals  when 
   adding the additional clauses generated by "cardinality_cs" to the original 
   problem. </li>
  </ul>

  <h2> Special properties of specific generators </h2>

  <ul>
   <li> A special property of the clause-set generated by "cardinality_cs" is 
   that, given an arbitrary partial assignment, unit-clause propagation will 
   immediately pick up any forced assignments. </li> 
   <li> For example:
   \verbatim
   cs : cardinality_cs([1,2],1,1)$
   ucp_lpa_0_cs(apply_pa({1},standardise_fcs(cs_to_fcs(cs))[1][2]));
   [{},[{-4,3},{-2}]]
   ucp_lpa_0_cs(apply_pa({2},standardise_fcs(cs_to_fcs(cs))[1][2]));
   [{},[{-4,3},{-1}]]
   \endverbatim
   etc. Notice how, providing the constraint 1 + 2 = 1, and then setting
   either 1 or 2 to 1, immediately enforces that 2 or 1 (resp) must be false
   by UCP. </li> 
   <li> A special property of the clause-set generated by
   "cardinality_totalizer_cs" is that, given an arbitrary partial assignment, 
   unit clause propagation will immediately pick up any forced assignments.
   </li>
   <li> For example:
   \verbatim
cs : cardinality_totalizer_cs([3,4],[1,2])$
ucp_lpa_0_cs(apply_pa({1},cs));
[{{-4,2},{-2,4}},[{3}]]
ucp_lpa_0_cs(apply_pa({2},cs));
[{{-4,1},{-1,4}},[{3}]]
ucp_lpa_0_cs(apply_pa({4},cs));
[{},[{1,2},{3}]]
   \endverbatim
   </li>
   etc. Notice how, 3 is forced by UCP (and is being set to 1) in the 
   cases where 1 or 2 is set to 1, as, in the unary representation
   3 must be set to 1 if any variable is set to true. </li>
   <li> Given an arbitrary partial assignment, the clause-set generated by
   "cardinality_comparator_cs" can be reduced to the empty clause-set (after 
   applying the assignment) by UCP iff no variable in the first m variables of
   S is set to false, and no variable in the last (length(S) - n) variables is 
   set to true, otherwise it reduces by UCP to the empty clause. </li>
  </ul>
*/
