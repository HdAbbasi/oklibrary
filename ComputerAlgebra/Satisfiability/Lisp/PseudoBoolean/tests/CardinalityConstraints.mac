/* Matthew Gwynne, 16.7.2009 (Swansea) */
/* Copyright 2009, 2010 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Satisfiability/Lisp/PseudoBoolean/tests/CardinalityConstraints.mac
  \brief Tests for translations of cardinality constraints into CNF

Use by

oklib_load("OKlib/ComputerAlgebra/Satisfiability/Lisp/PseudoBoolean/tests/CardinalityConstraints.mac");

  \bug All tests regarding UCP (and unary encoding) must be removed.
  <ul>
   <li> MG : All tests? Or just those relating to the unproven
   assertion that any forced assignment follows by UCP (and not just forced
   assignments under partial assignments using only the original
   variables)? </li>
   <li> All tests: UCP has nothing to do with these functions. </li>
  </ul>


  \todo The text below regarding unary encoding needs a complete update.


  \bug DONE okltest_unary_bb_totaliser_r_fcl_comb is a no-op

*/

/*!
\htmlonly
*/

oklib_include("OKlib/ComputerAlgebra/TestSystem/Lisp/Asserts.mac")$
oklib_include("OKlib/ComputerAlgebra/Satisfiability/Lisp/PseudoBoolean/CardinalityConstraints.mac")$
oklib_include("OKlib/ComputerAlgebra/Satisfiability/Lisp/Reductions/UnitClausePropagation.mac")$

kill(f)$


/* ***************************************
   * Simplifying cardinality constraints *
   ***************************************
*/

okltest_crd2scrd(f) := block([a,b],
  assert(f([a,[],b]) =  [a,[],b]),
  assert(f([a,[1,2,-1,-2,1,3,2],b]) = [a, [[1,2],[2,2],[-2,1],[-1,1],[3,1]], b]),
  true)$

okltest_remove_tautologies_scrd(f) := block([a,b],
  assert(f([a,[],b]) = [a,[],b]),
  assert(f([a,[[1,1]],b]) = [a,[[1,1]],b]),
  assert(f([a,[[1,1]],b]) = [a,[[1,1]],b]),
  assert(f([a,[[1,1],[-1,1]],b]) = [a-1,[],b-1]),
  assert(f([a,[[1,2],[-1,1]],b]) = [a-1,[[1,1]],b-1]),
  assert(f([a,[[-1,2],[1,1]],b]) = [a-1,[[-1,1]],b-1]),
  assert(f([a,[[1,3],[2,2],[-1,2],[-2,2],[3,1]],b]) = [a-4,[[1,1],[3,1]],b-4]),
  true)$


/* **********************
   * Direct translation *
   **********************
*/

okltest_direct_crd2cl(f) := (
  assert(f([0,[1,-1],0]) = [{}]),
  assert(f([0,[1,-1],1]) = []),
  assert(f([1,[1,-1],1]) = []),
  assert(f([2,[1,-1],inf]) = [{}]),
  assert(f([2,[1,-1,1],2]) = [{1}]),
  assert(f([2,[1,-1,1],inf]) = [{1}]),
  assert(f([2,[1,-1,1,-1],2]) = []),
  assert(f([2,[1,-1,1,-1,3],2]) = [{-3}]),
  assert(f([0,[1,-1,1,-1,3,3,-3],2]) = [{}]),
  assert(f([3,[1,-1,1,-1,3,3,-3],3]) = [{-3}]),
  /* XXX */
  true)$

okltest_direct_crd2cl_lt(f) := (
  for ub : -1 thru 1 do
    assert(f([],ub) = if ub <= 0 then [{}] else []),
  for c : 1 thru 3 do
    for ub : -1 thru c+3 do
      assert(f([[1,c]], ub) = if ub<=0 then [{}] elseif ub<=c then [{-1}] else []),
  assert(f([[1,1],[2,1]],0) = [{}]),
  assert(f([[1,1],[2,1]],1) = [{-1},{-2}]),
  assert(f([[1,1],[2,1]],2) = [{-1,-2}]),
  assert(f([[1,1],[2,1]],3) = []),
  assert(f([[1,2],[2,1]],1) = [{-1},{-2}]),
  assert(f([[1,2],[2,1]],2) = [{-1}]),
  assert(f([[1,2],[2,1]],3) = [{-1,-2}]),
  assert(f([[1,1],[2,2]],1) = [{-1},{-2}]),
  assert(f([[1,1],[2,2]],2) = [{-2}]),
  assert(f([[1,1],[2,2]],3) = [{-1,-2}]),
  assert(f([[1,2],[2,2]],2) = [{-1},{-2}]),
  assert(f([[1,2],[2,2]],3) = [{-1,-2}]),
  assert(f([[1,2],[2,2]],4) = [{-1,-2}]),
  assert(f([[1,2],[2,2]],5) = []),
  /* XXX */
  true)$

okltest_direct_crd2cl_ge(f) := (
  assert(f([],0) = []),
  assert(f([],1) = [{}]),
  assert(f([[1,1]],0) = []),
  assert(f([[1,1]],1) = [{1}]),
  assert(f([[1,1]],2) = [{}]),
  assert(f([[1,3]],0) = []),
  assert(f([[1,3]],1) = [{1}]),
  assert(f([[1,3]],2) = [{1}]),
  assert(f([[1,3]],3) = [{1}]),
  assert(f([[1,3]],4) = [{}]),
  assert(f([[1,1],[-2,2]], 1) = [{1,-2}]),
  assert(f([[1,1],[-2,2]], 2) = [{-2}]),
  assert(f([[1,1],[-2,2]], 3) = [{1},{-2}]),
  assert(f([[1,1],[-2,2]], 4) = [{}]),
  /* XXX */
  true)$


/* ************************
   * Using unary encoding *
   ************************
*/

/* Tests that the function f returns a clause-set which is exactly as specified
   in the comments for cardinality_totalizer_cl: */
okltest_unary_bb_totaliser_fcl_comb(f) := block([F],
  assert(f([],[]) = [[],[]]),
  assert(f([2],[1]) = [[2,1],[{-2,1},{-1,2}]]),
  assert(f([3,4],[1,2]) =
    [[3,4,1,2],[{-4,-3,2},{-2,4},{-3,1},{-2,3},{-4,1},{-1,3,4}]]),
  assert(f([4,5,6],[1,2,3]) =
    [[4,5,6,1,2,3,vru(2,3,1),vru(2,3,2)],
     [{-6,-5,vru(2,3,2)},{6,-vru(2,3,2)},{-5,vru(2,3,1)},{5,-vru(2,3,2)},
      {-6,vru(2,3,1)},{5,6,-vru(2,3,1)},{-4,3,-vru(2,3,2)},{-3,vru(2,3,2)},
      {-4,2,-vru(2,3,1)},{-2,vru(2,3,1)},{-4,1},{-3,4},{2,-vru(2,3,2)},
      {-2,4,vru(2,3,2)},{1,-vru(2,3,1)},{-1,4,vru(2,3,1)}]]),
  /* XXX */
  true)$

/* cardinality_totalizer_cl generates a CNF F
   such that the satisfying assignments of F (restricted
   to S and var(E)) have that S is the unary
   representation of the cardinality of E, and that
   any forced assignments on phi * F (for any phi) follow by UCP.
   These tests test both of these assertions. */
/* MG: Additional tests should be added which provide
   assertions on forced assignments including original variables
   (i.e., the original partial assignment applied should
    contain new variables). */
okltest_unary_bb_totaliser_fcl_spec(f) := block([F],
  F : cl2cs(f([1,2,3,4,5],[6,7,8,9,10])[2]),
  assert(ucp_0_cs(apply_pa({1,2,3,4,5,6,7,8,9,10},F)) = {}),
  for i : 1 thru 10 do
    assert(ucp_0_cs(
      apply_pa(setify(create_list(if j = i then -j else j,j,1,10)),F)) = {{}}),
  assert(ucp_0_cs(apply_pa({-1,2,3,4,5,-6,7,8,9,10},F)) = {{}}),
  assert(ucp_0_cs(apply_pa({-1,2,3,4,5,6,-7,8,9,10},F)) = {{}}),
  assert(ucp_0_cs(apply_pa({-1,2,3,4,5,6,7,-8,9,10},F)) = {{}}),
  assert(ucp_0_cs(apply_pa({-1,2,3,4,5,6,7,8,-9,10},F)) = {{}}),
  assert(ucp_0_cs(apply_pa({-1,2,3,4,5,6,7,8,9,-10},F)) = {}),
  assert(ucp_0_cs(apply_pa({-1,-2,-3,-4,-5,6,7,8,9,10},F)) = {{}}),
  assert(ucp_0_cs(apply_pa({-1,-2,-3,-4,-5,-6,-7,-8,-9,-10},F)) = {}),
  true)$

/* Tests that the function f returns a clause-set which is exactly as specified
   in the comments for unary_bb_totalizer_cl: */
okltest_unary_bb_totaliser_r_fcl_comb(f) := block(
  okltest_unary_bb_totaliser_fcl_comb(
    buildq([f],lambda([E,S], f(E,S,1,length(E))))),
  
  true)$

/* unary_bb_totalizer_r_cl is specified in the same
   way as unary_bb_totalizer_cl, except for the new variables
   used, therefore we test that it matches the specification for
   unary_bb_totalizer_cl and that the new variables introduced
   match the specification. */
okltest_unary_bb_totaliser_r_fcl_spec(f) := block([FF],
  okltest_unary_bb_totalizer_cl_spec(
    buildq([f],lambda([E,S], f(E,S,1,length(E))))),
  FF : f([6,7,8,9,10],[1,2,3,4,5],1,5),
  assert(setdifference(setify(FF[1]),{1,2,3,4,5,6,7,8,9,10}) =
    {vru(1,2,1),vru(1,2,2),vru(3,5,1),vru(3,5,2),vru(3,5,3),vru(4,5,1),
     vru(4,5,2)}),
  FF : f([6,7,8,9,10],[1,2,3,4,5],6,10), 
  assert(setdifference(setify(FF[1]),{1,2,3,4,5,6,7,8,9,10}) =
    {vru(6,7,1),vru(6,7,2),vru(8,10,1),vru(8,10,2),vru(8,10,3),vru(9,10,1),
     vru(9,10,2)}),
  true)$

/* Tests that the function f returns a clause-set which is exactly as specified
   in the comments for unary_bb_comparator_cl: */
okltest_unary_bb_comparator_fcl_comb(f) := block(
  for m : 0 thru 5 do
    for n : 0 thru 5 do
      assert(f([],0,0) = [[],[]]),
  assert(f([1],0,1) = [[1],[]]),
  assert(f([1],1,1) = [[1],[{1}]]),
  assert(f([1,2,3],1,2) = [[1,2,3],[{1},{-3}]]),
  assert(f([1,2,3,4,5],2,4) = [[1,2,3,4,5],[{1},{2},{-5}]]),
  true)$

/* unary_bb_comparator_cl generates a CNF F such that
   the satisfying assignments of F are those that have
   at least the first a literals in E are set to true, and the
   last length(E)-b literals set to false. The following
   tests that the given f matches this specification. */   
okltest_unary_bb_comparator_fcl_spec(f) := block([F],
  assert(ucp_lpa_0_cs(cl2cs(f([1,2,3,4],2,3)[2]))[2][1] = {-4,1,2}),
  assert(ucp_lpa_0_cs(cl2cs(f([1,2,3,4],1,3)[2]))[2][1] = {-4,1}),
  assert(ucp_lpa_0_cs(cl2cs(f([1,2,3,4],0,3)[2]))[2][1] = {-4}),
  assert(ucp_lpa_0_cs(cl2cs(f([1,2,3,4],0,4)[2]))[2] = []),
  true)$

/* Tests that the function f returns a clause-set which is as specified
   in the comments for unary_bb_cl: */
okltest_unary_bb_crd2fcl_comb(f) := block([F],
  for m : 0 thru 5 do
    for n : 0 thru 5 do
      assert(f([0,[],0]) = [[],[]]),
  assert(f([0,[1],1]) = [[1,vru(1,1,1)],[{-1,vru(1,1,1)},{1,-vru(1,1,1)}]]),
  assert(f([1,[1],1]) =
    [[1,vru(1,1,1)],[{-1,vru(1,1,1)},{1,-vru(1,1,1)},{vru(1,1,1)}]]),
  true)$

/* unary_bb_cl generates a CNF F
   such that the satisfying assignments of F (restricted to
   var(E)) have that the cardinality of E is between a and
   b (inclusive) and any forced assignments on phi * F (for any phi) follow by
   UCP. These tests test both of these assertions. */
/* MG: Additional tests should be added which provide
   assertions on forced assignments including original variables
   (i.e., the original partial assignment applied should
    contain new variables). */
okltest_unary_bb_crd2fcl_spec(f) := block([F],
  F : cl2cs(f([2,[1,2,3,4,5],4])[2]),
  assert(ucp_0_cs(apply_pa({1,2,3,4,5}, F)) = {{}}),
  for i : 1 thru 5 do (
    assert(ucp_0_cs(
      apply_pa(union(disjoin(i,{1,2,3,4,5}),{-i}), F)) = {}),
    assert(ucp_0_cs(
      apply_pa(union(disjoin(-i,{-1,-2,-3,-4,-5}),{i}), F)) = {{}}),
    for j : 1 thru 5 do (
      if i # j then (
        assert(ucp_0_cs(
          apply_pa(union(setdifference({1,2,3,4,5},{i,j}),{-i,-j}), F)) = {}),
        assert(ucp_0_cs(apply_pa(
          union(setdifference({-1,-2,-3,-4,-5},{-i,-j}),{i,j}), F)) = {}))
    )
  ),true)$

/*!
\endhtmlonly
*/
