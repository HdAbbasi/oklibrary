/* Oliver Kullmann, 24.12.2007 (Swansea) */
/* Copyright 2007, 2008 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Satisfiability/Lisp/Backtracking/DLL_solvers.mac
  \brief D(P)LL-like solver schemes

Use by

oklib_load("Transitional/ComputerAlgebra/Satisfiability/Lisp/Backtracking/DLL_solvers.mac");

*/


/*!
\htmlonly
*/

oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/BasicOperations.mac")$
oklib_include("Transitional/ComputerAlgebra/Hypergraphs/Lisp/SetSystems.mac")$
oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/Hypergraphs.mac")$
oklib_include("Transitional/ComputerAlgebra/Graphs/Lisp/Basic.mac")$


/* **********************************
   * Backtracking without reduction *
   **********************************
*/

/* The simplest scheme: input is a formal clause-set, and the return value
   is true or false.
   The heuristics has to return a literal for input a formal clause-set
   and this literal is first set to true. */

dll_simplest(FF, h) := if is_empty(FF[2]) then true
 elseif has_empty_element(FF[2]) then false
 else block([x : h(FF)], 
    return(dll_simplest(apply_pa_f({x}, FF), h) or dll_simplest(apply_pa_f({-x}, FF), h)))$

/* The variation where the return value is not true/false but the computed 
   splitting tree. */
dll_simplest_st(FF, h) := if is_empty(FF[2]) then [true]
 elseif has_empty_element(FF[2]) then [false]
 else block([x : h(FF)], 
    return([-x,
            dll_simplest_st(apply_pa_f({x}, FF), h),
            dll_simplest_st(apply_pa_f({-x}, FF), h)]))$


/* ***********************************
   * Backtracking with r_k-reduction *
   ***********************************
*/

monitorcheck_dll(name,red) := if oklib_monitor then (
  print(sconcat("M[",name,"]:"), "Entry (reduction =", red, ")."),
    print("F: ", statistics_fcs(FF)),
    print("Fr: ", statistics_fcs(cs_to_fcs(Fr))))$

dll_rk(FF, h, k) := block([Fr : generalised_ucp(FF[2],k)],
  monitorcheck_dll("dll_rk",k),
  if is_empty(Fr) then true
  elseif has_empty_element(Fr) then false
  else block([V : var_cs(Fr)], block([x : h([V,Fr])],
    return(dll_rk(apply_pa_f({x}, [V,Fr]), h, k) 
           or dll_rk(apply_pa_f({-x}, [V,Fr]), h, k)))))$

/* The variation where the return value is the computed r_k-splitting tree. */
dll_rk_st(FF, h, k) := block([Fr : generalised_ucp(FF[2],k)],
  monitorcheck_dll("dll_rk_st",k),
  if is_empty(Fr) then [true]
  elseif has_empty_element(Fr) then [false]
  else block([V : var_cs(Fr)], block([x : h([V,Fr])], 
    return([-x,
            dll_rk_st(apply_pa_f({x}, [V,Fr]), h, k),
            dll_rk_st(apply_pa_f({-x}, [V,Fr]), h, k)]))))$


/* *****************************************
   * Backtracking with arbitrary reduction *
   *****************************************
*/


/* the reduction takes a clause-set and returns a clause-set */
dll_red(FF, h, red) := block([Fr : red(FF[2])],
  monitorcheck_dll("dll_red", red),
  if is_empty(Fr) then true
  elseif has_empty_element(Fr) then false
  else block([V : var_cs(Fr)], block([x : h([V,Fr])], 
    return(dll_red(apply_pa_f({x}, [V,Fr]), h, red) 
           or dll_red(apply_pa_f({-x}, [V,Fr]), h, red)))))$

/* dll_red(FF, h, lambda([F], generalised_ucp(F,k))) = dll_rk(FF, h, k) */

/* The variation where the return value is the computed r-splitting tree. */
dll_red_st(FF, h, red) := block([Fr : red(FF[2])],
  monitorcheck_dll("dll_red_st", red),
  if is_empty(Fr) then [true]
  elseif has_empty_element(Fr) then [false]
  else block([V : var_cs(Fr)], block([x : h([V,Fr])], 
    return([-x,
            dll_red_st(apply_pa_f({x}, [V,Fr]), h, red),
            dll_red_st(apply_pa_f({-x}, [V,Fr]), h, red)]))))$

/* Amend the splitting tree with the distances used by the heuristics;
   so this time the "amended heuristics" returns a pair [x,L],
   and non-leaf-nodes a labelled with pairs [x,L], while
   leaf-nodes are still just labelled with [true] or [false].
   Here L is the list of distance-pairs used by the heuristic. */
dll_red_st_dist(FF, ah, red) := block([Fr : red(FF[2])],
  monitorcheck_dll("dll_red_st_dist", red),
  if is_empty(Fr) then [true]
  elseif has_empty_element(Fr) then [false]
  else block([V : var_cs(Fr)], block([H : ah([V,Fr]), x], 
    x : H[1],
    return([[-x, map(reverse, H[2])],
            dll_red_st_dist(apply_pa_f({x}, [V,Fr]), ah, red),
            dll_red_st_dist(apply_pa_f({-x}, [V,Fr]), ah, red)]))))$


/* ************************
   * Simple heuristics    *
   ************************
*/

/* The simplest heuristics: return the first variable */
dll_heuristics_first_formal(FF) := first(FF[1])$

dll_simplest_trivial1(FF) := dll_simplest(FF, dll_heuristics_first_formal)$
dll_simplest_st_trivial1(FF) := dll_simplest_st(FF, dll_heuristics_first_formal)$
dll_rk_trivial1(FF,k) := dll_rk(FF, dll_heuristics_first_formal, k)$
dll_rk_st_trivial1(FF,k) := dll_rk_st(FF, dll_heuristics_first_formal, k)$

/* The second-simplest heuristics: return the literal of the first
   literal-occurrence */
dll_heuristics_first_real(FF) := first(first(FF[2]))$

dll_simplest_trivial2(FF) := dll_simplest(FF, dll_heuristics_first_real)$
dll_simplest_st_trivial2(FF) := dll_simplest_st(FF, dll_heuristics_first_real)$
dll_rk_trivial2(FF,k) := dll_rk(FF, dll_heuristics_first_real, k)$
dll_rk_st_trivial2(FF,k) := dll_rk_st(FF, dll_heuristics_first_real, k)$

/* Heuristics: first literal in first shortest clause */
dll_heuristics_first_shortest_clause(FF) := block([ml : inf, x],
 for C in FF[2] do if length(C) < ml then (ml : length(C), x : first(C)),
  return(x))$

dll_simplest_first_shortest_clause(FF) := dll_simplest(FF, dll_heuristics_first_shortest_clause)$
dll_simplest_st_first_shortest_clause(FF) := dll_simplest_st(FF, dll_heuristics_first_shortest_clause)$
dll_rk_first_shortest_clause(FF,k) := dll_rk(FF, dll_heuristics_first_shortest_clause, k)$
dll_rk_st_first_shortest_clause(FF,k) := dll_rk_st(FF, dll_heuristics_first_shortest_clause, k)$


/* ****************************
   * Heuristics via distances *
   ****************************
*/

/* Heuristics scheme given by a list of distances and projections (for 
   lexicographical ordering in case of ties) and an approximation of
    satisfiability probability; look-ahead by reduction r (a map from
    clause-sets to clause-sets). */
/* If the distance yields <= 0 then the whole branching is disqualified,
   if the distance yields infinity, then this branching is chosen 
   immediately. */
/* A projection is the better the smaller. Inputs are positive and
   not infinity, and the same for the output. */
/* If there are less projections than distances, then the last projection
   is reused. */

/* A helper-function which determines whether a value evaluates to inf.
   Ignores presence of minf; Maxima evaluates 0*inf to 0. */
equivinfp(x) := is(not freeof(inf, x))$

/* A helper-function for evaluating a branching variable:
   Using dynamic binding for F, F1, F0 and v. */
evaluating_branching_variable(d) := block([x,d0,d1],
  x : v, d1 : d(F, F1),
  if equivinfp(d1) then return([x])
  elseif d1 <= 0 then return([]) else (
    x : -v, d0 : d(F, F0),
    if equivinfp(d0) then (return([x]))
    elseif d0 <= 0 then return([])
    else return([d1,d0])))$

/* Helper-function for lexicographical ordering of lists:
   returns true if A < B */
lexicographical_orderp(A,B) :=
  if A = [] then if B = [] then false else true
  elseif B = [] then false
  elseif A[1] < B[1] then true
  elseif A[1] > B[1] then false
  else lexicographical_orderp(rest(A),rest(B))$

monitorcheck_hld(name) := if oklib_monitor then (
  print(sconcat("M[",name,"]:"), "immediate:", immediate, ", best_proj:", best_proj))$
monitorcheck_hld_v(name) := if oklib_monitor then (
  if oklib_monitor_level >= 1 then (
    print(sconcat("M[",name,"]: LOOP "),  "variable:", v, ", immediate:", immediate, ", ignore:", ignore, ", distances:", D)))$

heuristics_lookahead_distances(r, distances, projections, satprob) :=
 block([nd : length(distances), np : length(projections)],
  buildq([r, distances, projections, satprob, nd, np], lambda([FF],
   block(
    [F : FF[2], best_var, branch_lit, best_proj : [inf], immediate : false, Fbest],
    for v in FF[1] unless immediate do 
     block([E, F0,F1, D : [], P : [], ignore : false],
      F1 : r(apply_pa({v},F)), F0 : r(apply_pa({-v},F)),
      for i : 1 thru nd do (
        E : evaluating_branching_variable(distances[i]),
        if length(E) = 0 then (ignore : true, return(false)),
        if length(E) = 1 then (
          branch_lit : E[1], immediate : true, return(false)
        ),
        D : endcons(E,D)
      ),
      monitorcheck_hld_v("heuristics_lookahead_distances"),
      if ignore or immediate then return(false),
      for i : 1 thru nd do block([p : projections[min(np,i)]],
        P : endcons(p(D[i][1], D[i][2]), P)),
      if lexicographical_orderp(P, best_proj) then (
        best_proj : P, best_var : v, Fbest : [F1,F0]
      )
    ),
    monitorcheck_hld("heuristics_lookahead_distances"),
    if immediate then return(branch_lit),
    if best_proj = [inf] then
      error("heuristics_lookahead_distances: all variables disabled!"),
    if satprob(Fbest[1]) >= satprob(Fbest[2]) then return(best_var)
    else return(-best_var)
   ))))$

/* The amended variation, returning the list of associated distances;
   additionally a list of monitoring distances can be specified.
   For the list of distances returned at a node, the number of "deciding"
   distances can vary if inf-values occur, however there are always
   length(mon_distances) many monitoring-distances. */
amended_heuristics_lookahead_distances(r, distances, projections, satprob, mon_distances) :=
 block([nd : length(distances), np : length(projections), nm : length(mon_distances)],
  buildq([r, distances, projections, satprob, mon_distances, nd, np, nm], lambda([FF],
   block(
    [F : FF[2], best_var, branch_lit, best_proj : [inf], immediate : false, Fbest, best_dist],
    for v in FF[1] unless immediate do 
     block([E, F0,F1, D : [], P : [], ignore : false],
      F1 : r(apply_pa({v},F)), F0 : r(apply_pa({-v},F)),
      for i : 1 thru nd do (
        E : evaluating_branching_variable(distances[i]),
        if length(E) = 0 then (ignore : true, return(false)),
        if length(E) = 1 then (
          branch_lit : E[1], immediate : true,
          if branch_lit > 0 then E : [inf,0] else E : [0,inf],
          best_dist : endcons(E,D),
          Fbest : [F1,F0],
          return(false)
        ),
        D : endcons(E,D)
      ),
      monitorcheck_hld_v("amended_heuristics_lookahead_distances"),
      if ignore or immediate then return(false),
      for i : 1 thru nd do block([p : projections[min(np,i)]],
        P : endcons(p(D[i][1], D[i][2]), P)),
      if lexicographical_orderp(P, best_proj) then (
        best_proj : P, best_var : v, Fbest : [F1,F0], best_dist : D
      )
    ),
    monitorcheck_hld("amended_heuristics_lookahead_distances"),
    for i : 1 thru nm do block([md : mon_distances[i]],
      best_dist : endcons([md(F,Fbest[1]),md(F,Fbest[2])], best_dist)),
    if not immediate then (
      if best_proj = [inf] then
        error("heuristics_lookahead_distances: all variables disabled!"),
      if satprob(Fbest[1]) >= satprob(Fbest[2]) then 
        branch_lit : best_var 
      else
        branch_lit : -best_var
    ),
    if branch_lit < 0 then best_dist : map(reverse, best_dist),
    return([branch_lit, best_dist])
   ))))$


/* Extract a tree with distances */
extract_tbt(T,i) := block([l : length(T)],
  if l = 1 then [[]] else
  cons(T[1][2][i], makelist(extract_tbt(T[j],i),j,2,l)))$

/* Check that inf-branches are trivial: m is the number of monitoring
   distances, returns the top-most offending nodes */
check_inf_branches(T,m) := block([l : length(T), rel_distances, inf_ind],
  if l = 1 then return([]),
  rel_distances : rest(T[1][2],-m),
  inf_ind : sublist_indices(rel_distances, lambda([d], member(inf,d))),
  if not emptyp(inf_ind) then (
    if length(inf_ind) # 1 then 
      error("check_inf_branches: more than one inf-notification!"),
    inf_ind : sublist_indices(rel_distances[inf_ind[1]], lambda([x],is(x=inf))),
    if not every(makelist(is(nnds_l(T[1+i]) = 1), i, inf_ind)) then
      return(append([T[1], inf_ind], makelist(nnds_l(T[1+i]),i,inf_ind)))
  ),
  return(apply(append, makelist(check_inf_branches(T[i],m),i,2,l))))$

/* Counts nodes containing some inf-distance-value */
count_inf_branches(T,m) := block([l : length(T), flag : 0],
  if l = 1 then return(0),
  if not emptyp(sublist_indices(rest(T[1][2],-m), lambda([d], member(inf,d))))
    then flag : 1,
  return(flag + sum(count_inf_branches(T[i],m),i,2,l)))$

/* Collapses nodes where all branches except of one are inf-branches
   (such nodes are hidden reductions); m is the number of monitoring
   distances */
collapse_inf_branches(T,m) := block(
  [l : length(T), rel_distances, inf_ind, other],
  if l = 1 then return(T),
  rel_distances : rest(T[1][2],-m),
  inf_ind : sublist_indices(rel_distances, lambda([d], member(inf,d))),
  if not emptyp(inf_ind) then (
    inf_ind : sublist_indices(rel_distances[inf_ind[1]],lambda([x],is(x=inf))),
    if length(inf_ind) = l-2 then (
      other : listify(setdifference(setmn(1,l-1),setify(inf_ind)))[1],
      T : T[1+other],
      return(collapse_inf_branches(T,m)))
  ),
  return(cons(T[1], makelist(collapse_inf_branches(T[i],m),i,2,l))))$


/* *************
   * Distances *    
   *************
*/

/* Distances have as input two clause-sets Ffrom, Fto,
   and return a real number or inf.
*/

/* The trivial distance */
trivial_distance(Ffrom,Fto) := 1$

/* The difference in the number of variables */
delta_n(Ffrom,Fto) := nvar_cs(Ffrom) - nvar_cs(Fto)$

/* The difference in the number of clauses */
delta_c(Ffrom,Fto) := ncl_cs(Ffrom) - ncl_cs(Fto)$

/* The difference in the number of literal occurrences */
delta_l(Ffrom,Fto) := nlitocc(Ffrom) - nlitocc(Fto)$

/* The scheme for the weighted number of new clauses (wf, the
   weight function, takes natural numbers >= 2 as inputs (the clause-lengths),
   and returns positive real numbers). */
wn_newclauses(wf) := buildq([wf], lambda([Ffrom,Fto],
  block([nC : listify(setdifference(Fto, Ffrom))],
    return(sum(wf(length(nC[i])),i,1,length(nC))))))$
/* The variation of wn_newclauses where instances of 2-CLS are detected: */
wn_newclauses_2(wf)  := buildq([wf], lambda([Ffrom,Fto],
  if max_rank_cs(Fto) <= 2 then inf else
   block([nC : listify(setdifference(Fto, Ffrom))],
    return(sum(wf(length(nC[i])),i,1,length(nC))))))$

/* Just the number of new clauses of length k */
n_newclauses(k) := buildq([k], lambda([Ffrom,Fto],
  length(setdifference(scls_k(Fto,k), scls_k(Ffrom,k)))))$


/* ***************
   * Projections *
   ***************
*/

/* For binary clauses: */

/* We have tau2. */

prod_proj(x,y) := 1/(x*y)$


/* *********************************
   * Satisfiability approximations *
   *********************************
*/

/* These "approximations" are just real numbers, and the greater the
   higher the probability of satisfiability.
   The value inf says the formula is surely satisfiable, the value
   minf says the forrmula is surely unsatisfiable.
*/

/* The trivial approximation of satprob(F) ("approximation of order 0") */
trivial_sat_approx(F) := 1$

/* The first-order approximation of satprob(F) (a lower bound on the true
   probability), increased to inf if sat is established */
firstorder_sat_approx(F) := block([L : listify(F), a],
 a : 1 - sum(2^(-length(L[i])),i,1,length(L)),
 if a > 0 then return(inf) else return(a))$

/* The logarithm of the probability that a random assignment over the 
   variables in the given clause-set satisfies a random clause-set 
   drawn with the same number of clauses of the same lengths as the
   given clause-set. */
/* With the exception that log(1) = 0 is translated to inf. */
/* See probsatrand in
ComputerAlgebra/Satisfiability/Lisp/Counting/RandomClauseSets.mac. */
logprobrand(F) := if F = {} then inf else 
 block([L : ncl_list_f(cs_to_fcs(F))],
  if L[1][1] = 0 then return(minf) else
  return(sum(L[i][2] * float(log(1-2^(-L[i][1]))), i, 1, length(L))))$

/* The reciprocal maximum over all clauses C of the sums of 2^(-|D|) over 
   neighbours D of C in the common-variable graph, as motivated by
   the asymetric local lemma of Lovasz. */
/* Compare with locallemma_sattest_asymmetric in
   ComputerAlgebra/Satisfiability/Lisp/Counting/Degrees.mac. */
locallemma_satapprox(F) := if F = {} then inf else 
  if has_empty_element(F) then minf else 
   block([G : g2mg(cvg_cs(F)), m : 0, c],
    c : graph_size(G),
    for i : 2 thru c do block([N : neighbors(i, G), s : 0],
      for j in N do
        s : s + 2^(-length(get_vertex_label(j,G))),
      m : max(m,s)),
    if m = 0 then return(inf)
    elseif m <= 1/4 then return(inf)
    else return(1/m))$

/*!
\endhtmlonly
*/
