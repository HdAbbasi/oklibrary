/* Oliver Kullmann, 24.12.2007 (Swansea) */
/* Copyright 2007 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Satisfiability/Lisp/Backtracking/DLL_solvers.mac
  \brief D(P)LL-like solver schemes

Use by

oklib_load("Transitional/ComputerAlgebra/Satisfiability/Lisp/Backtracking/DLL_solvers.mac");

*/


/*!
\htmlonly
*/

oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/BasicOperations.mac")$
oklib_include("Transitional/ComputerAlgebra/Hypergraphs/Lisp/SetSystems.mac")$


/* **********************************
   * Backtracking without reduction *
   **********************************
*/

/* The simplest scheme: input is a formal clause-set, and the return value
   is true or false.
   The heuristics has to return a literal for input a formal clause-set
   and this literal is first set to true. */

dll_simplest(FF, h) := if is_empty(FF[2]) then true
 elseif has_empty_element(FF[2]) then false
 else block([x : h(FF)], 
    return(dll_simplest(apply_pa_f({x}, FF), h) or dll_simplest(apply_pa_f({-x}, FF), h)))$

/* The variation where the return value is not true/false but the computed 
   splitting tree. */
dll_simplest_st(FF, h) := if is_empty(FF[2]) then [true]
 elseif has_empty_element(FF[2]) then [false]
 else block([x : h(FF)], 
    return([-x,
            dll_simplest_st(apply_pa_f({x}, FF), h),
            dll_simplest_st(apply_pa_f({-x}, FF), h)]))$


/* ***********************************
   * Backtracking with r_k-reduction *
   ***********************************
*/

dll_rk(FF, h, k) := block([Fr : generalised_ucp(FF[2],k)],
  if is_empty(Fr) then true
  elseif has_empty_element(Fr) then false
  else block([V : var_cs(Fr)], block([x : h([V,Fr])],
    return(dll_rk(apply_pa_f({x}, [V,Fr]), h, k) 
           or dll_rk(apply_pa_f({-x}, [V,Fr]), h, k)))))$

/* The variation where the return value is the computed r_k-splitting tree. */
dll_rk_st(FF, h, k) := block([Fr : generalised_ucp(FF[2],k)],
  if is_empty(Fr) then [true]
  elseif has_empty_element(Fr) then [false]
  else block([V : var_cs(Fr)], block([x : h([V,Fr])], 
    return([-x,
            dll_rk_st(apply_pa_f({x}, [V,Fr]), h, k),
            dll_rk_st(apply_pa_f({-x}, [V,Fr]), h, k)]))))$


/* *****************************************
   * Backtracking with arbitrary reduction *
   *****************************************
*/

/* the reduction takes a clause-set and returns a clause-set */
dll_red(FF, h, red) := block([Fr : red(FF[2])],
  if is_empty(Fr) then true
  elseif has_empty_element(Fr) then false
  else block([V : var_cs(Fr)], block([x : h([V,Fr])], 
    return(dll_red(apply_pa_f({x}, [V,Fr]), h, red) 
           or dll_red(apply_pa_f({-x}, [V,Fr]), h, red)))))$

/* dll_red(FF, h, lambda([F], generalised_ucp(F,k))) = dll_rk(FF, h, k) */

/* The variation where the return value is the computed r-splitting tree. */
dll_red_st(FF, h, red) := block([Fr : red(FF[2])],
  if is_empty(Fr) then [true]
  elseif has_empty_element(Fr) then [false]
  else block([V : var_cs(Fr)], block([x : h([V,Fr])], 
    return([-x,
            dll_red_st(apply_pa_f({x}, [V,Fr]), h, red),
            dll_red_st(apply_pa_f({-x}, [V,Fr]), h, red)]))))$


/* *****************
   * Heuristics    *
   *****************
*/

/* The simplest heuristics: return the first variable */
dll_heuristics_first_formal(FF) := first(FF[1])$

dll_simplest_trivial1(FF) := dll_simplest(FF, dll_heuristics_first_formal)$
dll_simplest_st_trivial1(FF) := dll_simplest_st(FF, dll_heuristics_first_formal)$
dll_rk_trivial1(FF,k) := dll_rk(FF, dll_heuristics_first_formal, k)$
dll_rk_st_trivial1(FF,k) := dll_rk_st(FF, dll_heuristics_first_formal, k)$

/* The second-simplest heuristics: return the literal of the first
   literal-occurrence */
dll_heuristics_first_real(FF) := first(first(FF[2]))$

dll_simplest_trivial2(FF) := dll_simplest(FF, dll_heuristics_first_real)$
dll_simplest_st_trivial2(FF) := dll_simplest_st(FF, dll_heuristics_first_real)$
dll_rk_trivial2(FF,k) := dll_rk(FF, dll_heuristics_first_real, k)$
dll_rk_st_trivial2(FF,k) := dll_rk_st(FF, dll_heuristics_first_real, k)$

/* Heuristics: first literal in first shortest clause */
dll_heuristics_first_shortest_clause(FF) := block([ml : inf, x],
 for C in FF[2] do if length(C) < ml then (ml : length(C), x : first(C)),
  return(x))$

dll_simplest_first_shortest_clause(FF) := dll_simplest(FF, dll_heuristics_first_shortest_clause)$
dll_simplest_st_first_shortest_clause(FF) := dll_simplest_st(FF, dll_heuristics_first_shortest_clause)$
dll_rk_first_shortest_clause(FF,k) := dll_rk(FF, dll_heuristics_first_shortest_claus, ke)$
dll_rk_st_first_shortest_clause(FF,k) := dll_rk_st(FF, dll_heuristics_first_shortest_clause, k)$

/*!
\endhtmlonly
*/
