/* Matthew Gwynne, 15.12.2009 (Swansea) */
/* Copyright 2009, 2011 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Satisfiability/Lisp/FiniteFunctions/Permutations.mac
  \brief Permutations as boolean functions

Use by

oklib_load("OKlib/ComputerAlgebra/Satisfiability/Lisp/FiniteFunctions/Permutations.mac");

*/

/*!
\htmlonly
*/

oklib_include("OKlib/ComputerAlgebra/NumberTheory/Lisp/Auxiliary.mac")$
oklib_include("OKlib/ComputerAlgebra/Hypergraphs/Lisp/SetSystems.mac")$
oklib_include("OKlib/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/BasicOperations.mac")$


/* *************************************
   * Permutations as boolean functions *
   *************************************
*/

/* 
   We consider permutations f of {1,...,m}, where for permutations
   we use the list representations (so that the set of all such
   representations is permutations(setn(m))).
   See ComputerAlgebra/Algebra/Lisp/Groupoids/Groups/SymmetricGroups.mac for
   the symmetric group.
   We represent f as a boolean function, considering f as a relation.

   We assume m = 2^k for natural k >= 1, so that the set {1,...,m} has the
   same cardinality as {0,1}^k. Using a bijection R{1,...,m} -> {0,1}^k for a
   representation, the mapping x -> y represented by the permutation f yields
   the boolean list append(R(x), R(y)) of length 2k.
   These lists are considered as the satisfying assignments of the
   corresponding boolean function.

   We fix R: {1,...,m} -> {0,1}^k, i -> R(i) as the standard representation of
   i-1 in binary, with (left-)padded zeros; in other words, R(i) is the
   unranking of i w.r.t. the lexicographical ordering of binary vectors of
   length k.

   So the transposition [2,1] (here m=2 and k=1), that is, the
   map 1->2, 2->1, yields the satisfying vectors {[0,1],[1,0]}, and thus
   the DNF-clause-set {{-1,2},{1,-2}}.
   And [2,4,1,3] yields the satisfying vectors
   {[0,0,0,1],[0,1,1,1],[1,0,0,0],[1,1,1,0]} and the DNF-clause-set
   {{-1,-2,-3,4},{-1,2,3,4},{1,-2,-3,-4},{1,2,3,-4}}.
   This is computed by the functions below as
     perm2dnffcl([2,1]) = [[1,2],[{-1,2},{-2,1}]]
     perm2dnffcl([2,4,1,3]) =
       [[1,2,3,4],[{-3,-2,-1,4},{-1,2,3,4},{-4,-3,-2,1},{-4,1,2,3}]].
*/

/* The boolean vectors of length k in lexicographical order: */
lex_bv_l(k) := cartesian_product_l(create_list([0,1],i,1,k))$
/* Unranking for 1 <= i <= 2^k: */
unrank_lex_bv(i,k) := if k=0 then [] else int2polyadic_padd(i-1,2,k)$
/* Ranking of boolean vectors: */
rank_lex_bv(x) := polyadic2int(x,2) + 1$

/* Translating boolean vectors into clauses (using the position as variables 
   in bv2c):
*/
bv2c(v) := bv2c_wv(v,create_list(i,i,1,length(v)))$
/* More generally, supplying a vector V of boolean variables (of the same
   length as v):
*/
bv2c_wv(v,V) := setify(map(lambda([x,y], if x=0 then -y else y), v, V))$

/* Translating a permutation P (standardised, as list) into a boolean function
   (the predicate of P as a map), and representing this function as a dnf.
   Prerequisite: P is a permutation of {1,...,2^k} for k >= 1.
*/
perm2dnffcl(P) := block([m : length(P), k, V, F, R],
  k : fld(m),
  V : create_list(i,i,1,2*k),
  R : lambda([i],unrank_lex_bv(i,k)),
  F : map(append, map(R,create_list(i,i,1,m)), map(R,P)),
  return([V, map(bv2c,F)]))$
perm2dnffcs(P) := fcl2fcs(perm2dnffcl(P))$

/* Now representing the function as cnf: */
perm2cnffcs(P) := block([m : length(P), FF : perm2dnffcs(P), k],
  k : fld(m),
  return([FF[1], setdifference(all_tass(setn(2*k)), FF[2])]))$

/* Output of clause-set perm2cnffcs(P) to file "Permutation_full.cnf": */
output_perm_fullcnf_stdname(P) :=
  output_fcs(
    sconcat("The permutation", P, "in full CNF representation."),
    perm2cnffcs(P),
    "Permutation_full.cnf")$

/*!
\endhtmlonly
*/
