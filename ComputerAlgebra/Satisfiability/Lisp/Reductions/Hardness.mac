/* Matthew Gwynne, 21.6.2011 (Swansea) */
/* Copyright 2011, 2012 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Satisfiability/Lisp/Reductions/Hardness.mac
  \brief Functions related to the hardness of clause-sets

  The hardness of a clause-set F is the minimum k >= 0 such that
  all clauses C which follow from F can be detected via r_k.

  That is, the minimum k >= 0 for which for all clauses C with
  F |= C we have generalised_ucp(apply_pa(comp_sl(C),F),k) = {{}}.

  See "Hardness of boolean function representations" in
  Experimentation/Investigations/BooleanFunctions/plans/general.hpp.

Use by

oklib_load("OKlib/ComputerAlgebra/Satisfiability/Lisp/Reductions/Hardness.mac");

*/

/*!
\htmlonly
*/

oklib_include("OKlib/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/BasicOperations.mac")$
oklib_include("OKlib/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/Statistics.mac")$
oklib_include("OKlib/ComputerAlgebra/Satisfiability/Lisp/Reductions/GeneralisedUCP.mac")$
oklib_include("OKlib/ComputerAlgebra/Satisfiability/Lisp/Resolution/PrimeImplicatesImplicants.mac")$


/* ***************************
   * Computing the hardness  *
   ***************************
*/

/* Computing the hardness of a clause-set F with its prime-implicates F_PI
   as input. In case there is a clause C in F_PI which does not follow from
   F, hardness_wpi_cs returns und.
*/
hardness_wpi_cs(F,F_PI) := block([k : 0, count : 0, maxcount, n],
  n : nvar_cs(F),
  if oklib_monitor then maxcount : length(F_PI),
  for C in F_PI do block([F_phi : apply_pa(comp_sl(C),F)],
    if oklib_monitor then (
      count : count + 1,
      if mod(count, 50) = 0 then
        print(sconcat("[",count,"/",maxcount,"] hd(F) >= ", k," ..."))
    ),
    while generalised_ucp(F_phi,k) # {{}} and k <= n do k : k+1
  ),
  if k > n then und else k)$
/* Taking just the clause-set F: */
hardness_cs(F) := hardness_wpi_cs(F,min_resolution_closure_cs(F)[1])$

/*!
\endhtmlonly
*/

