/* Oliver Kullmann, 7.10.2011 (Swansea) */
/* Copyright 2011 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Satisfiability/Lisp/Resolution/Search.mac
  \brief Searching for shortest resolution proofs

Use by

oklib_load("OKlib/ComputerAlgebra/Satisfiability/Lisp/Resolution/Search.mac");

*/

/*!
\htmlonly
*/

oklib_include("OKlib/ComputerAlgebra/Satisfiability/Lisp/Resolution/Basics.mac")$
oklib_include("OKlib/ComputerAlgebra/DataStructures/Lisp/HashMaps.mac")$
oklib_include("OKlib/ComputerAlgebra/Hypergraphs/Lisp/SetSystems.mac")$


/* *******************
   * Tree resolution *
   *******************
*/

/* Computes first(resolution_closure_cs(F)), where to every resolvent its
   tree-resolution computation is given, via a hash-map, target stands
   for a clause for which the search can be aborted when that clause
   has been derived (use for example target=0 if the full closure shall
   be computed).
*/
resolution_closure_treecomp_cs(F,target) := block(
 [finished : F,
  complexity : sm2hm(cartesian_product(F,{1})),
  queue : cartesian_product({3},resolvents_cs(F)),
  abortion : false
 ],
  if elementp(target,finished) then return(complexity),
  while not emptyp(queue) and not abortion do block(
   [Rp : first_element(queue), R, m],
   queue : disjoin(Rp,queue),
   [m,R] : Rp,
   if not elementp(R,finished) then block(
     [partners : subset(finished, lambda([C], resolvable(C,R)))],
     finished : adjoin(R,finished),
     set_hm(complexity, R, m),
     if R=target then (abortion : true, return(false)),
     for C in partners do block([E : resolvent(C,R)],
       if not elementp(E,finished) then
         queue : adjoin([ev_hm(complexity,C)+ev_hm(complexity,R)+1,E], queue)
     )
   )
  ),
  return(complexity))$

/* Computes the tree-resolution complexity of deriving the empty clause
   from clause-set F:
*/
treecomp_refutation_cs(F) := ev_hm(resolution_closure_treecomp_cs(F,{}),{})$

/*!
\endhtmlonly
*/
