/* Oliver Kullmann, 24.1.2008 (Swansea) */
/* Copyright 2008 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/CombinatorialMatrices/Lisp/Basics.mac
  \brief Basic functionality for combinatorial matrices

Use by

oklib_load("Transitional/ComputerAlgebra/CombinatorialMatrices/Lisp/Basics.mac");

*/

/*!
\htmlonly
*/

oklib_include("Transitional/ComputerAlgebra/Hypergraphs/Lisp/SetSystems.mac")$


/* ***********************
   * Basic constructions *
   ***********************
*/

/* Converts a square combinatorial matrix into a combinatorial matrix */
scom2com(M) := [M[1],M[1],M[2]]$

/* Converts a combinatorial matrix with equal row and column set into
   a square combinatorial matrix */
com2scom(M) := [M[1],M[3]]$

/* The empty combinatorial matrix */
emptycom : [{},{},lambda([i,j],false)]$
/* The empty square combinatorial matrix */
emptyscom : [{},lambda([i,j],false)]$
/* The zero combinatorial matrix for given index sets */
zerocom(I,J) := [I,J,lambda([i,j],0)]$
/* The zero square combinatorial matrix for a given index set */
zeroscom(I) := [I,lambda([i,j],0)]$
/* The constant combinatorial matrix for given index sets and value */
constantcom(I,J,a) := [I,J,buildq([a],lambda([i,j],a))]$
/* The constant square combinatorial matrix for given index set and value */
constantscom(I,a) := [I,buildq([a],lambda([i,j],a))]$

/* The identity matrix */
idscom(I) := [I, lambda([i,j],if i=j then 1 else 0)]$
/* The diagonal matrix with constant diagonal value */
cdiagscom(I,a) := [I,buildq([a],lambda([i,j],if i=j then a else 0))]$


/* *******************
   * Transformations *
   *******************
*/

/* Transforms a combinatorial matrix into a Maxima matrix */
com2m(M) := block([rows : listify(M[1]), cols : listify(M[2]), f : M[3]],
  apply(matrix, makelist(makelist(f(i,j),j,cols),i,rows)))$

/* Transforms a square combinatorial matrix into a Maxima matrix */
scom2m(M) := com2m(scom2com(M))$

/* Transforms a Maxima matrix into a combinatorial matrix
   (attention: this constitutes a reference to the original matrix). */
m2com(M) := block([m,n],
  [m,n] : matrix_size(M),
  [setn(m), setn(n),
    buildq([M], lambda([i,j], 'M[i,j]))])$

/* Transforms a square combinatorial matrix into a graph */
com2g(M) := [M[1], subset(powerset(M[1],2), lambda([S],
  block([L : listify(S)], return(is(M[2](L[1],L[2]) # 0)))))]$

/* Transforms a combinatorial matrix into a general hypergraph */
com2ghyp(M) := [M[1], M[2], buildq([M], 
 lambda([j], subset(M[1], lambda([i], is(M[3](i,j) # 0)))))]$


/* ********************
   * Basic operations *
   ********************
*/

/* The dimensions of a combinatorial matrix */
dim_com(M) := [length(M[1]), length(M[2])]$
/* The order of a square combinatorial matrix */
order_scom(M) := length(M[1])$

/* Transposition of a combinatorial matrix */
trans(M) := [M[2], M[1], buildq([M], lambda([i,j], M[3](j,i)))]$
/* Transposition of a square combinatorial matrix */
strans(M) := [M[1], buildq([M], lambda([i,j], M[2](j,i)))]$


/* Equality test for combinatorial matrices */
comequalp(A,B) := is(A[1] = B[1]) and is(A[2] = B[2]) and
 block([break : false],
  for a in A[1] unless break do for b in A[2] unless break do
    if A[3](a,b) # B[3](a,b) then break : true,
  return(not break))$
/* Equality test for square combinatorial matrices */
scomequalp(A,B) := is(A[1] = B[1]) and
 block([break : false],
  for a in A[1] unless break do for b in A[1] unless break do
    if A[2](a,b) # B[2](a,b) then break : true,
  return(not break))$

/* The difference of two square combinatorial matrices
   Precondition: A[1] = B[1]. */
diff_scom(A,B) := [A[1], buildq([A,B],
  lambda([i,j], A[2](i,j) - B[2](i,j)))]$

/* Multiplying a square combinatorial matrix with a scalar */
scprod_scom(a,A) := [A[1], buildq([a,A], lambda([i,j], a * A[2](i,j)))]$

/* The product of two combinatorial matrices.
   Precondition: A[2] = B[1]. */
prod_com(A,B) := [A[1], B[2], buildq([A,B],
  lambda([i,j], sum(A[3](i,listify(A[2])[k]) * B[3](listify(B[1])[k],j), 
                    k,1,length(listify(A[2])))))]$

/* The minimum over all entries of a combinatorial matrix */
min_com(M) := lmin(map(lambda([p],apply(M[3],p)), cartesian_product(M[1],M[2])))$
/* The maximum over all entries of a combinatorial matrix */
max_com(M) := lmax(map(lambda([p],apply(M[3],p)), cartesian_product(M[1],M[2])))$

/* The sum over all entries of a combinatorial matrix */
sum_com(M) := block(
 [R : listify(M[1]), m, C : listify(M[2]), n],
  m : length(R), n : length(C),
  sum(sum(M[3](R[i],C[j]), i,1,m), j,1,n))$
/* The sum over all entries of a square combinatorial matrix */
sum_scom(M) := sum_com(scom2com(M))$

/* The entrywise absolute values of a combinatorial matrix */
abs_com(M) := [M[1], M[2], buildq([M],lambda([i,j], abs(M[3](i,j))))]$
/* The entrywise absolute values of a square combinatorial matrix */
abs_scom(M) := [M[1], buildq([M],lambda([i,j], abs(M[2](i,j))))]$


/*!
\endhtmlonly
*/
