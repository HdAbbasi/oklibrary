/* Rui Wang, 28.10.2009 (Swansea) */
/* Copyright 2009 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Trees/Lisp/Visualisation.mac
  \brief Functions for tree drawing using Gnuplot

Use by

oklib_load("OKlib/ComputerAlgebra/Trees/Lisp/Visualisation.mac");

*/

/*!
\htmlonly
*/

oklib_include("OKlib/ComputerAlgebra/Trees/Lisp/ReingoldTilford.mac")$


/* ******************************
   * Tree drawing *
   ******************************
*/

/* Extract a list of points [[x1,y1], [x2,y2], ... , [xn,yn]] from a labelled
   rooted tree T with 2-dimensional coordinates:
*/
tdlrt2points(T) := block([nt,nt1,nt2],
      if rest(T)=[] then return([T[1][1]]) 
      else if length(rest(T))=2 
           then ([nt1,nt2]:map(tdlrt2points, rest(T)),
                 nt:cons(T[1][1],append(nt1,nt2))) 
           else ([nt1]:map(tdlrt2points, rest(T)),
                 nt:cons(T[1][1],nt1)),
      return(nt))$

/* Extract a list of edges [[[x1,y1],[x2,y2]], ... , [[xn',yn'],[xn,yn]]] from
   a labelled rooted tree T with 2-dimensional coordinates:
*/
tdlrt2edges(T) := block([nt,nt1,nt2],
      if rest(T)=[] then return(T) 
      else if length(rest(T))=2 
           then ([nt1,nt2]:map(tdlrt2edges, rest(T)), 
                 nt:append(cons([T[1][1],nt1[1][1]],
                                if rest(nt1)=[] and rest(nt1[1])=[] then [] 
                                else nt1),
                                cons([T[1][1],nt2[1][1]],
                                     if rest(nt2)=[] and rest(nt2[1])=[] then []
                                     else nt2))) 
           else ([nt1]:map(tdlrt2edges, rest(T)), 
                 nt:cons([T[1][1],nt1[1][1]],
                         if rest(nt1)=[] and rest(nt1[1])=[] then [] else nt1)), 
      return(nt))$

/* Produce a list of labels [[label_1,x_1,y_1],..., [label_n,x_n,y_n]] for
   the leaves, where label_i is either "true" or "false"; x_i, y_i are the 
   coordinates of the label's position, (using the leave-coordinates in the 
   binary labelled rooted tree T).
TODO: See bug report "False labels at the leaves"; likely this function
      has just to be removed.
*/
tdlrt2label(T,l) := 
  if length(T) = 1 then [cons(if l=1 then "true" else 
                             if l=2 then "false" else
                             if l=0 then "", [x_tdlrt(T),y_tdlrt(T)-0.2])] else
  block([left,right],
  if length(T) = 3 then ([left,right]: map(tdlrt2label,rest(T),[1,2]),
                         append(left,right))
  else tdlrt2label(T[2],0))$

/* Draw an unlabelled rooted tree T, using the Reingold-Tilford algorithm. */
/* Parameter arg is a list which may be empty or may contain drawing 
   attributes. Missing attributes get default values, as specified below.
   The drawing attributes are defined as 
     [name_1, value_1, ... , name_N, value_N], n >= 0.
   Each attribute contains two fields, name and value, both of which must be
   provided. Possible attribute names and values are:

    root     : the root coordinates of the tree [x,y]; default [0,0].
    x_ran    : the range for the x coordinate [x_min,x_max]; default auto.
    y_ran    : the range for the y coordinate [y_min,y_max]; default auto.
    p_size   : the size of a point (a non-negative number); default computed
    p_type   : the type of points (either as name or as integer):
      $none (-1)
      dot (0)
      plus (1)
      multiply (2)
      asterisk (3)
      square (4)
      filled_square (5)
      circle (6)
      filled_circle (7) *default*
      up_triangle (8)
      filled_up_triangle (9)
      down_triangle (10)
      filled_down_triangle (11)
      diamant (12)
      filled_diamant (13)
    p_colour : the colour of points (red, blue, ...); default red.
    e_colour : the colour of edges (red, blue, ...); default blue.
*/
draw_rt(T,arg) := block([tdlrt,xdis,ydis,p:[0,0],xran:auto,
   yran:auto,pts,ptt:filled_circle,ptc:red,edgc:blue],
   if emptyp(arg)=false then
    for i:1 thru length(arg) step 2 do (
     if arg[i]= root then p:arg[i+1] else
     if arg[i]= x_ran then xran:arg[i+1] else
     if arg[i]= y_ran then yran:arg[i+1] else
     if arg[i]= p_size then pts:arg[i+1] else
     if arg[i]= p_type then ptt:arg[i+1] else
     if arg[i]= p_colour then ptc:arg[i+1] else
     if arg[i]= e_colour then edgc:arg[i+1]),
   tdlrt:reingold_tilford_annotated(T,p), 
   xdis:rightmost_x(tdlrt)-leftmost_x(tdlrt),
   ydis:y_tdlrt(tdlrt)-y_extreme_tdlrt(tdlrt),
   tdlrt:reingold_tilford_remove_annotations(tdlrt),
   if member(p_size,arg)=false then
   pts:min(10/(max(xdis,2)^(5/11)),10/(max(ydis,2)^(5/11))),
   apply(draw2d,
         append([grid=true,xrange = xran,yrange = yran,
                 point_size = pts,point_type = ptt,color = ptc,
                 points(tdlrt2points(tdlrt)),
                 apply(label,tdlrt2label(tdlrt,0)),
                 color=edgc,transparent=true],
                map(polygon, tdlrt2edges(tdlrt)))),
   true)$


/*!
\endhtmlonly
*/
