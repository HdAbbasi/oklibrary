/* Rui Wang, 28.10.2009 (Swansea) */
/* Copyright 2009 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Trees/Lisp/Visualisation.mac
  \brief Functions for tree drawing using Gnuplot

Use by

oklib_load("OKlib/ComputerAlgebra/Trees/Lisp/Visualisation.mac");

*/

/*!
\htmlonly
*/

oklib_include("OKlib/ComputerAlgebra/Trees/Lisp/ReingoldTilford.mac")$


/* ******************************
   * Tree drawing *
   ******************************
*/

/* Extract a list of points [[x1,y1], [x2,y2], ... , [xn,yn]] from a labelled
   rooted tree T with 2-dimensional coordinates:
*/
tdlrt2points(T) := block([nt,nt1,nt2],
      if rest(T)=[] then return([T[1][1]]) 
      else if length(rest(T))=2 
           then ([nt1,nt2]:map(tdlrt2points, rest(T)),
                 nt:cons(T[1][1],append(nt1,nt2))) 
           else ([nt1]:map(tdlrt2points, rest(T)),
                 nt:cons(T[1][1],nt1)),
      return(nt))$

/* Extract a list of edges [[[x1,y1],[x2,y2]], ... , [[xn',yn'],[xn,yn]]] from
   a labelled rooted tree T with 2-dimensional coordinates:
*/
tdlrt2edges(T) := block([nt,nt1,nt2],
      if rest(T)=[] then return(T) 
      else if length(rest(T))=2 
           then ([nt1,nt2]:map(tdlrt2edges, rest(T)), 
                 nt:append(cons([T[1][1],nt1[1][1]],
                                if rest(nt1)=[] and rest(nt1[1])=[] then [] 
                                else nt1),
                                cons([T[1][1],nt2[1][1]],
                                     if rest(nt2)=[] and rest(nt2[1])=[] then []
                                     else nt2))) 
           else ([nt1]:map(tdlrt2edges, rest(T)), 
                 nt:cons([T[1][1],nt1[1][1]],
                         if rest(nt1)=[] and rest(nt1[1])=[] then [] else nt1)), 
      return(nt))$

/* Produce a list of labels [[label_1,x_1,y_1],..., [label_n,x_n,y_n]] where the
label_i is a string either "true" or "false"; x_i, y_i are the coordinates of the
label's position, which according to the leaves in an binary labelled rooted tree
T.
*/
tdlrt2label(T,l) := 
  if length(T) = 1 then [cons(if l=1 then "true" else 
                             if l=2 then "false" else
                             if l=0 then "", [x_tdlrt(T),y_tdlrt(T)-0.2])] else
  block([left,right],
  if length(T) = 3 then ([left,right]: map(tdlrt2label,rest(T),[1,2]),
                         append(left,right))
  else tdlrt2label(T[2],0))$

/* Visualise an unlabelled rooted tree T. */
/* Parameter arg is a list which may be empty or contain drawing attributes. 
   If an empty list [] is provided, the automatic computation and drawing will
   be performed. Otherwise, the drawing attributes can be defined as
   [name_1, value_1, ... , name_N, value_N], n >= 0. Each attribute contains
   two fields, name and value, both of which must be provided.
   Possible attribute names and values are:
    root     : the root coordinates of the tree [x,y].
    x_ran    : the range for the x coordinate [x_min,x_max].
    y_ran    : the range for the y coordinate [y_min,y_max].
    p_size   : the size of a point, it must be a non-negative number.
    p_type   : the type of points (circle, diamant, ...)
    p_colour : the colour of points (red, blue, ...)
    e_colour : the colour of edges (red, blue, ...) 
*/
draw_rt(T,arg) := block([tdlrt,xdis,ydis,p:[0,0],xran:auto,
   yran:auto,pts,ptt:filled_circle,ptc:red,edgc:blue],
   if emptyp(arg)=false then
    for i:1 thru length(arg) step 2 do (
     if arg[i]= root then p:arg[i+1] else
     if arg[i]= x_ran then xran:arg[i+1] else
     if arg[i]= y_ran then yran:arg[i+1] else
     if arg[i]= p_size then pts:arg[i+1] else
     if arg[i]= p_type then ptt:arg[i+1] else
     if arg[i]= p_colour then ptc:arg[i+1] else
     if arg[i]= e_colour then edgc:arg[i+1]),
   tdlrt:reingold_tilford_annotated(T,p), 
   xdis:rightmost_x(tdlrt)-leftmost_x(tdlrt),
   ydis:y_tdlrt(tdlrt)-y_extreme_tdlrt(tdlrt),
   tdlrt:reingold_tilford_remove_annotations(tdlrt),
   if member(p_size,arg)=false then
   pts:min(10/(max(xdis,2)^(5/11)),10/(max(ydis,2)^(5/11))),
   apply(draw2d,
         append([grid=true,xrange = xran,yrange = yran,
                 point_size = pts,point_type = ptt,color = ptc,
                 points(tdlrt2points(tdlrt)),
                 apply(label,tdlrt2label(tdlrt,0)),
                 color=edgc,transparent=true],
                map(polygon, tdlrt2edges(tdlrt)))),
   true)$


/*!
\endhtmlonly
*/
