/* Rui Wang, 28.10.2009 (Swansea) */
/* Copyright 2009 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Trees/Lisp/Visualisation.mac
  \brief Functions for tree drawing using Gnuplot

Use by

oklib_load("OKlib/ComputerAlgebra/Trees/Lisp/Visualisation.mac");

*/

/*!
\htmlonly
*/

oklib_include("OKlib/ComputerAlgebra/Trees/Lisp/ReingoldTilford.mac")$


/* ******************************
   * Tree drawing *
   ******************************
*/

/* Extract a list of points [[x1,y1], [x2,y2], ... , [xn,yn]] from a labelled
   rooted tree T with 2-dimensional coordinates:
*/
tdlrt2points(T) := block([nt,nt1,nt2],
      if rest(T)=[] then return([T[1][1]]) 
      else if length(rest(T))=2 
           then ([nt1,nt2]:map(tdlrt2points, rest(T)),
                 nt:cons(T[1][1],append(nt1,nt2))) 
           else ([nt1]:map(tdlrt2points, rest(T)),
                 nt:cons(T[1][1],nt1)),
      return(nt))$

/* Extract a list of edges [[[x1,y1],[x2,y2]], ... , [[xn',yn'],[xn,yn]]] from
   a labelled rooted tree T with 2-dimensional coordinates:
*/
tdlrt2edges(T) := block([nt,nt1,nt2],
      if rest(T)=[] then return(T) 
      else if length(rest(T))=2 
           then ([nt1,nt2]:map(tdlrt2edges, rest(T)), 
                 nt:append(cons([T[1][1],nt1[1][1]],
                                if rest(nt1)=[] and rest(nt1[1])=[] then [] 
                                else nt1),
                                cons([T[1][1],nt2[1][1]],
                                     if rest(nt2)=[] and rest(nt2[1])=[] then []
                                     else nt2))) 
           else ([nt1]:map(tdlrt2edges, rest(T)), 
                 nt:cons([T[1][1],nt1[1][1]],
                         if rest(nt1)=[] and rest(nt1[1])=[] then [] else nt1)), 
      return(nt))$


/* Draw an unlabelled rooted tree T, using the Reingold-Tilford algorithm. */
/* Parameter arg is a list which may be empty or may contain drawing 
   attributes. Missing attributes get default values, as specified below.
   The drawing attributes are defined as 
     [name_1, value_1, ... , name_N, value_N], n >= 0.
   Each attribute contains two fields, name and value, both of which must be
   provided. Possible attribute names and values are:

    root     : the root coordinates of the tree [x,y]; default [0,0].
    x_ran    : the range for the x coordinate [x_min,x_max]; default auto.
    y_ran    : the range for the y coordinate [y_min,y_max]; default auto.
    p_size   : the size of a point (a non-negative number); default computed
    p_type   : the type of points (either as name or as integer):
      $none (-1)
      dot (0)
      plus (1)
      multiply (2)
      asterisk (3)
      square (4)
      filled_square (5)
      circle (6)
      filled_circle (7) *default*
      up_triangle (8)
      filled_up_triangle (9)
      down_triangle (10)
      filled_down_triangle (11)
      diamant (12)
      filled_diamant (13)
    p_colour : the colour of points (red, blue, ...); default red.
    e_colour : the colour of edges (red, blue, ...); default blue.
*/
draw_rt(T,arg) := block([tdlrt,xdis,ydis,p:[0,0],xran:auto,
   yran:auto,pts,ptt:filled_circle,ptc:red,edgc:blue],
   if emptyp(arg)=false then
    for i:1 thru length(arg) step 2 do (
     if arg[i]= root then p:arg[i+1] else
     if arg[i]= x_ran then xran:arg[i+1] else
     if arg[i]= y_ran then yran:arg[i+1] else
     if arg[i]= p_size then pts:arg[i+1] else
     if arg[i]= p_type then ptt:arg[i+1] else
     if arg[i]= p_colour then ptc:arg[i+1] else
     if arg[i]= e_colour then edgc:arg[i+1]),
   tdlrt:reingold_tilford_annotated(T,p), 
   xdis:rightmost_x(tdlrt)-leftmost_x(tdlrt),
   ydis:y_tdlrt(tdlrt)-y_extreme_tdlrt(tdlrt),
   tdlrt:reingold_tilford_remove_annotations(tdlrt),
   if member(p_size,arg)=false then
   pts:min(10/(max(xdis,2)^(5/11)),10/(max(ydis,2)^(5/11))),
   apply(draw2d,
         append([grid=true,xrange = xran,yrange = yran,
                 point_size = pts,point_type = ptt,color = ptc,
                 points(tdlrt2points(tdlrt)),                 
                 color=edgc,transparent=true],
                map(polygon, tdlrt2edges(tdlrt)))),
   true)$


/* Perform the tree drawing with a labelled rooted tree T. RGB colour model is
   used for the colouring schemes.
   For the details of parameter arg, see the specification of draw_rt.
*/
draw_lrt(T,arg) := block([tdlrt,xdis,ydis,p:[0,0],xran:auto,
   yran:auto,pts,ptt:filled_circle,ptc:red,edgc:blue],
   if emptyp(arg)=false then
    for i:1 thru length(arg) step 2 do (
     if arg[i]= root then p:arg[i+1] else
     if arg[i]= x_ran then xran:arg[i+1] else
     if arg[i]= y_ran then yran:arg[i+1] else
     if arg[i]= p_size then pts:arg[i+1] else
     if arg[i]= p_type then ptt:arg[i+1] else
     if arg[i]= p_colour then ptc:arg[i+1] else
     if arg[i]= e_colour then edgc:arg[i+1]),
   tdlrt:reingold_tilford_annotated(lrt2rt(T),p), 
   xdis:rightmost_x(tdlrt)-leftmost_x(tdlrt),
   ydis:y_tdlrt(tdlrt)-y_extreme_tdlrt(tdlrt),
   tdlrt:reingold_tilford_remove_annotations(tdlrt),
   if member(p_size,arg)=false then
   pts:min(10/(max(xdis,2)^(5/11)),10/(max(ydis,2)^(5/11))),
   apply(draw2d,
         append([grid=true,xrange = xran,yrange = yran,
                 point_size = pts,point_type = ptt],
                apply(append,(map(colouring, lrt2value(T),tdlrt2points(tdlrt)))),
                [color=edgc,transparent=true],
                map(polygon, tdlrt2edges(tdlrt)))),
   true)$


/* Extract the values of labels from a labelled rooted tree T.
   The output is a list [label1, label2, ... , labelN], where N equals the 
   number of nodes in the labelled rooted tree T. The order of the labels
   obeys the rule of a pre-order tree traversal.
*/
lrt2value(T) := if length(T) = 1 then [T[1]] else
    block([left,right], 
          if length(T) = 3 
          then ([left,right]: map(lrt2value, rest(T)),
                cons(T[1],append(left,right))) 
          else cons(T[1],lrt2value(T[2])))$
          
          
/* Convert a decimal number to a string in hexadecimal.
   10 -> "0A"
*/
dec2hex(n) := if n<16 then concat("0",printf(false,"~x",n))
              else concat(printf(false,"~x",n))$          


/* Convert RGB decimal value to standard Maxima RGB code.
   [14,2,51] -> "#0E0233"
*/
format_rgb(rgb) := apply(concat,append(["#"],map(dec2hex,rgb)))$    


/* Convert a list of values (usually a label in a labelled rooted tree) to    
   standard Maxima RGB code.
   [value1, value2,...] -> "#rrggbb"
*/
/* Currently, the function handles the list that contains only 1 value,
   otherwise, the output colour is red ("#FF0000").
*/
value2rgb(v) := apply(format_rgb,
          [if length(v)>=1 then
            (if v[1]=true then [255,255,255] else
             if v[1]=false then [0,0,0] else
               [255-min(v[1]*15,255),min(v[1],255),min(v[1]*10,255)]) else
             [255,0,0]])$


/* Binding one colour to one point.
*/
colouring(v,p) := [color= value2rgb(v),points([p])]$


/* Print the labels of the nodes of a binary labelled rooted tree T instead of
   the node-symbols up to the depth d, where d is a natural number >= -1, and
   for the nodes of depth <= d then the labels are printed, while otherwise 
   the (normal) node-symbol is shown. Leaves are treated differently, where
   the leaves that are labelled by "true" show the node-symbol with white
   colour, otherwise black colour.
   For the details of parameter arg, see the specification of draw_rt.
*/
draw_lrt_dbl(T,arg,d) := block([nd,tdlrt,xdis,ydis,p:[0,0],xran:auto,
   yran:auto,pts,ptt:filled_circle,ptc:red,edgc:blue],
   if emptyp(arg)=false then
    for i:1 thru length(arg) step 2 do (
     if arg[i]= root then p:arg[i+1] else
     if arg[i]= x_ran then xran:arg[i+1] else
     if arg[i]= y_ran then yran:arg[i+1] else
     if arg[i]= p_size then pts:arg[i+1] else
     if arg[i]= p_type then ptt:arg[i+1] else
     if arg[i]= p_colour then ptc:arg[i+1] else
     if arg[i]= e_colour then edgc:arg[i+1]),
   tdlrt:reingold_tilford_annotated(lrt2rt(T),p), 
   xdis:rightmost_x(tdlrt)-leftmost_x(tdlrt),
   ydis:y_tdlrt(tdlrt)-y_extreme_tdlrt(tdlrt),
   tdlrt:reingold_tilford_remove_annotations(tdlrt),
   nd: nodes_division(tdlrt2points(tdlrt),lrt2value(T),d),
   if member(p_size,arg)=false then
   pts:min(10/(max(xdis,2)^(5/11)),10/(max(ydis,2)^(5/11))),
   apply(draw2d,
         append([grid=true,xrange = xran,yrange = yran,
                 point_size = pts,point_type = ptt,color = ptc],
                 if not(nd[1]=[]) then
                  [apply(label,map(cons,map(string,apply(append,nd[2])),nd[1]))]
                 else [],
                 if not(nd[3]=[]) then
                  [points(nd[3])]
                 else [],
                 if not(nd[5]=[]) then
                  apply(append,(map(colouring, nd[6],nd[5])))
                 else [],
                 [color=edgc,transparent=true],
                 map(polygon, tdlrt2edges(tdlrt)))),
   true)$


/* Dividing the nodes of trees into 3 parts according to the depth d and 
   whether nodes are leaves.
   Input: a point list pl, a value list vl and depth d.
   Output: a list [pointlist1,valuelist1,pointlist2,valuelist2,pointlist3,
   valuelist3], where pointlist1 and valuelist1 are relating to the nodes
   above the depth d(inclusive), pointlist2 and valuelist2 are relating to
   the nodes below the depth d, pointlist3 and valuelist3 are relating to
   the nodes which are leaves.
*/
nodes_division(pl,vl,d) := 
    block([y: pl[1][2]+d*(-1), l:[[],[],[],[],[],[]]],
          for i:1 thru length(pl)-1 do
            (if i=length(pl) then 
              (l[5]:endcons(pl[i],l[5]), l[6]:endcons(vl[i],l[6])) else
             if pl[i][2]<=pl[i+1][2] then
               (l[5]:endcons(pl[i],l[5]), l[6]:endcons(vl[i],l[6])) else
             if pl[i][2]>=y then
               (l[1]:endcons(pl[i],l[1]), l[2]:endcons(vl[i],l[2])) else 
               (l[3]:endcons(pl[i],l[3]), l[4]:endcons(vl[i],l[4]))),
          if length(pl) =1 and d>=0 then
            [[pl[1]],[vl[1]],[[]],[[]],[[]],[[]]] else 
          if length(pl) =1 and d=-1 then
            [[[]],[[]],[pl[1]],[vl[1]],[[]],[[]]] else
            (l[5]:endcons(pl[length(pl)],l[5]),
             l[6]:endcons(vl[length(pl)],l[6]),
             l)
)$


/*!
\endhtmlonly
*/
