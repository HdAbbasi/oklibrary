/* Rui Wang, 28.9.2009 (Swansea) */
/* Copyright 2009 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Trees/Lisp/ReingoldTilford.mac
  \brief Functions of Reingold-Tilford algorithm

Use by

oklib_load("OKlib/ComputerAlgebra/Trees/Lisp/ReingoldTilford.mac");

*/

/*!
\htmlonly
*/

oklib_include("OKlib/ComputerAlgebra/Trees/Lisp/Basics.mac")$


/* ******************************
   * Reingold-Tilford algorithm *
   ******************************
*/

/* Produce a labelled rooted tree with 2-dimensional coordinates from an 
   unlabelled rooted tree T with specified root coordinates x, y. 
*/
reingold_tilford_rt(T,x,y) := block([rt],cons([[x,y]],rest(apply(rt:lambda([T,x,y],block([tc,tl,tr,temp],if T=[] then return([[[x,y],[x,x]]]) else
(if length(T) = 2 then
([tl,tr]:map(rt,T,create_list(x,i,1,length(T)),create_list(y-1,i,1,length(T))),
if mod(((tl[1][2][2]-tl[1][1][1])-(tr[1][2][1]-tr[1][1][1])+1),2)=0
then temp:((tl[1][2][2]-tl[1][1][1])-(tr[1][2][1]-tr[1][1][1])+1)/2
else temp:((tl[1][2][2]-tl[1][1][1])-(tr[1][2][1]-tr[1][1][1])+2)/2,
tl:trans_lrt(tl,[-temp-tl[1][1][1]+x,0]),
tr:trans_lrt(tr,[+temp-tr[1][1][1]+x,0]),
tc:cons([[x,y],[tl[1][2][1]-temp,tr[1][2][2]+temp]],[cons([tl[1][1]],rest(tl)),cons([tr[1][1]],rest(tr))]),
return(tc))
else
( [tl]:map(rt,T,[x],[y-1]),
temp:((tl[1][2][2]-tl[1][1][1])+1),
tl:trans_lrt(tl,[-temp-tl[1][1][1]+x,0]),
tc:cons([[x,y],[tl[1][2][1]-temp,x]],[cons([tl[1][1]],rest(tl))]),
return(tc))
))), [T,x,y]))))$


/*!
\endhtmlonly
*/
