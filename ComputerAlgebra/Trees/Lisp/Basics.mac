/* Oliver Kullmann, 12.1.2008 (Swansea) */
/* Copyright 2008 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Trees/Lisp/Basics.mac
  \brief Functions for handling trees

Use by

oklib_load("Transitional/ComputerAlgebra/Trees/Lisp/Basics.mac");

*/

/*!
\htmlonly
*/

oklib_include("Transitional/ComputerAlgebra/Graphs/Lisp/Basic.mac")$


/* ****************************
   * Unlabelled rooted trees  *
   ****************************
*/

/* An "unlabelled rooted tree" is recursively defined as a list
   [T_1, ..., T_n], where the T_i are the subtrees (the case
   n=0, i.e., the empty list, represents the trivial tree).
*/

/* the number of nodes in an unlabelled tree */
nnds(T) := 1+sum(nnds(T[i]),i,1,length(T))$

/* the number of leaves in an unlabelled rooted tree */
nlvs(T) := if T = [] then 1 else sum(nlvs(T[i]),i,1,length(T))$

/* A "node representation" for an unlabelled rooted tree is a list
   of natural numbers (>= 1) representing the path from the root
   to the node. */

/* the set of "leaves" of an unlabelled tree */
lvs(T) := if emptyp(T) then {[]} else
  apply(union,
    makelist(
      map(lambda([p], cons(i,p)), lvs(T[i])),
      i,1,length(T)))$

/* the set of "nodes" of an unlabelled tree */
nds(T) := union({[]}, apply(union,
  makelist(
    map(lambda([p], cons(i,p)), nds(T[i])),
    i,1,length(T))))$

/* the subtee of unlabelled tree T at node (representation) p */
subtree(T,p) := if p = [] then T else
  subtree(T[p[1]], rest(p))$

/* the successor nodes (i.e., representations) of node (representation) p
   in unlabelled tree T */
dst(T,p) := block([S : subtree(T,p)],
  setify(makelist(endcons(i,p),i,1,length(S))))$


/* the height of an unlabelled tree */
height(T) := if T = [] then 0 else
  1 + lmax(makelist(height(T[i]),i,1,length(T)))$

/* the "levelled height" of an unlabelled tree 
   (also the "Horton-Strahler number" */
levelled_height(T) := if T = [] then 0 else block(
 [l : length(T), max : minf, imax, strict : true],
  block([H : makelist(levelled_height(T[i]),i,1,l)],
   for i : 1 thru l do
    if H[i] > max then (imax : i, max : H[i]),
   for i : 1 thru l unless not strict do
    if i # imax and H[i] = max then strict : false,
   if strict then return(max) else return(1+max)))$


/* ****************************
   * Labelled rooted trees    *
   ****************************
*/

/* A "labelled rooted tree" is recursively defined as a list
   [L, T_1, ..., T_n], n >= 0, where L is the label, and the T_i
   are the subtrees.
*/

/* transforms a labelled into an unlabelled tree by removing the labels */
l2ult(T) := makelist(l2ult(T[i]),i,2,length(T))$

/* number of nodes in a labelled rooted tree */
nnds_l(T) := if length(T) = 1 then 1 else 1+sum(nnds_l(T[i]),i,2,length(T))$

/* the number of leaves in a labelled rooted tree */
nlvs_l(T) := if length(T) = 1 then 1 else sum(nlvs_l(T[i]),i,2,length(T))$

/* Transforms a graph G, which is a tree, into a labelled rooted tree 
   (using root r) */
graph2tree(G,r) := block([N : listify(neighbours(r,G))],
 return(cons(r, makelist(graph2tree(remove_vertices_graph({r},G),v),v,N))))$

load(graphs);
/* a random labelled tree with n vertices (labels 0,...,n-1; root is 0) */
random_ltree(n) := graph2tree(mg2g(random_tree(n)),0);


/*!
\endhtmlonly
*/
