// Matthew Gwynne, 4.8.2009 (Swansea)
/* Copyright 2009 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file Experimentation/Investigations/Cryptography/AdvancedEncryptionStandard/plans/BreakingAES_R1-5.hpp
  \brief On investigations into breaking reduced round variants of the AES with small numbers of rounds


  \todo Breaking one round AES using the canonical translation for Sbox and Mul
  <ul>
   <li> The aim here is to monitor the performance of a variety of solvers on
   the one-round variant of the "canonical" AES translation, providing all 
   plaintext and ciphertext bits but leaving n key bits unknown where n ranges
   from 0 to 128. </li>
   <li> The basic questions here are simply:
    <ul>
     <li> How do current SAT solvers perform on these problems? </li>
     <li> Are there any solvers that perform far better than others on
     these problems? If so why? (Such things may suggest improvements in
     formulations of the problem. </li>
     <li> Are there any interesting boundaries after which the problems
     become hard with the current formulations? </li>
    </ul>
   The idea is simply to get one's bearings with respect to the problem.
   </li>
   <li> For the sake of simple experimental, the plaintext and key are all
   zero and the ciphertext is the corresponding ciphertext given 1-round AES. 
   Further experimentation can be done using random keys if a pattern emerges.
   </li>
   <li> Note, in the context of the problem, the full key is known (all zeros)
   but how much of this key is provided in the SAT problem to the SAT solver
   is then restricted, and the SAT problem is then to derive this key. </li>
   <li> See "Generating experiments" in 
   Investigations/Cryptography/AdvancedEncryptionStandard/plans/BreakingAES.hpp
   for details on generating an experiment set for this experiment ($N=1).
   </li>
   <li> minisat2 seems to perform reasonably well on such problems:
    <ul>
     <li> With 10 key bits unknown: 
     \verbatim
cs360678@cspasiphae:~> cat AES_1_Round/AES_R1_P0_K0_CX_KN10.cnf.result.minisat2 | grep -v ".\{1000,\}"
restarts              : 1
conflicts             : 0              (0 /sec)
decisions             : 1              (0.00 % random) (1 /sec)
propagations          : 32176          (19666 /sec)
conflict literals     : 0              ( nan % deleted)
CPU time              : 1.6361 s
SATISFIABLE
     \endverbatim
     </li>
     <li> With 50 key bits unknown:
     \verbatim
cs360678@cspasiphae:~> cat AES_1_Round/AES_R1_P0_K0_CX_KN50.cnf.result.minisat2 | grep -v ".\{1000,\}"
restarts              : 1
conflicts             : 9              (2 /sec)
decisions             : 648            (1.85 % random) (143 /sec)
propagations          : 75870          (16755 /sec)
conflict literals     : 1075           (11.89 % deleted)
CPU time              : 4.52828 s
SATISFIABLE
     \endverbatim
     </li>
     <li> With 80 key bits unknown:
     \verbatim
cs360678@cspasiphae:~> cat AES_1_Round/AES_R1_P0_K0_CX_KN80.cnf.result.minisat2 | grep -v ".\{1000,\}"
restarts              : 15
conflicts             : 64225          (214 /sec)
decisions             : 139765         (1.39 % random) (467 /sec)
propagations          : 151211470      (504801 /sec)
conflict literals     : 21865300       (54.62 % deleted)
CPU time              : 299.547 s
SATISFIABLE
     \endverbatim
     </li>
    </ul>
   </li>
   <li> picosat seems to perform extremely well in this instance:
   \verbatim
s SATISFIABLE
c 0 iterations
c 0 restarts
c 0 failed literals
c 0 conflicts
c 16 decisions
c 6296 fixed variables
c 6012 learned literals
c 10033828 propagations
c 1.8 seconds total run time
   \endverbatim
   even for the full AES (tested in a seperate experiment):
   \verbatim
[19:42:51 - aeternus] AES_10_Round$ picosat913 AES_R10_P0_K0_CX_KN128.cnf  | grep -v "^v"
s SATISFIABLE
c 0 iterations
c 0 restarts
c 0 failed literals
c 0 conflicts
c 128 decisions
c 336 fixed variables
c 256 learned literals
c 10291832 propagations
c 3.1 seconds total run time
   \endverbatim
   </li>
   <li> However, in the case of picosat913, it seems that the heuristics are 
   such that it happens to try an all zero key first. Trying a more random
   key, generated by:
   \verbatim
aes_num_rounds : 1$
for bits_to_remove : 0 thru 128 do block([PA],
  PA : map(set,
    union(
      aes_hex2pa("00000000000000000000000000000000", create_list(i,i,1,128)),
      aes_hex2pa("123456789ABCDEF0123456789ABCDEF0", create_list(i,i,129,256)),
      aes_hex2pa(
        aes_encrypt_hex(
          "00000000000000000000000000000000", 
	  "123456789ABCDEF0123456789ABCDEF0"), 
          create_list(i,i,257,384)))),
  PA : subset(PA, lambda([a], 
      not(member(map(abs,a), create_list({i},i,129,129+(bits_to_remove-1)))))),
  output_fcs(
    sconcat("AES Unit Clause assignment for all zero plaintext and key ",
            "and associated ciphertext with the first ", bits_to_remove," bits",
            "left unset in the key. Rounds = ",aes_num_rounds)  , 
    cs2fcs(PA), 
    sconcat("AES_UC_P0_KX_CX_KN",bits_to_remove,".cnf"))
)$
   \endverbatim
   and then
   \verbatim
./merge_cnf.sh AES_R1.cnf AES_UC_P0_KX_CX_KN75.cnf > AES_R1_P0_KX_CX_KN75.cnf
   \endverbatim
   results in far more reasonable results:
   \verbatim
$ picosat913 AES_R1_P0_KX_CX_KN75.cnf | grep -v "^v"
s SATISFIABLE
c 7 iterations
c 150 restarts
c 496 failed literals
c 32544 conflicts
c 241499 decisions
c 7062 fixed variables
c 9887444 learned literals
c 77729689 propagations
c 48.8 seconds total run time
   \endverbatim
   </li>
   <li> OKsolver_2002 seems to perform well 
   <ul>
    <li> 
    \verbatim
cs360678@cspasiphae:~> cat AES_1_Round/AES_R1_P0_K0_CX_KN72.cnf.result.OKsolver | grep -v "^v"
s SATISFIABLE
c sat_status=1 initial_maximal_clause_length=256 initial_number_of_variables=32176 initial_number_of_clauses=510420 initial_number_of_literal_occurrences=1500064 running_time(s)=8.7 number_of_nodes=1 number_of_single_nodes=0 number_of_quasi_single_nodes=0 number_of_2-reductions=255 number_of_pure_literals=0 number_of_autarkies=0 number_of_missed_single_nodes=0 max_tree_depth=0 number_of_table_enlargements=0 reduced_maximal_clause_length=0 reduced_number_of_variables=7136 reduced_number_of_clauses=110841 reduced_number_of_literal_occurrences=326240 number_of_1-autarkies=0 number_of_initial_unit-eliminations=7136 number_of_new_2-clauses=0 maximal_number_of_added_2-clauses=0 initial_number_of_2-clauses=374080 file_name=AES_R1_P0_K0_CX_KN72.cnf
    \endverbatim
     (this should be updated using the current OKsolver_2002).
    </li>
    <li> However, when the number of unknown key bits reaches 73 and above, 
    OKsolver_2002 takes more time (though the problem is still very simple):
    \verbatim
cs360678@cspasiphae:~> cat AES_1_Round/AES_R1_P0_K0_CX_KN73.cnf.result.OKsolver | grep -v "^v"
s SATISFIABLE
c sat_status=1 initial_maximal_clause_length=256 initial_number_of_variables=32176 initial_number_of_clauses=510419 initial_number_of_literal_occurrences=1500063 running_time(s)=269.7 number_of_nodes=3 number_of_single_nodes=0 number_of_quasi_single_nodes=0 number_of_2-reductions=580 number_of_pure_literals=0 number_of_autarkies=0 number_of_missed_single_nodes=0 max_tree_depth=1 number_of_table_enlargements=0 reduced_maximal_clause_length=0 reduced_number_of_variables=6571 reduced_number_of_clauses=101979 reduced_number_of_literal_occurrences=300149 number_of_1-autarkies=0 number_of_initial_unit-eliminations=6571 number_of_new_2-clauses=0 maximal_number_of_added_2-clauses=0 initial_number_of_2-clauses=382261 file_name=AES_R1_P0_K0_CX_KN73.cnf
    \endverbatim
    </li>
    <li>
    \verbatim
cs360678@cspasiphae:~> cat AES_1_Round/AES_R1_P0_K0_CX_KN75.cnf.result.OKsolver | grep -v "^v"
s SATISFIABLE
c sat_status=1 initial_maximal_clause_length=256 initial_number_of_variables=32176 initial_number_of_clauses=510417 initial_number_of_literal_occurrences=1500061 running_time(s)=17567.7 number_of_nodes=516 number_of_single_nodes=0 number_of_quasi_single_nodes=0 number_of_2-reductions=213261 number_of_pure_literals=0 number_of_autarkies=0 number_of_missed_single_nodes=0 max_tree_depth=13 number_of_table_enlargements=0 reduced_maximal_clause_length=0 reduced_number_of_variables=6559 reduced_number_of_clauses=101889 reduced_number_of_literal_occurrences=299893 number_of_1-autarkies=0 number_of_initial_unit-eliminations=6559 number_of_new_2-clauses=0 maximal_number_of_added_2-clauses=0 initial_number_of_2-clauses=382334 file_name=AES_R1_P0_K0_CX_KN75.cnf
    \endverbatim
    </li>
   </ul>
   </li>
   <li> Preprocessing seems to help OKsolver_2002 considerably here:
   \verbatim
cs360678@cspasiphae:~> cat AES_1_Round/AES_R1_P0_K0_CX_KN75.cnf.result.OKsolver-m2pp | grep -v "^v"
s UNKNOWN
c sat_status=2 initial_maximal_clause_length=256 initial_number_of_variables=32176 initial_number_of_clauses=510417 initial_number_of_literal_occurrences=1500061 running_time(s)=0.6 number_of_nodes=0 number_of_single_nodes=0 number_of_quasi_single_nodes=0 number_of_2-reductions=0 number_of_pure_literals=0 number_of_autarkies=0 number_of_missed_single_nodes=0 max_tree_depth=0 number_of_table_enlargements=0 reduced_maximal_clause_length=0 reduced_number_of_variables=6559 reduced_number_of_clauses=101889 reduced_number_of_literal_occurrences=299893 number_of_1-autarkies=0 number_of_initial_unit-eliminations=6559 number_of_new_2-clauses=0 maximal_number_of_added_2-clauses=0 initial_number_of_2-clauses=0 file_name=AES_R1_P0_K0_CX_KN75.cnf
s SATISFIABLE
c sat_status=1 initial_maximal_clause_length=129 initial_number_of_variables=24912 initial_number_of_clauses=407544 initial_number_of_literal_occurrences=1363708 running_time(s)=634.9 number_of_nodes=3 number_of_single_nodes=0 number_of_quasi_single_nodes=0 number_of_2-reductions=1480 number_of_pure_literals=0 number_of_autarkies=0 number_of_missed_single_nodes=0 max_tree_depth=2 number_of_table_enlargements=0 reduced_maximal_clause_length=0 reduced_number_of_variables=0 reduced_number_of_clauses=0 reduced_number_of_literal_occurrences=0 number_of_1-autarkies=0 number_of_initial_unit-eliminations=0 number_of_new_2-clauses=0 maximal_number_of_added_2-clauses=0 initial_number_of_2-clauses=380039 file_name=AES_R1_P0_K0_CX_KN75.cnf_m2pp_17180
   \endverbatim
   </li>
   <li> march_pl also doesn't seem to work particularly well on such problems,
   although faster than OKsolver_2002:
   <ul>
    <li> For the number of unknown key bits being 10, march_pl takes under a 
    second. (??? the number of nodes is important!) </li>
    <li> For the number of unknown key bits being 50, march_pl takes around 
    25 seconds. </li>
    <li> For the number of unknown key bits being 75, march_pl takes nearly 
    3 hours (2:53:31). </li>
    <li> Timings are given from the process monitoring which is to within 2 
    seconds. </li>
    <li> The experiments should be paused, and restarted with an updated
    "run_experiments.sh" including use of the "time" command to give accurate
    readings, especially for solvers such as march with broken timers (the 
    timer overflows). </li>
   </ul>
   </li>
   <li> Monitoring scripts in the R system should be written to read the output
   of each solver, so such data can be easily amalgamated and then properly
   analysed. </li>
   <li> Experiments currently running on "cspasiphae", from n=128 (where n is 
   the number of missing key bits) to n=0 in steps of 5, with a timeout of 2
   hours. </li>
   <li> (DONE - No, simply adding a timeout is better, and analysing the 
   behaviour of, for example, the OKsolver for the time it runs is useful)
   OKsolver_2002 and march_pl seem to considerably slow the experiment in
   this case and so it may be reasonable to remove them for larger numbers of
   unknown key bits? </li>
  </ul>


  \todo Breaking two round AES using the canonical translation for Sbox and Mul
  <ul>
   <li> See "Breaking one round AES using the canonical translation for Sbox 
   and Mul" for aims, questions, and how to generate this experiment ($N=2). 
   </li>
   <li> Experiments currently running on "cssinope", from n=128 (where n is 
   the number of missing key bits) to n=0 in steps of 5, with a timeout of 2
   hours. </li>
   <li> For up to eight unknown key bits, the problem is trivial, and minisat2 
   requires a single decision, and the rest follows by propagation. With 
   OKsolver_2002 everything follows purely by propagation. </li>
   <li> From 9 unknown key bits onwards, the number of decisions required to 
   find the satisfying assignment with minisat2 seems to grow exponentially:
   <table>
   <tr>
    <th> Number of unknown key bits </th><th>Decisions</th>
    <th>Conflicts</th><th>Restarts</th><th>CPU time (s)</th>
   </tr>
   <tr><td>9</td><td>33</td><td>3</td><td>1</td><td>6.4</td></tr>
   <tr><td>10</td><td>265</td><td>5</td><td>1</td><td>6.66</td></tr>
   <tr><td>11</td><td>479</td><td>17</td><td>1</td><td>6.8</td></tr>
   <tr><td>15</td><td>724</td><td>138</td><td>2</td><td>7.8</td></tr>
   <tr><td>16</td><td>3070</td><td>493</td><td>4</td><td>9.2</td></tr>
   <tr><td>20</td><td>81076</td><td>15848</td><td>11</td><td>39.7</td></tr>
   </table>
REMARK OK: the text should be readable as pure text, so no such html-tables please. Numerical evaluation by R-tools is needed.

   From 8 to 9 and from 15 to 16 unknown key bits, the behaviour seems to 
   change dramatically. Could this have something to do with the byte 
   boundaries in the key?
   </li>
   <li> Why do the first 8 key bits follow immediately by unit clause 
   elimination? </li>
   <li> With OKsolver_2002 however, the number of nodes is always low and there
   are a significant number of 2-reductions:
\verbatim
> oklib_load_all()
> options(width=250)
> df <- read_oksolver_outputs(dir(pattern=glob2rx("AES_R*_P0*.cnf.result.OKsolver")))
> df <- extract_new_column(df,"file_name","unknown_key_bits", "(?<=AES_R[0-9]_P0_K0_CX_KN).*(?=\\.cnf$)", as.integer)
> df[order(df[,"unknown_key_bits"]), c("unknown_key_bits","number_of_nodes","number_of_2reductions","running_times","number_of_initial_uniteliminations")]
   unknown_key_bits number_of_nodes number_of_2reductions running_times number_of_initial_uniteliminations
1                 0               0                     0           1.4                              63840
2                 1               0                     0           1.4                              63840
13                2               0                     0           1.4                              63840
20                3               0                     0           1.3                              63840
21                4               0                     0           1.3                              63840
22                5               0                     0           1.3                              63840
23                6               0                     0           1.3                              63840
24                7               0                     0           1.3                              63840
25                8               0                     0           1.3                              63840
26                9               1                     1           1.5                              35031
3                10               1                    35           1.6                              34974
4                11               1                   255           2.4                              34877
5                12               1                   255           2.5                              34700
6                13               1                   255           2.6                              34363
7                14               1                   255           3.0                              33706
8                15               1                   255           3.9                              32409
9                16               1                   255           6.8                              29832
10               17               1                  1933         155.5                              22562
11               18               2                  6586         805.3                              22508
12               19               8                  7556        2839.7                              22416
14               20               9                  7556        3539.5                              22248
15               21              10                  7556        4213.0                              21928
16               22               7                  6980        3585.9                              21304
17               23               8                  6980        4353.8                              20072
18               24               7                  6735        4583.9                              17624
19               25               8                  8838        5313.3                              11901
\endverbatim
   However, OKsolver_2002 takes a significant amount of time as the problem 
   increases, presumably because the problem is large and computing
   2-reductions on such a large CNF is expensive. </li>
   <li> For any of the runs so far, for $KN=0 to $KN=25, the OKsolver
   has not found any autarkies. </li>
  </ul>


  \todo Breaking three round AES using the canonical translation for Sbox and 
  Mul
  <ul>
   <li> See "Breaking one round AES using the canonical translation for Sbox 
   and Mul" for aims, questions, and how to generate this experiment ($N=3). 
   </li>
   <li> Experiments currently running on "cselara", from n=128 (where n is 
   the number of missing key bits) to n=0 in steps of 5, with a timeout of 2
   hours. </li>
   <li> OKsolver seems to solve these problems (for the currently solved $KN)
   with very few nodes, and this seems to be mostly due to r2 reductions:
   \verbatim
> oklib_load_all()
> options(width=250)
> df <- read_oksolver_outputs(dir(pattern=glob2rx("AES_R*_P0*.cnf.result.OKsolver")))
> df <- extract_new_column(df,"file_name","unknown_key_bits", "(?<=AES_R[0-9]_P0_K0_CX_KN).*(?=\\.cnf$)", as.integer)
> df[order(df[,"unknown_key_bits"]), c("unknown_key_bits","number_of_nodes","number_of_2reductions","running_times","number_of_initial_uniteliminations")]
   unknown_key_bits number_of_nodes number_of_2reductions running_times number_of_initial_uniteliminations
1                 0               0                     0           2.0                              95504
2                 1               1                     2          11.1                              45747
10                2               1                     6          11.1                              45678
11                3               1                     7          11.2                              45565
12                4               1                    15          11.4                              45364
13                5               1                    31          11.9                              44987
14                6               1                    63          13.2                              44258
15                7               1                   127          15.7                              42825
16                8               1                   255          22.1                              39984
17                9               2                  2155        1400.4                              31321
3                10               2                  7593         967.6                              31258
4                11               8                  8810        3334.2                              31153
5                12               9                  8810        4151.2                              30964
6                13              10                  8810        4928.3                              30607
7                14               7                  8226        4117.7                              29914
8                15               8                  8226        5016.5                              28549
9                16               7                  7975        6837.5                              25840
   \endverbatim
   </li>
  </ul>


  \todo Breaking four round AES using the canonical translation for Sbox and 
  Mul
  <ul>
   <li> See "Breaking one round AES using the canonical translation for Sbox 
   and Mul" for aims, questions, and how to generate this experiment ($N=4). 
   </li>
   <li> Experiments currently running on "csananke", from n=128 (where n is 
   the number of missing key bits) to n=0 in steps of 5, with a timeout of 2
   hours. </li>
   <li> Again, as with three rounds, OKsolver seems to solve these instances 
   with very few nodes, and with very similar numbers of nodes in each case
   to three rounds:
   \verbatim
> oklib_load_all()
> options(width=250)
> df <- read_oksolver_outputs(dir(pattern=glob2rx("AES_R*_P0*.cnf.result.OKsolver")))
> df <- extract_new_column(df,"file_name","unknown_key_bits", "(?<=AES_R[0-9]_P0_K0_CX_KN).*(?=\\.cnf$)", as.integer)
> df[order(df[,"unknown_key_bits"]), c("unknown_key_bits","number_of_nodes","number_of_2reductions","running_times","number_of_initial_uniteliminations")]
   unknown_key_bits number_of_nodes number_of_2reductions running_times number_of_initial_uniteliminations
1                 0               0                     0           2.6                             127168
2                 1               1                     1          17.7                              42052
9                 2               1                     4          17.8                              41976
10                3               1                     7          18.3                              41854
11                4               1                    15          18.5                              41640
12                5               1                    31          20.2                              41242
13                6               1                    63          23.4                              40476
14                7               1                   127          29.7                              38974
15                8               1                   255          44.1                              36000
16                9               2                  2109        1289.6                              27491
3                10               2                  7577         991.0                              27462
4                11               8                  8798        3370.5                              27421
5                12               9                  8798        4084.2                              27356
6                13              10                  8798        5453.9                              27243
7                14               7                  8214        5910.2                              27034
8                15               8                  8214        7351.0                              26633
   \endverbatim
   </li>
   <li> Why are the number of nodes the same here as in round 3 and round 2? 
   </li>
   <li> One should look at the search tree and see which variables
   are being branched on? </li>
  </ul>


  \todo Breaking five round AES using the canonical translation for Sbox and 
  Mul
  <ul>
   <li> See "Breaking one round AES using the canonical translation for Sbox 
   and Mul" for aims, questions, and how to generate this experiment ($N=5). 
   </li>
   <li> Experiments currently running on "csmiranda", from n=128 (where n is 
   the number of missing key bits) to n=0 in steps of 5, with a timeout of 2
   hours. </li>
   <li> The OKsolver has very similar results again for five rounds as for 
   four rounds:
   \verbatim
> oklib_load_all()
> options(width=250)
> df <- read_oksolver_outputs(dir(pattern=glob2rx("AES_R*_P0*.cnf.result.OKsolver")))
> df <- extract_new_column(df,"file_name","unknown_key_bits", "(?<=AES_R[0-9]_P0_K0_CX_KN).*(?=\\.cnf$)", as.integer)
> df[order(df[,"unknown_key_bits"]), c("unknown_key_bits","number_of_nodes","number_of_2reductions","running_times","number_of_initial_uniteliminations")]
   unknown_key_bits number_of_nodes number_of_2reductions running_times number_of_initial_uniteliminations
1                 0               0                     0           3.3                             158832
2                 1               1                     1          23.0                              38222
9                 2               1                     4          21.9                              38180
10                3               1                     7          23.7                              38122
11                4               1                    15          24.5                              38032
12                5               1                    31          27.2                              37878
13                6               1                    63          31.8                              37596
14                7               1                   127          43.0                              37058
15                8               1                   255          64.2                              36008
16                9               2                  2109        1217.2                              27499
3                10               2                  7577         980.6                              27470
4                11               8                  8798        3330.2                              27429
5                12               9                  8798        4062.7                              27364
6                13              10                  8798        4759.2                              27251
7                14               7                  8214        3888.0                              27042
8                15               8                  8214        4755.3                              26641
   \endverbatim
   </li>
   <li> Five rounds and four rounds with the OKsolver seem to produce very 
   similar results, only differing in the number of unit clause eliminations.
   </li>
   <li> Why are the results so similar, given the change in clause sets, one
   would expect a much greater change. </li>
   <li> Again (for all rounds so far), the OKsolver finds no autarkies. </li>
  </ul>

  
  \todo Breaking two round AES using Sbox and Mul translations with no new 
  variables
  <ul>
   <li> A CNF representing a two round AES variant (one round and the final 
   round) can be generated in the following way:
   \verbatim
:lisp (ext:set-limit 'ext:heap-size 3000000000)
:lisp (ext:set-limit 'ext:frame-stack 10000)
:lisp (ext:set-limit 'ext:c-stack 200000)
:lisp (ext:set-limit 'ext:lisp-stack 200000)


oklib_load_all()$
aes_num_rounds : 2$

block([oklib_monitoring : true], CS : aes_cnf_fcs())$
output_fcs("AES - 2 Rounds - No new variables", F, "AES_r2_nnv.cnf")$
   \endverbatim
   </li>
  </ul>

*/
