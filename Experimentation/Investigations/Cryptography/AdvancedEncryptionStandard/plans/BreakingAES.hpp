// Matthew Gwynne, 4.8.2009 (Swansea)
/* Copyright 2009 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file Experimentation/Investigations/Cryptography/AdvancedEncryptionStandard/plans/BreakingAES.hpp
  \brief On investigations on breaking AES


  \todo Breaking AES
  <ul>
   <li> What do we mean by "Breaking AES"?
   <ul>
    <li> We take the standard notion of "breaking" a symmetric block cipher, 
    namely that if given a set of plaintext/ciphertext pairs, encrypted using 
    the same key, can we then deduce the key faster than a brute force search? 
    </li>
    <li> The size of the set of plaintext/ciphertext pairs needed, and how
    much faster than brute force one can find the key are then matters of 
    practicality. </li>
    <li> Given a single plaintext/ciphertext pair, there may be multiple keys
    for which the AES algorithm maps that plaintext block to that ciphertext
    block given that key. Therefore, for the purposes of "breaking" AES in
    earnest, one may require providing multiple AES translations, each 
    considering different plaintext/ciphertext pairs, but using the same key
    variables (see "Generate translation that allows multiple 
    plaintext/ciphertext pairs" in 
    ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/plans/Translations.hpp). 
    </li>
    <li> Therefore, experiments detailed within this plans file consider taking
    various AES SAT translations, setting all plaintext variables, all 
    ciphertext variables (to the appropriate values given the plaintext and the
    AES algorithm) and then setting "n" key bits where "n" ranges from 1 to the
    total number of key bits (128 in most cases). </li>
    <li> To "break" AES, the idea is obviously to leave all key variables
    unset. </li>
    <li> Setting some key variables, rather than leaving all key variables
    unset can be done to produce easier to solve SAT problems that can be used
    to determine the behaviour of different solvers as the number of unknown
    key variables increases. </li>
    </li>
   </ul>
   </li>
   <li> For such experiments, when considering experiments where some key bits 
   are specified, there is the question of which key bits to specify. To avoid
   situations where knowing some key bits might be more advantageous than 
   others (and so the experimental results not being representative of the 
   AES as a whole), there is the need to randomise which key bits are
   specified. (See "Randomly choosing 'unknown' block bits" in 
   ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/plans/general.hpp.) 
   </li>
   <li> The main question considered here is:  Given fully specified 128-bit 
    plaintext and the associated ciphertext and a number of rounds r (1-10), 
    how many key bits may be left unspecified before the SAT problem becomes 
    infeasible? </li>
    <li> See 
    Experimentation/Investigations/Cryptography/AdvancedEncryptionStandard/plans/BreakingAES_R2-6.hpp
    for experiments investigating this question for reduced round variants of 
    AES with less than 7 rounds. </li>
    <li> See 
    Experimentation/Investigations/Cryptography/AdvancedEncryptionStandard/plans/BreakingAES_R7-10.hpp
    for experiments investigating this question for reduced round variants of 
    AES with 7 rounds or more. </li>
  </ul>

  
  \todo Generating experiment/test blocks
  <ul>
   <li> For simple experiments we can simply use trivial plaintext and key 
   blocks such as all zero plaintext and key blocks, and then consider the 
   ciphertext which is generated by AES for such blocks. </li>
   <li> To experiment properly however, one needs truly random plaintext and 
   key blocks, randomly distributed in a well-defined and understood manner,
   and such randomisation much be reproducible (so we must store seeds etc
   and the algorithm must be well-defined). </li>
   <li> See "Generating randomised AES parameters" in 
   ComputerAlgebra/Cryptology/Lisp/CryptoSystems/Rijndael/plans/AdvancedEncryptionStandard.hpp
   for random block generation. </li>
   <li> See also "Randomly choosing 'unknown' block bits" in 
   ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/plans/general.hpp 
   for random choosing of "unknown" block bits. </li>
   <li> Provided below is some initial code for generating experiments, however
   this needs to be rewritten (based on structural changes being made to the 
   AES translation) and moved into scripts:
   <ul>
    <li> To generate instances of AES as a SAT problem where the primary
    variables are the plaintext, key and ciphertext (each 128 variables),
    the following code generates problem instances as described below: 
    \verbatim
removeTopNVars(C,n) := subset(C, lambda([a], is(abs(a) <= (uaapply(max,listify(map(abs,C))) - n))));

hex2il(h) := block([cl],
  cl : charlist(h),
  print(cl),
  return(map(lambda([b], hex2int(simplode(b))), partition_elements(cl,2)))
)$

gen_uc_ass_aes(ph, pbn, kh ,kbn,ch, cbn) := block(
  return(
    map(lambda([a],{a}),union(
      removeTopNVars(AESHexToPA(ph,aes_make_vars_int("p",1,128)),pbn),
      removeTopNVars(AESHexToPA(kh,aes_make_vars_int("k",1,128)),kbn),
      removeTopNVars(AESHexToPA(ch,aes_make_vars_int("c",1,128)),cbn)))));

gen_uc_ass_aes_comp(ph, pbn, kh ,kbn, cbn) := block([ch],
 ch : il2hex(transpose_l(
         aes_encrypt_l(
           hex2il(ph),
           hex2il(kh)),
         4)),
 return(gen_uc_ass_aes(ph,pbn,kh,kbn,ch,cbn))
)$
plaintext_hex : "32488853038D31734198AA2E0370D450"$
key_hex : "3F6A2B7E151628AED2A6ABF7158809CF"$
for r from 2 step 1 thru 10 do block([aes_num_rounds:r],
  aes_cs : aes_cnf_fcs(),
  output_cs_f(sconcat("AES r=",r," NPKC"),aes_cs,sconcat("AES_r",r,".cnf")),
  ch: apply(sconcat,map(lambda([s],lpad(int2hex(s),"0",2)),
    aes_encrypt_l(
      hex2il(plaintext_hex),
      hex2il(key_hex)))
    ),
  for pn from 0 thru 0 do (
    for kn from 0 step 2 thru 64 do (
      for cn from 0 thru 0 do block(
        output_cs_f(
          sconcat("AES UC R=",r," PN=",pn,"KN=",kn,"CN=",cn,
            "P=",plaintext_hex,"K=",key_hex),
          cs_to_fcs(gen_uc_ass_aes(plaintext_hex,pn,key_hex,kn,ch,cn)),
          sconcat("AES_UC_r",r,"_pn",pn,"_kn",kn,"_cn",cn,
            "_P",plaintext_hex,"_K",key_hex,".cnf")),
        print(sconcat("AES UC R=",r," PN=",pn,"KN=",kn,"CN=",cn,
           " P=",plaintext_hex,"K=",key_hex))))));
    \endverbatim
    The above code generates files "AES_r2.cnf" (for round 2 for example) 
    containing the main AES translation (with no variable assignments) and then 
    "AES_UC_r2_pn0_kn0_cn0_P32488853038D31734198AA2E0370D450_K3F6A2B7E151628AED2A6ABF7158809CF.cnf"
    as the unit clauses for setting up a two round AES translation with all 
    plaintext, key and ciphertext bits set and the plaintext and key
    provided as "32488853038D31734198AA2E0370D450" and
    "3F6A2B7E151628AED2A6ABF7158809CF" in the standard AES format.
    </li>
    <li> To merge the AES translation cnf with the assignment unit clauses 
    generated, the following script generates the problem instances: 
    \verbatim
#!/bin/bash

# Grab the number of clauses from each
CL1=`grep "^p" $1  | cut -d " " -f "4"`
CL2=`grep "^p" $2  | cut -d " " -f "4"`

NewCL=`expr $CL1 + $CL2`
cat $1 | sed -e "s/p \+\([a-zA-Z]\+\) \+\([0-9]\+\).*$/p \1 \2 $NewCL/"
cat $2 | grep -v "^p"
    \endverbatim
    called "mergeSameVarCNFs.sh" and can be used in the following way: 
    \verbatim
./mergeSameVarCNFs.sh AES_r2.cnf AES_UC_r2_pn0_kn32_cn0_P00000000000000000000000000000000_K00000000000000000000000000000000.cnf > AES_r2_kn_32_P00000000000000000000000000000000_K00000000000000000000000000000000_SAT.cnf   
    \endverbatim
    </li>
    <li> For experimentation, the following is then an example for 
    running a particular SAT solver (minisat in the example below) on the given
    problem instance:
    \verbatim
for k in `seq 0 32 128`; do
  for r in `seq 2 2 10`; do
    echo "K = " $k "R = " $r;
    ./mergeSameVarCNFs.sh "AES_r${r}.cnf" "AES_UC_r${r}_pn0_kn${k}_cn0_P00000000000000000000000000000000_K00000000000000000000000000000000.cnf" > "AES_r${r}_k   n_${k}_P00000000000000000000000000000000_K00000000000000000000000000000000_SAT.cnf" ;
    time ./solvers/minisat/core/minisat "AES_r${r}_kn_${k}_P00000000000000000000000000000000_K00000000000000000000000000000000_SAT.cnf" > "AES_r${r}_kn_${k}_P   00000000000000000000000000000000_K00000000000000000000000000000000_SAT.cnf.results.minisat" 2> "AES_r${r}_kn_${k}_P00000000000000000000000000000000_K000000000   00000000000000000000000_SAT.cnf.results.minisat" ;
  done
done
    \endverbatim
    </li>
   </ul>
   </li>
  </ul>


  \todo Computing AES ciphertext given full 128-bit key and plaintext
  <ul>
   <li> Question here is: Given the current translation, how well can a SAT
   solver perform a simple AES computation? </li>
   <li> It should be that through unit clause propagation etc, the SAT solver
   should be very quick? </li>
   <li> See 
   Experimentation/Investigations/Cryptography/AdvancedEncryptionStandard/plans/minisat2.hpp
   for results using minisat2. </li>
   <li> Add results for other solvers. </li>
  </ul>


  \todo Determining a "good" local search algorithm to use on AES instances
  <ul>
   <li> Question: what is a good algorithm to use, considering the algorithms
   tested by "eval_ubcsat" (see 
   Experimentation/ExperimentSystem/ControllingLocalSearch/Evaluation.R) </li>
   <li> Presumably local search will not do well on AES instances compared to 
   DPLL/CDCL solvers, as often local search solvers perform comparatively
   poorly on industrial and crafted instances, which the AES translations
   are likely similar to. </li>
   <li> What sort of metrics to use to determine a good algorithm once the
   experiment has been run?
   <ul>
    <li> Sorting first by the average number of falsified clauses and then
    by the number of steps seems reasonable, as we wish to minimise the number
    of falsified clauses as much as possible. </li>
   </ul>
   </li>
  </ul>

*/
