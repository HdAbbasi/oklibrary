// Matthew Gwynne, 6.8.2009 (Swansea)
/* Copyright 2009 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file Experimentation/Investigations/Cryptography/AdvancedEncryptionStandard/plans/FieldMulInvestigations.hpp
  \brief On investigations into the AES field multiplications


  \todo Number of prime implicates for Field multiplications
  <ul>
   <li> Currently, within the SAT translation, the most powerful representation
   of the Field operations used within the AES SAT translation (such as 
   multiplication by 02, 03 etc within Rijndael's byte field, see XXX) is the 
   canonical translation using new variables (see "dualts_fcl" in XXX). </li>
   <li> However, the most powerful representation of any boolean function, not 
   considering size of the translation is always the set of prime implicates. 
   </li>
   <li> In general, the set of prime implicates for a given boolean function is
   prohibitively large, such as is the case with the Sbox with > 100000
   clauses. </li>
   <li> This is not always the case though, as the size and structure of the 
   set of prime implicates for each of the field multiplication functions must
   be checked. </li>
   <li> Small set of prime implicates would provide much better representations
   than "dualts_fcl" produces, as then there is no problem that the SAT solver
   might somehow get "lost" branching or basing it's heuristics on the new 
   variables, and if the set of prime implicates is small enough, it might
   even be smaller than the "dualts_fcl" translation. </li>
   <li> Given an integer representation (??? what is an "integer 
   representation" ? ACTION required from MG), the full CNF representation of 
   the boolean function for multiplication by a constant factor n in Rijndael's
   byte-field, where n is an integer (see XXX), can be generated by:
   \verbatim
output_full_aes_field_mul_cnf(n);
   \endverbatim
   and the prime implicates can be generated using:
   \verbatim
QuineMcCluskey-n16-O3-DNDEBUG AES_byte_field_mul_full_n.cnf > AES_byte_field_mul_full_n.pi
   \endverbatim
   and getting the minimum and maximum prime-clause lengths:
USE a general tool here! For example the OKsolver_2002. ACTION required from 
MG.
   \verbatim
N=2;cat AES_byte_field_mul_full_${N}.pi | while read x; do CLAUSECOUNT=`echo $x | wc -w`; echo `expr $CLAUSECOUNT - 1`; done | sort > AES_byte_field_mul_full_${N}.stats; cat AES_byte_field_mul_full_${N}.stats | head -n 1; cat AES_byte_field_mul_full_${N}.stats | tail -n 1
   \endverbatim
   </li>
   <li> Multiplication by 1: </li>
   <li> Multiplication by 2:
   <ul>
    <li> There are 58 prime implicates for multiplication by 2. </li>
    <li> The minimal size prime clause is 2. </li>
    <li> The maximal size prime clause is 4. </li>
    <li> This is to be expected (???) as multiplication by 2 is a very simple
    operation. </li>
    <li> In this case, representing multiplication by 02 by all it's prime
    implicates seems the only real solution, given such a small number. </li>
   </ul>
   </li>
   <li> Multiplication by 3:
   <ul>
    <li> There are 5048 prime implicates for multiplication by 3. </li>
    <li> The minimal size prime clause is 3. </li>
    <li> The maximal size prime clause is 9. </li>
   </ul>
   </li>
   <li> Multiplication by 9:
   <ul>
    <li> There are 7840 prime implicates for multiplication by 9. </li>
    <li> The minimal size prime clause is 3. </li>
    <li> The maximal size prime clause is 9. </li>
   </ul>
   </li>
   <li> Multiplication by 11:
   <ul>
    <li> There are 15008 prime implicates for multiplication by 11. </li>
    <li> The minimal size prime clause is 4. </li>
    <li> The maximal size prime clause is 9. </li>
   </ul>
   </li>
   <li> Multiplication by 13:
   <ul>
    <li> There are 15312 prime implicates for multiplication by 13. </li>
    <li> The minimal size prime clause is 4. </li>
    <li> The maximal size prime clause is 9. </li>
   </ul>
   </li>
   <li> Multiplication by 14:
   <ul>
    <li> There are 14300 prime implicates for multiplication by 14. </li>
    <li> The minimal size prime clause is 3. </li>
    <li> The maximal size prime clause is 9. </li>
   </ul>
   </li>
   <li> We need to handle all multiplications; and we need the size (and
   number) of minimum CNF representations. </li>
   <li> It would be nice here to be able to read the clause-sets into the
   Maxima system, where we have statistics_fcl etc. (see "Input and output" in 
   ComputerAlgebra/Satisfiability/Lisp/ClauseSets/plans/general.hpp). </li>
  </ul>


  \todo Add todos ??? ACTION required from MG

*/
